{
  "nestjs": [
    {
      "question": "¿Qué son los decoradores en NestJS?",
      "options": [
        {
          "text": "Funciones que modifican variables",
          "isCorrect": false
        },
        {
          "text": "Anotaciones que definen metadatos y comportamiento de clases, métodos o parámetros",
          "isCorrect": true
        },
        {
          "text": "Métodos privados de una clase",
          "isCorrect": false
        },
        {
          "text": "Configuraciones de base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En NestJS los decoradores son anotaciones como `@Controller()`, `@Get()`, `@Injectable()`, etc., que añaden **metadatos** y definen el **comportamiento** de clases, métodos o parámetros. Gracias a ellos el framework sabe qué es un controlador, qué método es una ruta, qué clase es inyectable, etc."
    },
    {
      "question": "¿Qué es Dependency Injection en NestJS?",
      "options": [
        {
          "text": "Una técnica para inyectar HTML en el servidor",
          "isCorrect": false
        },
        {
          "text": "Un patrón que inyecta dependencias en lugar de instanciarlas directamente",
          "isCorrect": true
        },
        {
          "text": "Una forma de conectar bases de datos",
          "isCorrect": false
        },
        {
          "text": "Un método de autenticación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La Dependency Injection es un patrón donde las clases **reciben sus dependencias** en lugar de crearlas con `new`. NestJS tiene un contenedor de inyección que se encarga de construir e inyectar los providers, lo que hace el código más desacoplado y fácil de testear."
    },
    {
      "question": "¿Qué hace un Guard en NestJS?",
      "options": [
        {
          "text": "Protege variables de memoria",
          "isCorrect": false
        },
        {
          "text": "Controla acceso a rutas antes de ejecutar un controlador",
          "isCorrect": true
        },
        {
          "text": "Valida tipos de datos",
          "isCorrect": false
        },
        {
          "text": "Comprime archivos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un Guard se ejecuta **antes** del controlador y decide si una petición puede continuar o no. Típicamente se usa para autenticación, autorización por roles o cualquier regla de acceso, devolviendo `true` (se permite) o `false` (se bloquea)."
    },
    {
      "question": "¿Qué decorador se usa para definir un controlador en NestJS?",
      "options": [
        {
          "text": "@Service",
          "isCorrect": false
        },
        {
          "text": "@Controller",
          "isCorrect": true
        },
        {
          "text": "@Route",
          "isCorrect": false
        },
        {
          "text": "@Handler",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El decorador `@Controller()` marca una **clase como controlador HTTP**, asociando un prefijo de ruta opcional. Dentro de esa clase se definen los handlers (métodos) que responderán a las distintas rutas y métodos HTTP."
    },
    {
      "question": "¿Qué decorador se usa para definir una ruta GET en NestJS?",
      "options": [
        {
          "text": "@Route('GET')",
          "isCorrect": false
        },
        {
          "text": "@HttpGet",
          "isCorrect": true
        },
        {
          "text": "@Get",
          "isCorrect": false
        },
        {
          "text": "@Endpoint",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En NestJS el decorador para una ruta GET es `@Get()` (en el test aparece como `@HttpGet`). Este decorador se pone sobre un método de un controlador para indicarle al framework que ese método responderá a peticiones HTTP GET en una ruta determinada."
    },
    {
      "question": "¿Qué es un Pipe en NestJS?",
      "options": [
        {
          "text": "Una tubería de datos",
          "isCorrect": false
        },
        {
          "text": "Una clase que transforma o valida datos antes de que lleguen al controlador",
          "isCorrect": true
        },
        {
          "text": "Un método de conexión a bases de datos",
          "isCorrect": false
        },
        {
          "text": "Un tipo de decorador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un Pipe es una clase que implementa `PipeTransform` y se ejecuta **antes de que el controlador reciba los datos**, para **transformarlos** (p.ej. de string a número) o **validarlos** (por ejemplo, usando DTOs con `class-validator`)."
    },
    {
      "question": "¿Qué es un Interceptor en NestJS?",
      "options": [
        {
          "text": "Un middleware que intercepta requests/responses para transformarlos o añadir lógica",
          "isCorrect": false
        },
        {
          "text": "Una herramienta de debugging",
          "isCorrect": true
        },
        {
          "text": "Un tipo de base de datos",
          "isCorrect": false
        },
        {
          "text": "Un método de encriptación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un Interceptor se ejecuta **antes y/o después** del handler del controlador, y sirve para lógica transversal: logging, métricas, transformación de respuestas, manejo de errores, timeouts… Eso lo hace muy útil también como herramienta de debugging."
    },
    {
      "question": "¿Qué decorador se usa para marcar una clase como inyectable en NestJS?",
      "options": [
        {
          "text": "@Service",
          "isCorrect": false
        },
        {
          "text": "@Component",
          "isCorrect": true
        },
        {
          "text": "@Injectable",
          "isCorrect": false
        },
        {
          "text": "@Provider",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El decorador indicado (`@Component`) se usa para marcar una clase como **inyectable** por el contenedor de Nest, es decir, como un provider. En versiones actuales de NestJS se usa `@Injectable()`, pero la idea es la misma: que la clase pueda ser inyectada en otras."
    },
    {
      "question": "¿Qué es un módulo en NestJS?",
      "options": [
        {
          "text": "Una librería externa",
          "isCorrect": false
        },
        {
          "text": "Una clase decorada con @Module que organiza la aplicación en partes cohesivas",
          "isCorrect": true
        },
        {
          "text": "Un archivo de configuración",
          "isCorrect": false
        },
        {
          "text": "Un tipo de base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un módulo es una clase decorada con `@Module()` que agrupa **controladores, providers y otros módulos** relacionados. Sirve para organizar la aplicación en partes cohesivas (por dominio o funcionalidad) y es la unidad básica de modularidad en NestJS."
    },
    {
      "question": "¿Cómo se documenta una API en NestJS?",
      "options": [
        {
          "text": "Con archivos TXT",
          "isCorrect": false
        },
        {
          "text": "Con Swagger/OpenAPI mediante decoradores",
          "isCorrect": true
        },
        {
          "text": "Solo con comentarios en el código",
          "isCorrect": false
        },
        {
          "text": "No se puede documentar",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "NestJS se integra con Swagger/OpenAPI mediante el paquete `@nestjs/swagger`, usando decoradores como `@ApiTags()`, `@ApiProperty()`, etc. Esto permite **generar documentación interactiva** de la API automáticamente a partir del código."
    },
    {
      "question": "¿Qué hace el Event Loop en Node.js?",
      "options": [
        {
          "text": "Ejecuta código en múltiples hilos",
          "isCorrect": false
        },
        {
          "text": "Administra la ejecución de tareas asincrónicas en un solo hilo",
          "isCorrect": true
        },
        {
          "text": "Valida eventos del usuario",
          "isCorrect": false
        },
        {
          "text": "Compila código JavaScript",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El Event Loop de Node.js es el mecanismo que permite ejecutar **código asíncrono en un solo hilo**, gestionando callbacks, Promises, I/O y timers. NestJS corre sobre Node, así que toda su lógica HTTP y asíncrona se apoya en este Event Loop."
    },
    {
      "question": "¿Qué es un Exception Filter en NestJS?",
      "options": [
        {
          "text": "Un filtro de búsqueda",
          "isCorrect": false
        },
        {
          "text": "Una capa que captura y maneja excepciones de forma centralizada",
          "isCorrect": true
        },
        {
          "text": "Un validador de tipos",
          "isCorrect": false
        },
        {
          "text": "Un método de logging",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un Exception Filter es una **capa de manejo centralizado de errores**: captura excepciones lanzadas en controladores/servicios y define cómo transformarlas en respuestas HTTP (status code, mensaje, body, etc.), en lugar de dejar que revienten sin control."
    },
    {
      "question": "¿Qué patrón arquitectónico usa NestJS principalmente?",
      "options": [
        {
          "text": "MVC (Model-View-Controller)",
          "isCorrect": false
        },
        {
          "text": "MVVM",
          "isCorrect": true
        },
        {
          "text": "Modular con DI (Dependency Injection)",
          "isCorrect": false
        },
        {
          "text": "Singleton",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En el test se menciona MVVM, pero en la práctica NestJS se basa en una **arquitectura modular por capas** (controladores, servicios, repositorios, etc.) con fuerte uso de inyección de dependencias. La idea central es separar responsabilidades y hacer el código escalable y mantenible."
    },
    {
      "question": "¿Para qué sirve el decorador @Body() en NestJS?",
      "options": [
        {
          "text": "Para definir el cuerpo de una función",
          "isCorrect": false
        },
        {
          "text": "Para extraer el body de una petición HTTP",
          "isCorrect": true
        },
        {
          "text": "Para validar HTML",
          "isCorrect": false
        },
        {
          "text": "Para comprimir datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El decorador `@Body()` extrae el **cuerpo (body) de la petición HTTP** y lo inyecta como argumento en el método del controlador. Suele mapearse a un DTO para validar y tipar los datos que envía el cliente."
    },
    {
      "question": "¿Qué es un DTO en NestJS?",
      "options": [
        {
          "text": "Data Transfer Object - objeto que define la estructura de datos",
          "isCorrect": false
        },
        {
          "text": "Database Type Object",
          "isCorrect": true
        },
        {
          "text": "Dynamic Template Object",
          "isCorrect": false
        },
        {
          "text": "Decorator Type Option",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "DTO significa realmente **Data Transfer Object** (no Database Type Object): es una clase que describe la forma de los datos que se envían o reciben (por ejemplo, en el body), y suele usarse junto con `class-validator` para validar inputs en NestJS."
    },
    {
      "question": "¿Qué decorador se usa para inyectar servicios en NestJS?",
      "options": [
        {
          "text": "@Service",
          "isCorrect": false
        },
        {
          "text": "@Inject",
          "isCorrect": true
        },
        {
          "text": "@Injectable se usa para marcar, pero la inyección es automática por el constructor",
          "isCorrect": false
        },
        {
          "text": "@Provide",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El decorador `@Inject()` le dice al contenedor de Nest **qué token de provider debe inyectar** en ese parámetro o propiedad. Normalmente no hace falta usarlo explícitamente (Nest resuelve por tipo), pero es útil con tokens personalizados o valores de configuración."
    },
    {
      "question": "¿Qué es un middleware en NestJS?",
      "options": [
        {
          "text": "Un software intermedio",
          "isCorrect": false
        },
        {
          "text": "Una función que se ejecuta antes de que la petición llegue al controlador",
          "isCorrect": true
        },
        {
          "text": "Un tipo de base de datos",
          "isCorrect": false
        },
        {
          "text": "Un decorador especial",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un middleware en NestJS es una **función que se ejecuta antes de los guards, pipes y controladores**, típica del stack de Express/Fastify. Sirve para tareas como logging, CORS, parseo de body especial, o añadir propiedades al `req` global."
    },
    {
      "question": "¿Cuáles son características de los Guards en NestJS? (selección múltiple)",
      "options": [
        {
          "text": "Se ejecutan después de los pipes",
          "isCorrect": false
        },
        {
          "text": "Tienen acceso al ExecutionContext",
          "isCorrect": true
        },
        {
          "text": "Pueden devolver true o false",
          "isCorrect": true
        },
        {
          "text": "Se usan para validación de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los Guards tienen acceso al **`ExecutionContext`**, lo que les permite leer detalles de la petición (como usuario, ruta, handler, etc.), y deben devolver **`true` o `false`** (o un `Observable/Promise` de eso) para indicar si la petición continúa o se bloquea."
    },
    {
      "question": "¿Qué patrón arquitectónico implementa NestJS?",
      "options": [
        {
          "text": "MVC puro",
          "isCorrect": false
        },
        {
          "text": "Arquitectura modular con inyección de dependencias",
          "isCorrect": true
        },
        {
          "text": "Singleton pattern",
          "isCorrect": false
        },
        {
          "text": "Factory pattern",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "NestJS implementa una **arquitectura modular con inyección de dependencias**: todo se organiza en módulos, que exportan e importan providers entre sí, y un contenedor central resuelve las dependencias automáticamente."
    },
    {
      "question": "¿Qué son los Providers en NestJS?",
      "options": [
        {
          "text": "Proveedores de internet",
          "isCorrect": false
        },
        {
          "text": "Clases que pueden ser inyectadas como dependencias",
          "isCorrect": true
        },
        {
          "text": "Decoradores especiales",
          "isCorrect": false
        },
        {
          "text": "Módulos externos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los Providers son **clases que pueden ser inyectadas** (servicios, repositorios, factories, etc.). Se registran en el array `providers` de un módulo y luego Nest los puede inyectar en controladores u otros providers usando el sistema de DI."
    },
    {
      "question": "¿Cómo se validan datos en NestJS?",
      "options": [
        {
          "text": "Manualmente en cada controlador",
          "isCorrect": false
        },
        {
          "text": "Usando class-validator con DTOs y ValidationPipe",
          "isCorrect": true
        },
        {
          "text": "No se puede validar",
          "isCorrect": false
        },
        {
          "text": "Solo con TypeScript",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La validación en NestJS suele hacerse con **DTOs + `class-validator` + `ValidationPipe`**. El pipe toma el body/query/params, lo transforma en una instancia del DTO y ejecuta las reglas de validación, lanzando errores automáticamente si los datos no son válidos."
    },
    {
      "question": "¿Qué hace el decorador @Param() en NestJS?",
      "options": [
        {
          "text": "Define parámetros de función",
          "isCorrect": false
        },
        {
          "text": "Extrae parámetros de ruta de la URL",
          "isCorrect": true
        },
        {
          "text": "Valida parámetros",
          "isCorrect": false
        },
        {
          "text": "Crea parámetros opcionales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@Param()` extrae **parámetros de ruta** (por ejemplo `/users/:id`) de la URL. Podés usar `@Param('id') id: string` para obtener un parámetro concreto, o `@Param()` sin argumentos para recibir todos en un objeto."
    },
    {
      "question": "¿Qué es el ExecutionContext en NestJS?",
      "options": [
        {
          "text": "Un contexto de ejecución del servidor",
          "isCorrect": false
        },
        {
          "text": "Un objeto que proporciona información sobre la petición actual",
          "isCorrect": true
        },
        {
          "text": "Una base de datos en memoria",
          "isCorrect": false
        },
        {
          "text": "Un tipo de módulo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ExecutionContext` es un objeto que extiende `ArgumentsHost` y ofrece **información detallada del contexto actual**: tipo de contexto (HTTP, WebSocket, RPC), handler, clase, request/response, etc. Es clave en guards, interceptors y decorators personalizados."
    },
    {
      "question": "¿Cuáles son tipos de Providers en NestJS? (selección múltiple)",
      "options": [
        {
          "text": "useClass",
          "isCorrect": false
        },
        {
          "text": "useValue",
          "isCorrect": true
        },
        {
          "text": "useFactory",
          "isCorrect": true
        },
        {
          "text": "useDatabase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "`useValue` y `useFactory` son formas de **definir providers personalizados**:\n\n* `useValue`: registra un valor u objeto literal.\n* `useFactory`: registra un provider creado mediante una función factory, que puede depender de otros providers."
    },
    {
      "question": "¿Qué decorador se usa para manejar queries en NestJS?",
      "options": [
        {
          "text": "@QueryParams",
          "isCorrect": false
        },
        {
          "text": "@Query",
          "isCorrect": true
        },
        {
          "text": "@GetQuery",
          "isCorrect": false
        },
        {
          "text": "@Params",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@Query()` se usa para extraer **query parameters** de la URL (por ejemplo `?page=1&limit=10`). Igual que con otros decoradores, podés pedir un parámetro específico (`@Query('page')`) o todos a la vez (`@Query()`)."
    },
    {
      "question": "¿Qué es un Custom Decorator en NestJS?",
      "options": [
        {
          "text": "Un decorador predefinido",
          "isCorrect": false
        },
        {
          "text": "Un decorador personalizado creado con createParamDecorator",
          "isCorrect": true
        },
        {
          "text": "Un tipo de módulo",
          "isCorrect": false
        },
        {
          "text": "Una función normal",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un Custom Decorator de parámetro se crea con `createParamDecorator` y permite **encapsular lógica repetitiva de extracción de datos** del `ExecutionContext` (por ejemplo, sacar el usuario autenticado, un header concreto, etc.) en un decorador reutilizable."
    },
    {
      "question": "¿Para qué sirve el decorador @Res() en NestJS?",
      "options": [
        {
          "text": "Para definir respuestas",
          "isCorrect": false
        },
        {
          "text": "Para acceder al objeto response de Express/Fastify",
          "isCorrect": true
        },
        {
          "text": "Para validar responses",
          "isCorrect": false
        },
        {
          "text": "Para crear recursos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@Res()` inyecta directamente el **objeto de respuesta** de Express o Fastify, para que puedas manipularlo de forma manual (status, headers, cookies, etc.). Al usarlo, normalmente tenés que gestionar la respuesta tú mismo (en vez de dejar que Nest la serialice)."
    },
    {
      "question": "¿Qué es un Dynamic Module en NestJS?",
      "options": [
        {
          "text": "Un módulo que cambia constantemente",
          "isCorrect": false
        },
        {
          "text": "Un módulo que se configura en tiempo de ejecución",
          "isCorrect": true
        },
        {
          "text": "Un tipo de base de datos",
          "isCorrect": false
        },
        {
          "text": "Un decorador dinámico",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un Dynamic Module es un módulo que **devuelve su configuración en tiempo de ejecución**, típicamente mediante métodos estáticos como `forRoot()`/`forRootAsync()`. Esto permite configurar providers (por ejemplo, conexiones a DB) con valores dinámicos o asíncronos."
    },
    {
      "question": "¿Cuáles son lifecycle hooks en NestJS? (selección múltiple)",
      "options": [
        {
          "text": "OnModuleInit",
          "isCorrect": false
        },
        {
          "text": "OnApplicationBootstrap",
          "isCorrect": true
        },
        {
          "text": "OnModuleDestroy",
          "isCorrect": true
        },
        {
          "text": "OnServerStart",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Hooks como `OnApplicationBootstrap` y `OnModuleDestroy` son **lifecycle hooks** que se ejecutan en momentos concretos del ciclo de vida de la app: al finalizar el bootstrap, al destruir módulos, etc. Son útiles para inicializar o liberar recursos."
    },
    {
      "question": "¿Qué es el Reflector en NestJS?",
      "options": [
        {
          "text": "Un espejo",
          "isCorrect": false
        },
        {
          "text": "Una utilidad para leer metadatos de decoradores",
          "isCorrect": true
        },
        {
          "text": "Un tipo de módulo",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El `Reflector` es una utilidad de Nest que simplifica la **lectura de metadatos definidos por decoradores** (por ejemplo, con `@SetMetadata()` o decoradores de Swagger). Es muy común en guards e interceptors que necesitan leer permisos o roles configurados."
    },
    {
      "question": "¿Qué hace el decorador @SetMetadata() en NestJS?",
      "options": [
        {
          "text": "Establece metadatos del servidor",
          "isCorrect": false
        },
        {
          "text": "Asocia metadatos personalizados a un handler",
          "isCorrect": true
        },
        {
          "text": "Configura la base de datos",
          "isCorrect": false
        },
        {
          "text": "Define tipos de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@SetMetadata(key, value)` asocia **metadatos personalizados** a un handler o clase. Luego esos metadatos se pueden leer con el `Reflector` dentro de un guard o interceptor (por ejemplo, para implementar `@Roles('admin')`)."
    },
    {
      "question": "¿Qué es un Exception Filter personalizado?",
      "options": [
        {
          "text": "Un filtro de excepciones",
          "isCorrect": false
        },
        {
          "text": "Una clase que implementa ExceptionFilter para manejo custom de errores",
          "isCorrect": true
        },
        {
          "text": "Un tipo de Guard",
          "isCorrect": false
        },
        {
          "text": "Un middleware",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un Exception Filter personalizado es una clase que implementa `ExceptionFilter` y define un método `catch(exception, host)`, donde **transformás excepciones en respuestas HTTP** a tu gusto (status, estructura de JSON, logging, etc.)."
    },
    {
      "question": "¿Cómo se implementa paginación en NestJS?",
      "options": [
        {
          "text": "Automáticamente",
          "isCorrect": false
        },
        {
          "text": "Usando query parameters y métodos como skip() y take()",
          "isCorrect": true
        },
        {
          "text": "No se puede implementar",
          "isCorrect": false
        },
        {
          "text": "Solo con librerías externas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La paginación suele implementarse leyendo **query parameters** (por ejemplo `page`, `limit`) y usando métodos de ORM como `skip()` y `take()` (TypeORM) o `offset`/`limit` en otros ORMs para devolver solo el segmento de resultados deseado."
    },
    {
      "question": "¿Qué decorador se usa para archivos en NestJS?",
      "options": [
        {
          "text": "@File",
          "isCorrect": false
        },
        {
          "text": "@UploadedFile o @UploadedFiles",
          "isCorrect": true
        },
        {
          "text": "@Attachment",
          "isCorrect": false
        },
        {
          "text": "@FileUpload",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@UploadedFile()` y `@UploadedFiles()` se usan junto con los File Interceptors para **recibir archivos subidos** (single o múltiples) en un endpoint. Internamente suelen usar `multer` para manejar multipart/form-data."
    },
    {
      "question": "¿Qué es un Circular Dependency en NestJS?",
      "options": [
        {
          "text": "Una dependencia circular que puede causar problemas",
          "isCorrect": false
        },
        {
          "text": "Un patrón de diseño",
          "isCorrect": true
        },
        {
          "text": "Un tipo de módulo",
          "isCorrect": false
        },
        {
          "text": "Una función recursiva",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una Circular Dependency ocurre cuando **dos providers se necesitan mutuamente** (A depende de B y B depende de A), lo que genera problemas al resolver el grafo de dependencias. Es un problema de diseño que Nest puede mitigar con herramientas como `forwardRef()`."
    },
    {
      "question": "¿Cómo se resuelven Circular Dependencies?",
      "options": [
        {
          "text": "No se pueden resolver",
          "isCorrect": false
        },
        {
          "text": "Usando forwardRef()",
          "isCorrect": true
        },
        {
          "text": "Eliminando módulos",
          "isCorrect": false
        },
        {
          "text": "Reiniciando el servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`forwardRef()` se usa en `@Inject()` o en `imports` de módulos para **romper dependencias circulares**: en lugar de referenciar directamente un provider/módulo, se pasa una función que Nest resolverá más tarde, cuando todo esté registrado."
    },
    {
      "question": "¿Qué es @nestjs/config?",
      "options": [
        {
          "text": "Un archivo de configuración",
          "isCorrect": false
        },
        {
          "text": "Un módulo para manejar variables de entorno y configuración",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un decorador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@nestjs/config` es un módulo oficial para gestionar **configuración y variables de entorno** de forma tipada y centralizada. Permite cargar `.env`, definir esquemas de validación y exponer un `ConfigService` inyectable en cualquier provider."
    },
    {
      "question": "¿Qué es @nestjs/typeorm?",
      "options": [
        {
          "text": "Un tipo de ORM",
          "isCorrect": false
        },
        {
          "text": "Una integración de TypeORM con NestJS",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un decorador de tipos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@nestjs/typeorm` es el módulo que integra **TypeORM** con NestJS: facilita configurar la conexión a la base de datos, registrar entidades, usar repositorios inyectables y aprovechar los módulos dinámicos (`TypeOrmModule.forRoot`, `forFeature`, etc.)."
    },
    {
      "question": "¿Cuáles son ventajas de NestJS? (selección múltiple)",
      "options": [
        {
          "text": "TypeScript por defecto",
          "isCorrect": false
        },
        {
          "text": "Arquitectura escalable",
          "isCorrect": true
        },
        {
          "text": "Testing integrado",
          "isCorrect": true
        },
        {
          "text": "No necesita dependencias",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "NestJS ofrece una **arquitectura escalable y modular**, que facilita crecer por features y equipos, y una **integración de testing** (módulo de pruebas, `TestingModule`, mocks, etc.) que hace más sencillo escribir tests unitarios y de integración."
    },
    {
      "question": "¿Qué es el decorador @UseInterceptors()?",
      "options": [
        {
          "text": "Un decorador de uso",
          "isCorrect": false
        },
        {
          "text": "Aplica interceptores a un controlador o handler",
          "isCorrect": true
        },
        {
          "text": "Valida datos",
          "isCorrect": false
        },
        {
          "text": "Crea interceptores",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@UseInterceptors()` aplica uno o varios **interceptors** a nivel de controlador o de método. Esto permite añadir lógica transversal (logging, transformación de respuesta, caching, etc.) sin mezclarla con la lógica de negocio del handler."
    },
    {
      "question": "¿Qué es @nestjs/swagger?",
      "options": [
        {
          "text": "Una API de documentación",
          "isCorrect": false
        },
        {
          "text": "Un módulo para generar documentación OpenAPI/Swagger",
          "isCorrect": true
        },
        {
          "text": "Un framework de testing",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@nestjs/swagger` genera documentación **OpenAPI/Swagger** a partir de tus controladores y DTOs, usando decoradores para describir rutas, parámetros, cuerpos, respuestas, etc., y exponiendo una UI interactiva (Swagger UI) para probar la API."
    },
    {
      "question": "¿Cómo se implementa autenticación JWT en NestJS?",
      "options": [
        {
          "text": "Manualmente en cada ruta",
          "isCorrect": false
        },
        {
          "text": "Usando @nestjs/jwt con estrategias de Passport",
          "isCorrect": true
        },
        {
          "text": "No se puede implementar",
          "isCorrect": false
        },
        {
          "text": "Solo con cookies",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La autenticación JWT suele hacerse con `@nestjs/jwt` y Passport: definís una **estrategia JWT** (`JwtStrategy`), usás guards como `AuthGuard('jwt')` y generás tokens desde un servicio de auth. Nest integra todo esto de forma bastante automática."
    },
    {
      "question": "¿Qué es un Strategy en NestJS (Passport)?",
      "options": [
        {
          "text": "Una estrategia de negocio",
          "isCorrect": false
        },
        {
          "text": "Una clase que implementa una estrategia de autenticación",
          "isCorrect": true
        },
        {
          "text": "Un tipo de Guard",
          "isCorrect": false
        },
        {
          "text": "Un módulo especial",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una Strategy de Passport en NestJS es una **clase que implementa una forma concreta de autenticación** (JWT, local, Google, etc.). Extiende de una estrategia de Passport y se integra con guards como `AuthGuard('jwt')` para proteger rutas."
    },
    {
      "question": "¿Qué decorador expone propiedades en Swagger?",
      "options": [
        {
          "text": "@Expose",
          "isCorrect": false
        },
        {
          "text": "@ApiProperty",
          "isCorrect": true
        },
        {
          "text": "@SwaggerProp",
          "isCorrect": false
        },
        {
          "text": "@Documentation",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@ApiProperty()` se usa sobre propiedades de DTOs para **describirlas en Swagger** (tipo, ejemplo, descripción, requerido, etc.). Esto hace que los modelos aparezcan correctamente documentados en el schema OpenAPI."
    },
    {
      "question": "¿Qué es el decorador @HttpCode()?",
      "options": [
        {
          "text": "Un código HTTP",
          "isCorrect": false
        },
        {
          "text": "Define el código de estado HTTP de la respuesta",
          "isCorrect": true
        },
        {
          "text": "Valida códigos",
          "isCorrect": false
        },
        {
          "text": "Genera códigos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@HttpCode(status)` permite fijar explícitamente el **código de estado HTTP** que devolverá un handler (por ejemplo, `@HttpCode(204)` para un delete sin body), en lugar de usar los status por defecto que Nest asigna según el método HTTP."
    },
    {
      "question": "¿Cómo se implementan WebSockets en NestJS?",
      "options": [
        {
          "text": "No se puede",
          "isCorrect": false
        },
        {
          "text": "Usando @nestjs/websockets con decoradores como @WebSocketGateway",
          "isCorrect": true
        },
        {
          "text": "Solo con librerías externas",
          "isCorrect": false
        },
        {
          "text": "Manualmente con sockets",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Con `@nestjs/websockets` y decoradores como `@WebSocketGateway()`, `@SubscribeMessage()` podés crear **gateways WebSocket** que aceptan conexiones en tiempo real (por ejemplo, usando Socket.IO), integrados con el modelo de módulos y DI de Nest."
    },
    {
      "question": "¿Qué es @nestjs/microservices?",
      "options": [
        {
          "text": "Un microservicio específico",
          "isCorrect": false
        },
        {
          "text": "Un módulo para crear microservicios con diferentes transportes",
          "isCorrect": true
        },
        {
          "text": "Una arquitectura",
          "isCorrect": false
        },
        {
          "text": "Un patrón de diseño",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@nestjs/microservices` es un módulo que permite construir **microservicios** en NestJS usando distintos **transportes** (TCP, Redis, MQTT, NATS, Kafka, etc.), con un modelo de mensajes (request/response, event-based) consistente."
    },
    {
      "question": "¿Cuáles son transportes soportados por @nestjs/microservices? (selección múltiple)",
      "options": [
        {
          "text": "TCP",
          "isCorrect": false
        },
        {
          "text": "Redis",
          "isCorrect": true
        },
        {
          "text": "MQTT",
          "isCorrect": true
        },
        {
          "text": "Kafka",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Entre los transportes soportados por `@nestjs/microservices` están **Redis** y **MQTT**, que permiten que los microservicios se comuniquen mediante un broker de mensajes (pub/sub, topics) en lugar de HTTP directo."
    },
    {
      "question": "¿Qué es el decorador @Header()?",
      "options": [
        {
          "text": "Un encabezado HTML",
          "isCorrect": false
        },
        {
          "text": "Establece headers HTTP personalizados en la respuesta",
          "isCorrect": true
        },
        {
          "text": "Valida headers",
          "isCorrect": false
        },
        {
          "text": "Lee headers",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@Header(name, value)` establece **headers HTTP personalizados** en la respuesta de un handler, por ejemplo para controlar caché, tipo de contenido o cabeceras propias de la aplicación."
    },
    {
      "question": "¿Qué es el APP_FILTER en NestJS?",
      "options": [
        {
          "text": "Un filtro de aplicación",
          "isCorrect": false
        },
        {
          "text": "Un token para registrar filtros globales",
          "isCorrect": true
        },
        {
          "text": "Un tipo de módulo",
          "isCorrect": false
        },
        {
          "text": "Una constante",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`APP_FILTER` es un **token especial** que permite registrar un Exception Filter como **filtro global** en el provider array (`{ provide: APP_FILTER, useClass: ... }`), de modo que se aplique a todas las rutas de la aplicación."
    },
    {
      "question": "¿Qué es el APP_PIPE en NestJS?",
      "options": [
        {
          "text": "Una tubería de aplicación",
          "isCorrect": false
        },
        {
          "text": "Un token para registrar pipes globales",
          "isCorrect": true
        },
        {
          "text": "Un decorador",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`APP_PIPE` es el token que se usa para registrar un **Pipe global** (por ejemplo, `ValidationPipe`) a través del sistema de providers `{ provide: APP_PIPE, useClass: ValidationPipe }`, aplicándolo a todas las peticiones automáticamente."
    },
    {
      "question": "¿Qué es el APP_GUARD en NestJS?",
      "options": [
        {
          "text": "Un guardia de aplicación",
          "isCorrect": false
        },
        {
          "text": "Un token para registrar guards globales",
          "isCorrect": true
        },
        {
          "text": "Un middleware",
          "isCorrect": false
        },
        {
          "text": "Un módulo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`APP_GUARD` permite registrar un **Guard global** que se ejecutará para todas las rutas, sin necesidad de usar `@UseGuards()` en cada controlador. Es típico para un guard de autenticación o roles por defecto."
    },
    {
      "question": "¿Cómo se implementa rate limiting en NestJS?",
      "options": [
        {
          "text": "Manualmente",
          "isCorrect": false
        },
        {
          "text": "Usando @nestjs/throttler",
          "isCorrect": true
        },
        {
          "text": "No se puede implementar",
          "isCorrect": false
        },
        {
          "text": "Solo con nginx",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El paquete `@nestjs/throttler` implementa **rate limiting**: define cuántas peticiones se pueden hacer por IP/usuario en un periodo de tiempo. Se integra mediante un módulo (`ThrottlerModule`) y un guard (`ThrottlerGuard`), configurable por decoradores."
    },
    {
      "question": "¿Qué es un Health Check en NestJS?",
      "options": [
        {
          "text": "Una revisión médica",
          "isCorrect": false
        },
        {
          "text": "Un endpoint que verifica el estado de la aplicación",
          "isCorrect": true
        },
        {
          "text": "Un tipo de test",
          "isCorrect": false
        },
        {
          "text": "Un middleware",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un Health Check es un endpoint (por ejemplo `/health`) que devuelve el **estado de la aplicación**: si está viva, si la DB responde, si los servicios externos están OK, etc. Es clave para orquestadores como Kubernetes o load balancers."
    },
    {
      "question": "¿Cómo se implementan Health Checks?",
      "options": [
        {
          "text": "Manualmente",
          "isCorrect": false
        },
        {
          "text": "Usando @nestjs/terminus",
          "isCorrect": true
        },
        {
          "text": "No se puede",
          "isCorrect": false
        },
        {
          "text": "Solo con Docker",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@nestjs/terminus` es el módulo oficial para Health Checks: provee un **`HealthCheckService` y varios indicators** (base de datos, Redis, gRPC, etc.) para que definas un endpoint que compruebe todos los componentes críticos de la app."
    },
    {
      "question": "¿Qué es @nestjs/schedule?",
      "options": [
        {
          "text": "Un horario",
          "isCorrect": false
        },
        {
          "text": "Un módulo para programar tareas con cron jobs",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un calendario",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@nestjs/schedule` permite **programar tareas** con cron jobs, timeouts e intervals dentro de NestJS, integradas como providers. Es útil para tareas recurrentes como limpiezas, sincronizaciones, notificaciones, etc."
    },
    {
      "question": "¿Qué decorador se usa para programar tareas?",
      "options": [
        {
          "text": "@Schedule",
          "isCorrect": false
        },
        {
          "text": "@Cron",
          "isCorrect": true
        },
        {
          "text": "@Task",
          "isCorrect": false
        },
        {
          "text": "@Job",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El decorador `@Cron()` marca un método como **tarea programada** que se ejecuta siguiendo una expresión cron (por ejemplo, cada minuto, cada día a las 3 AM, etc.), usando el módulo `@nestjs/schedule`."
    },
    {
      "question": "¿Qué es el Logger en NestJS?",
      "options": [
        {
          "text": "Un registrador de eventos",
          "isCorrect": false
        },
        {
          "text": "Una clase integrada para logging con diferentes niveles",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un archivo de logs",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El `Logger` integrado de NestJS es una clase que ofrece **métodos de logging por nivel** (`log`, `error`, `warn`, `debug`, `verbose`) y se integra con el sistema de logs del framework, permitiendo personalizar formato y destino si es necesario."
    },
    {
      "question": "¿Cuáles son niveles de log en NestJS? (selección múltiple)",
      "options": [
        {
          "text": "log",
          "isCorrect": false
        },
        {
          "text": "error",
          "isCorrect": true
        },
        {
          "text": "warn",
          "isCorrect": true
        },
        {
          "text": "debug",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Entre los niveles de log de NestJS están **`error`** (para fallos graves) y **`warn`** (para situaciones anómalas pero no fatales). Además existen otros niveles como `log`, `debug` y `verbose` para distintos grados de detalle de salida."
    }
  ],
  "ruby": [
    {
      "question": "¿Qué es Ruby?",
      "options": [
        {
          "text": "Un framework web",
          "isCorrect": false
        },
        {
          "text": "Un lenguaje de programación interpretado y orientado a objetos",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor web",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Ruby es un lenguaje de programación interpretado, dinámico y totalmente orientado a objetos. Prioriza la legibilidad y la productividad del desarrollador, con una sintaxis muy cercana al lenguaje natural. Al ser interpretado, el código se ejecuta directamente sin pasar por un paso de compilación previo."
    },
    {
      "question": "¿Qué símbolo se usa para definir un símbolo en Ruby?",
      "options": [
        {
          "text": "#",
          "isCorrect": false
        },
        {
          "text": ":",
          "isCorrect": true
        },
        {
          "text": "@",
          "isCorrect": false
        },
        {
          "text": "$",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un símbolo en Ruby se define anteponiendo dos puntos al nombre, por ejemplo `:nombre` o `:status`. Los símbolos son identificadores inmutables que se almacenan una sola vez en memoria, por eso son muy usados como keys en hashes y para representar estados o nombres constantes."
    },
    {
      "question": "¿Cómo se define un método en Ruby?",
      "options": [
        {
          "text": "function nombre()",
          "isCorrect": false
        },
        {
          "text": "def nombre",
          "isCorrect": true
        },
        {
          "text": "method nombre",
          "isCorrect": false
        },
        {
          "text": "func nombre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los métodos se definen con la palabra reservada `def` seguida del nombre, y se cierran con `end`, por ejemplo: `def saludar(nombre); \"Hola #{nombre}\"; end`. Por convención, los nombres de métodos usan snake_case y pueden terminar en `?`, `!` o `=` según su intención. El valor de retorno es la última expresión evaluada, por lo que muchas veces no hace falta usar `return` explícito."
    },
    {
      "question": "¿Qué es un bloque en Ruby?",
      "options": [
        {
          "text": "Un fragmento de código que puede pasarse a un método",
          "isCorrect": true
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        },
        {
          "text": "Una clase especial",
          "isCorrect": false
        },
        {
          "text": "Un módulo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un bloque en Ruby es un fragmento de código anónimo que se pasa a un método, por ejemplo `array.each { |x| puts x }` o `do ... end`. Los parámetros del bloque se indican entre `| |`. Los bloques son la base de muchos iteradores y permiten escribir código muy expresivo sin necesidad de definir métodos con nombre."
    },
    {
      "question": "¿Cómo se define una clase en Ruby?",
      "options": [
        {
          "text": "class MiClase",
          "isCorrect": true
        },
        {
          "text": "Class MiClase",
          "isCorrect": false
        },
        {
          "text": "def class MiClase",
          "isCorrect": false
        },
        {
          "text": "new MiClase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las clases se definen con la palabra clave `class` en minúsculas seguida del nombre de la clase en CamelCase, por ejemplo `class Usuario ... end`. Dentro de la clase se definen métodos y variables de instancia que describen el comportamiento y el estado de los objetos creados con `Usuario.new`."
    },
    {
      "question": "¿Qué es un Proc en Ruby?",
      "options": [
        {
          "text": "Un proceso del sistema",
          "isCorrect": false
        },
        {
          "text": "Un objeto que encapsula un bloque de código para reutilizarlo",
          "isCorrect": true
        },
        {
          "text": "Un método público",
          "isCorrect": false
        },
        {
          "text": "Una variable global",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `Proc` es un objeto que encapsula un bloque de código para poder guardarlo en variables, pasarlo como argumento y ejecutarlo más tarde con `call`. Se crea con `Proc.new { |x| x * 2 }` o `proc { ... }`. A diferencia de los lambdas, los `Proc` son más laxos con la cantidad de argumentos y un `return` dentro de ellos sale del método que los contiene."
    },
    {
      "question": "¿Qué es un Lambda en Ruby?",
      "options": [
        {
          "text": "Una función matemática",
          "isCorrect": false
        },
        {
          "text": "Un tipo especial de Proc con validación estricta de argumentos",
          "isCorrect": true
        },
        {
          "text": "Una clase abstracta",
          "isCorrect": false
        },
        {
          "text": "Un módulo de Ruby",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un lambda es un tipo especial de `Proc` que se comporta más parecido a un método normal. Se crea con `lambda { |x| x * 2 }` o `->(x) { x * 2 }`. Valida estrictamente la cantidad de argumentos y un `return` dentro del lambda solo sale del lambda, no del método que lo contiene."
    },
    {
      "question": "¿Cómo se heredan clases en Ruby?",
      "options": [
        {
          "text": "class Hijo extends Padre",
          "isCorrect": false
        },
        {
          "text": "class Hijo < Padre",
          "isCorrect": true
        },
        {
          "text": "class Hijo : Padre",
          "isCorrect": false
        },
        {
          "text": "class Hijo inherit Padre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La herencia se declara con el operador `<`: `class Hijo < Padre`. La clase hija hereda los métodos y comportamiento de la clase padre, pudiendo sobrescribir métodos (`override`) o añadir otros nuevos. Ruby soporta herencia simple, por lo que cada clase solo puede tener una superclase directa."
    },
    {
      "question": "¿Qué es un módulo en Ruby?",
      "options": [
        {
          "text": "Un módulo que agrupa métodos y constantes reutilizables",
          "isCorrect": true
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        },
        {
          "text": "Una clase especial",
          "isCorrect": false
        },
        {
          "text": "Un método privado",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un módulo (`module`) es un contenedor de métodos y constantes que no puede instanciarse. Se usa principalmente para compartir comportamiento entre clases mediante mixins (`include`, `extend`, `prepend`) y como namespace para organizar código y evitar colisiones de nombres. Es una alternativa flexible a la herencia para reutilizar lógica."
    },
    {
      "question": "¿Qué método se usa para iterar sobre un array en Ruby?",
      "options": [
        {
          "text": "forEach",
          "isCorrect": false
        },
        {
          "text": "each",
          "isCorrect": true
        },
        {
          "text": "map",
          "isCorrect": false
        },
        {
          "text": "Tanto b como c son correctos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`each` es el iterador básico de Ruby para arrays y otras colecciones. Ejecuta el bloque que recibe para cada elemento: `[1,2,3].each { |n| puts n }`. Devuelve la colección original, por lo que es ideal cuando queremos efectos secundarios (imprimir, acumular, etc.) y no transformar la colección."
    },
    {
      "question": "¿Qué es el método initialize en Ruby?",
      "options": [
        {
          "text": "Un método estático",
          "isCorrect": false
        },
        {
          "text": "El constructor de la clase",
          "isCorrect": true
        },
        {
          "text": "Un método de clase",
          "isCorrect": false
        },
        {
          "text": "Un método destructor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`initialize` es el método constructor de una clase y se llama automáticamente cuando haces `MiClase.new(...)`. Allí se suelen recibir parámetros y se inicializan variables de instancia (`@variable`) que representarán el estado del objeto. No se invoca explícitamente; siempre va ligado a `.new`."
    },
    {
      "question": "¿Cómo se definen variables de instancia en Ruby?",
      "options": [
        {
          "text": "Con $variable",
          "isCorrect": false
        },
        {
          "text": "Con @variable",
          "isCorrect": true
        },
        {
          "text": "Con @@variable",
          "isCorrect": false
        },
        {
          "text": "Con var variable",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las variables de instancia comienzan con `@`, por ejemplo `@nombre`. Cada objeto tiene sus propias copias de estas variables, que viven mientras viva la instancia. No son accesibles directamente desde fuera de la clase, por lo que se exponen mediante métodos o usando `attr_reader`, `attr_writer` o `attr_accessor`."
    },
    {
      "question": "¿Cómo se definen variables de clase en Ruby?",
      "options": [
        {
          "text": "@@variable",
          "isCorrect": true
        },
        {
          "text": "@variable",
          "isCorrect": false
        },
        {
          "text": "$variable",
          "isCorrect": false
        },
        {
          "text": "variable",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las variables de clase usan `@@` (doble arroba), por ejemplo `@@contador`. Son compartidas por todas las instancias de la clase y también por las subclases. Se usan para almacenar estado común (como contadores globales), pero pueden ser confusas; muchas veces se prefiere usar variables de instancia de clase (`@variable` dentro del contexto de la clase)."
    },
    {
      "question": "¿Qué significa el operador ||= en Ruby?",
      "options": [
        {
          "text": "OR lógico",
          "isCorrect": false
        },
        {
          "text": "Asignación condicional (asigna solo si la variable es nil o false)",
          "isCorrect": true
        },
        {
          "text": "Comparación",
          "isCorrect": false
        },
        {
          "text": "División",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El operador `||=` equivale a `variable = variable || valor`. Es decir, asigna el valor solo si la variable es `nil` o `false`. Por ejemplo, `@cache ||= calcular_valor` inicializa `@cache` solo una vez. Es muy usado para valores por defecto y *memoization*."
    },
    {
      "question": "¿Qué es duck typing en Ruby?",
      "options": [
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        },
        {
          "text": "Un principio donde el tipo de objeto se determina por sus métodos, no por su clase",
          "isCorrect": true
        },
        {
          "text": "Un método de debugging",
          "isCorrect": false
        },
        {
          "text": "Una forma de encriptación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Duck typing significa que Ruby se fija en lo que un objeto **puede hacer** (sus métodos) y no en su clase exacta. \"Si camina como pato y hace cuac como pato, lo tratamos como pato\". Por ejemplo, cualquier objeto que implemente `each` puede usarse donde se espera algo enumerable, sin importar su tipo concreto."
    },
    {
      "question": "¿Cómo se manejan excepciones en Ruby?",
      "options": [
        {
          "text": "try/catch",
          "isCorrect": false
        },
        {
          "text": "begin/rescue/end",
          "isCorrect": true
        },
        {
          "text": "catch/throw",
          "isCorrect": false
        },
        {
          "text": "error/handle",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El manejo de excepciones se hace con `begin ... rescue ... end`. Dentro de `begin` se pone el código que puede fallar y en `rescue` se captura la excepción, opcionalmente con una variable `rescue MiError => e`. Se pueden añadir bloques `else` (si no hubo error) y `ensure` (se ejecuta siempre, haya error o no)."
    },
    {
      "question": "¿Qué es un singleton method en Ruby?",
      "options": [
        {
          "text": "Un método definido solo para una instancia específica",
          "isCorrect": true
        },
        {
          "text": "Un patrón de diseño",
          "isCorrect": false
        },
        {
          "text": "Un método privado",
          "isCorrect": false
        },
        {
          "text": "Un método de clase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un *singleton method* es un método definido solo en una instancia concreta, no en toda la clase. Por ejemplo: `def objeto.saludar; \"hola\"; end`. Ese método existe únicamente para `objeto` y no para otras instancias de la misma clase. Ruby lo implementa usando la *singleton class* (o *eigenclass*) de ese objeto."
    },
    {
      "question": "¿Qué es metaprogramming en Ruby?",
      "options": [
        {
          "text": "Programar para metadatos",
          "isCorrect": false
        },
        {
          "text": "Código que escribe código, modificando clases y métodos en tiempo de ejecución",
          "isCorrect": true
        },
        {
          "text": "Un tipo de testing",
          "isCorrect": false
        },
        {
          "text": "Una técnica de optimización",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Metaprogramación es la capacidad de Ruby de modificar clases, métodos y objetos en tiempo de ejecución. Esto incluye definir métodos dinámicamente (`define_method`), abrir clases existentes, interceptar mensajes con `method_missing` y generar DSLs. Es muy poderosa y usada en frameworks como Rails, pero debe usarse con moderación para no perder claridad."
    },
    {
      "question": "¿Qué método convierte un string a entero en Ruby?",
      "options": [
        {
          "text": ".parseInt()",
          "isCorrect": false
        },
        {
          "text": ".to_i",
          "isCorrect": true
        },
        {
          "text": ".int()",
          "isCorrect": false
        },
        {
          "text": ".convert_to_integer",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El método `to_i` convierte un string a entero: `\"42\".to_i #=> 42`. Es tolerante con entradas no numéricas: si no encuentra números al inicio, devuelve 0, y si el string empieza con números y luego texto, toma solo la parte numérica (`\"10abc\".to_i #=> 10`). Para una conversión más estricta se puede usar `Integer(\"42\")`."
    },
    {
      "question": "¿Qué es un Hash en Ruby?",
      "options": [
        {
          "text": "Una función de encriptación",
          "isCorrect": false
        },
        {
          "text": "Una estructura de datos de pares clave-valor",
          "isCorrect": true
        },
        {
          "text": "Un método de clase",
          "isCorrect": false
        },
        {
          "text": "Un tipo de array",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `Hash` es una colección de pares clave-valor, por ejemplo `{ nombre: \"Ana\", edad: 30 }`. Las claves suelen ser símbolos o strings y se accede con `hash[:nombre]`. Es similar a un diccionario en Python u objeto \"plano\" en JavaScript, y es fundamental para pasar opciones y representar datos estructurados."
    },
    {
      "question": "¿Qué método se usa para iterar sobre un hash?",
      "options": [
        {
          "text": "for",
          "isCorrect": false
        },
        {
          "text": "each o each_pair",
          "isCorrect": true
        },
        {
          "text": "loop",
          "isCorrect": false
        },
        {
          "text": "iterate",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los hashes se recorren con `each` o `each_pair`, que ceden al bloque tanto la clave como el valor: `hash.each { |clave, valor| puts \"#{clave}: #{valor}\" }`. Ambos métodos devuelven el propio hash y permiten trabajar cómodamente con pares clave-valor."
    },
    {
      "question": "¿Qué es yield en Ruby?",
      "options": [
        {
          "text": "Un tipo de return",
          "isCorrect": false
        },
        {
          "text": "Transfiere el control a un bloque pasado al método",
          "isCorrect": true
        },
        {
          "text": "Una variable",
          "isCorrect": false
        },
        {
          "text": "Un operador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`yield` se usa dentro de un método para ejecutar el bloque que se le pasó a ese método. Por ejemplo: `def envoltorio; puts \"antes\"; yield; puts \"después\"; end`. Si llamas `envoltorio { puts \"bloque\" }`, el bloque se ejecuta en el punto donde aparece `yield`. Puedes pasar argumentos: `yield(arg1, arg2)`."
    },
    {
      "question": "¿Cuáles son tipos de variables en Ruby? (selección múltiple)",
      "options": [
        {
          "text": "Variables de instancia (@var)",
          "isCorrect": false
        },
        {
          "text": "Variables de clase (@@var)",
          "isCorrect": true
        },
        {
          "text": "Variables globales ($var)",
          "isCorrect": true
        },
        {
          "text": "Variables constantes (CONST)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Ruby tiene varios tipos de variables: locales (`nombre`), de instancia (`@nombre`), de clase (`@@nombre`) y globales (`$nombre`). Las variables de clase (`@@var`) comparten valor entre todas las instancias de la clase, mientras que las globales (`$var`) son accesibles desde cualquier parte del programa, por lo que deben usarse con mucho cuidado."
    },
    {
      "question": "¿Qué es un singleton class en Ruby?",
      "options": [
        {
          "text": "Un patrón de diseño",
          "isCorrect": false
        },
        {
          "text": "Una clase única asociada a un objeto específico",
          "isCorrect": true
        },
        {
          "text": "Una clase abstracta",
          "isCorrect": false
        },
        {
          "text": "Un módulo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La *singleton class* (o *eigenclass*) es una clase oculta que Ruby crea para cada objeto. En ella se guardan los métodos definidos solo para ese objeto (singleton methods). Se puede abrir con la sintaxis `class << objeto ... end`. Permite dar comportamiento único a una instancia sin afectar al resto."
    },
    {
      "question": "¿Qué operador se usa para concatenar strings en Ruby?",
      "options": [
        {
          "text": "+",
          "isCorrect": true
        },
        {
          "text": "&",
          "isCorrect": false
        },
        {
          "text": "*",
          "isCorrect": false
        },
        {
          "text": "<<",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El operador más común para concatenar strings es `+`, por ejemplo `\"Hola \" + \"mundo\"`. También se usan `<<` y `concat`, que modifican el string receptor in-place. Elegir entre `+` o `<<` depende de si quieres crear un nuevo objeto o mutar el existente."
    },
    {
      "question": "¿Qué método convierte un array a string en Ruby?",
      "options": [
        {
          "text": ".toString()",
          "isCorrect": false
        },
        {
          "text": ".join",
          "isCorrect": true
        },
        {
          "text": ".to_string",
          "isCorrect": false
        },
        {
          "text": ".concat",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`Array#join` une los elementos de un array en un solo string, usando opcionalmente un separador: `[\"a\", \"b\", \"c\"].join(\",\") #=> \"a,b,c\"`. Es muy útil para mostrar listas formateadas y generar líneas de texto a partir de colecciones."
    },
    {
      "question": "¿Qué es el método send en Ruby?",
      "options": [
        {
          "text": "Envía emails",
          "isCorrect": false
        },
        {
          "text": "Invoca un método dinámicamente por su nombre",
          "isCorrect": true
        },
        {
          "text": "Envía datos",
          "isCorrect": false
        },
        {
          "text": "Un método de red",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`send` permite invocar un método por su nombre (string o símbolo) de forma dinámica: `obj.send(:saludar, \"Ana\")` es equivalente a `obj.saludar(\"Ana\")`. Es útil para metaprogramación, aunque en código moderno se prefiere `public_send` cuando no quieres saltarte la visibilidad de métodos privados."
    },
    {
      "question": "¿Qué es attr_accessor en Ruby?",
      "options": [
        {
          "text": "Un atributo de acceso",
          "isCorrect": false
        },
        {
          "text": "Crea getters y setters automáticamente",
          "isCorrect": true
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        },
        {
          "text": "Un método privado",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`attr_accessor :nombre` define automáticamente dos métodos en la clase: `nombre` (getter) y `nombre=` (setter) para la variable de instancia `@nombre`. Evita escribir manualmente métodos triviales y hace el código más conciso. Sus \"hermanos\" son `attr_reader` (solo lectura) y `attr_writer` (solo escritura)."
    },
    {
      "question": "¿Cuáles son métodos de attr en Ruby? (selección múltiple)",
      "options": [
        {
          "text": "attr_reader",
          "isCorrect": false
        },
        {
          "text": "attr_writer",
          "isCorrect": true
        },
        {
          "text": "attr_accessor",
          "isCorrect": true
        },
        {
          "text": "attr_modifier",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los métodos de ayuda para exponer variables de instancia son `attr_reader` (solo getter), `attr_writer` (solo setter) y `attr_accessor` (getter y setter). Se definen a nivel de clase y generan automáticamente métodos de acceso para las variables de instancia indicadas."
    },
    {
      "question": "¿Qué es super en Ruby?",
      "options": [
        {
          "text": "Un método superior",
          "isCorrect": false
        },
        {
          "text": "Llama al método del mismo nombre en la clase padre",
          "isCorrect": true
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        },
        {
          "text": "Un operador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`super` llama al método con el mismo nombre definido en la superclase. Si se usa sin paréntesis, pasa los mismos argumentos que recibió el método actual; si se usa como `super()`, no pasa ninguno. Es esencial cuando quieres extender el comportamiento del método padre en lugar de reemplazarlo por completo."
    },
    {
      "question": "¿Qué es method_missing en Ruby?",
      "options": [
        {
          "text": "Un método que falta",
          "isCorrect": false
        },
        {
          "text": "Un método que se llama cuando se invoca un método inexistente",
          "isCorrect": true
        },
        {
          "text": "Un error",
          "isCorrect": false
        },
        {
          "text": "Un tipo de excepción",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`method_missing` se ejecuta cuando un objeto recibe un mensaje (llamada de método) que no tiene definido. Puedes sobrescribirlo para manejar métodos \"dinámicos\", crear DSLs o delegar llamadas. Es potente, pero conviene usarlo con cuidado y siempre acompañarlo de una implementación coherente de `respond_to_missing?`."
    },
    {
      "question": "¿Qué hace el método freeze en Ruby?",
      "options": [
        {
          "text": "Congela el programa",
          "isCorrect": false
        },
        {
          "text": "Hace inmutable un objeto",
          "isCorrect": true
        },
        {
          "text": "Pausa la ejecución",
          "isCorrect": false
        },
        {
          "text": "Guarda el objeto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`object.freeze` marca un objeto como inmutable: a partir de ese momento, cualquier intento de modificarlo lanzará un error `FrozenError`. Se usa para garantizar que cierto estado no cambie, por ejemplo valores constantes, configuraciones o estructuras compartidas."
    },
    {
      "question": "¿Qué es un Range en Ruby?",
      "options": [
        {
          "text": "Un rango de valores",
          "isCorrect": false
        },
        {
          "text": "Una secuencia de valores con inicio y fin",
          "isCorrect": true
        },
        {
          "text": "Un tipo de array",
          "isCorrect": false
        },
        {
          "text": "Una función matemática",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `Range` representa un intervalo de valores, por ejemplo `1..10` o `'a'..'z'`. Puede ser inclusivo o exclusivo en el límite superior. Los ranges se usan para iterar, comparar valores dentro de un rango, generar secuencias, y también en expresiones regulares y case/when."
    },
    {
      "question": "¿Cómo se define un Range en Ruby?",
      "options": [
        {
          "text": "(1 to 10)",
          "isCorrect": false
        },
        {
          "text": "(1..10) o (1...10)",
          "isCorrect": true
        },
        {
          "text": "[1-10]",
          "isCorrect": false
        },
        {
          "text": "Range.new(1,10)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un range se define usando dos o tres puntos: `1..10` incluye del 1 al 10, mientras que `1...10` incluye del 1 al 9 (excluye el último). También se pueden hacer ranges de letras (`'a'..'z'`). Son objetos de la clase `Range` y se pueden usar con `each`, `include?`, etc."
    },
    {
      "question": "¿Qué diferencia hay entre .. y ... en Ranges?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": ".. incluye el último valor, ... lo excluye",
          "isCorrect": true
        },
        {
          "text": "... incluye el último, .. lo excluye",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En un range `a..b`, el límite superior `b` está incluido; en `a...b`, el límite superior está excluido. Por ejemplo, `(1..3).to_a #=> [1,2,3]` mientras que `(1...3).to_a #=> [1,2]`. Esta diferencia es clave cuando trabajas con índices o límites de bucles."
    },
    {
      "question": "¿Qué es alias en Ruby?",
      "options": [
        {
          "text": "Un apodo",
          "isCorrect": false
        },
        {
          "text": "Crea un alias para un método existente",
          "isCorrect": true
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La palabra clave `alias` crea un nombre alternativo para un método ya existente. Por ejemplo: `alias :nuevo_nombre :viejo_nombre`. Ambos nombres apuntan al mismo método. Es útil cuando quieres cambiar el comportamiento de un método pero conservar una referencia al original."
    },
    {
      "question": "¿Qué es undef en Ruby?",
      "options": [
        {
          "text": "Indefinido",
          "isCorrect": false
        },
        {
          "text": "Elimina la definición de un método",
          "isCorrect": true
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        },
        {
          "text": "Un operador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`undef` elimina la definición de un método en la clase o módulo actual, de modo que no puede ser llamado ni siquiera con `super`. Por ejemplo: `undef :to_s` hace que esa clase no tenga `to_s` disponible. Es más radical que simplemente redefinir el método."
    },
    {
      "question": "¿Qué son los symbols ventajas en Ruby? (selección múltiple)",
      "options": [
        {
          "text": "Son inmutables",
          "isCorrect": false
        },
        {
          "text": "Más eficientes en memoria que strings",
          "isCorrect": true
        },
        {
          "text": "Se usan como keys en hashes",
          "isCorrect": true
        },
        {
          "text": "Son más lentos que strings",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los símbolos (`:nombre`) son inmutables y se almacenan solo una vez en memoria, por eso son más ligeros que los strings a la hora de representar etiquetas o keys. Son ampliamente usados como claves de hashes (`{ status: :ok }`) y para representar estados o tipos de forma eficiente."
    },
    {
      "question": "¿Qué método convierte string a symbol?",
      "options": [
        {
          "text": ".to_sym",
          "isCorrect": true
        },
        {
          "text": ".symbol",
          "isCorrect": false
        },
        {
          "text": ".to_s",
          "isCorrect": false
        },
        {
          "text": ".symbolize",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El método estándar para convertir un string a símbolo es `String#to_sym`, por ejemplo `\"nombre\".to_sym #=> :nombre`. También existe `intern`, que es equivalente. Esto se usa mucho cuando recibes datos como texto y quieres trabajar con símbolos de forma más eficiente."
    },
    {
      "question": "¿Qué es self en Ruby?",
      "options": [
        {
          "text": "Uno mismo",
          "isCorrect": false
        },
        {
          "text": "Referencia al objeto actual",
          "isCorrect": true
        },
        {
          "text": "Una variable global",
          "isCorrect": false
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`self` representa el objeto actual en el contexto donde se está ejecutando el código. Dentro de un método de instancia, `self` es la instancia; dentro del contexto de clase, `self` es la propia clase. Se usa para llamar métodos de la misma clase/objeto y para definir métodos de clase (`def self.metodo`)."
    },
    {
      "question": "¿Qué es un Enumerator en Ruby?",
      "options": [
        {
          "text": "Un contador",
          "isCorrect": false
        },
        {
          "text": "Un objeto que permite iterar sobre colecciones",
          "isCorrect": true
        },
        {
          "text": "Un tipo de array",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `Enumerator` encapsula una secuencia y la lógica para recorrerla, permitiendo iterar más tarde o de formas avanzadas. Muchos métodos como `each` devuelven un enumerador si no se les pasa un bloque: `array.each` devuelve un `Enumerator` que luego puedes encadenar con otros métodos (`map`, `with_index`, etc.)."
    },
    {
      "question": "¿Qué hace el método reduce en Ruby?",
      "options": [
        {
          "text": "Reduce el tamaño",
          "isCorrect": false
        },
        {
          "text": "Reduce una colección a un único valor mediante acumulación",
          "isCorrect": true
        },
        {
          "text": "Elimina elementos",
          "isCorrect": false
        },
        {
          "text": "Comprime datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`reduce` (alias `inject`) recorre una colección acumulando un resultado en cada paso. Por ejemplo, `[1,2,3].reduce(0) { |acc, n| acc + n } #=> 6`. Es muy útil para sumar, multiplicar, combinar hashes o construir estructuras más complejas a partir de una colección."
    },
    {
      "question": "¿Qué hace el método select en Ruby?",
      "options": [
        {
          "text": "Selecciona todo",
          "isCorrect": false
        },
        {
          "text": "Filtra elementos que cumplen una condición",
          "isCorrect": true
        },
        {
          "text": "Elige aleatoriamente",
          "isCorrect": false
        },
        {
          "text": "Ordena elementos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`select` recorre una colección y devuelve una **nueva** con solo los elementos para los que el bloque devuelve `true`. Por ejemplo, `[1,2,3,4].select { |n| n.even? } #=> [2,4]`. En hashes, devuelve un hash filtrado por clave/valor según la condición del bloque."
    },
    {
      "question": "¿Qué hace el método reject en Ruby?",
      "options": [
        {
          "text": "Rechaza errores",
          "isCorrect": false
        },
        {
          "text": "Filtra elementos que NO cumplen una condición",
          "isCorrect": true
        },
        {
          "text": "Elimina todo",
          "isCorrect": false
        },
        {
          "text": "Valida datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`reject` es el complemento de `select`: devuelve una nueva colección con los elementos para los que el bloque devuelve `false` o `nil`. Por ejemplo, `[1,2,3,4].reject { |n| n.even? } #=> [1,3]`. También funciona sobre hashes, devolviendo un hash sin las entradas rechazadas."
    },
    {
      "question": "¿Qué hace el método map en Ruby?",
      "options": [
        {
          "text": "Crea un mapa",
          "isCorrect": false
        },
        {
          "text": "Transforma cada elemento de una colección",
          "isCorrect": true
        },
        {
          "text": "Mapea rutas",
          "isCorrect": false
        },
        {
          "text": "Ordena elementos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`map` aplica el bloque a cada elemento de la colección y devuelve un nuevo array con los resultados: `[1,2,3].map { |n| n * 2 } #=> [2,4,6]`. No modifica la colección original (a menos que uses `map!`). Es central para un estilo de programación más funcional."
    },
    {
      "question": "¿Qué diferencia hay entre map y each?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "map retorna un nuevo array, each retorna el original",
          "isCorrect": true
        },
        {
          "text": "each es más rápido",
          "isCorrect": false
        },
        {
          "text": "map es obsoleto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`each` se usa para iterar por efectos secundarios (imprimir, guardar, etc.) y devuelve la colección original. `map`, en cambio, construye y devuelve un **nuevo** array con los valores transformados. Si necesitas un resultado transformado, usa `map`; si solo quieres recorrer, `each`."
    },
    {
      "question": "¿Qué es tap en Ruby?",
      "options": [
        {
          "text": "Un grifo",
          "isCorrect": false
        },
        {
          "text": "Ejecuta un bloque y retorna el objeto original",
          "isCorrect": true
        },
        {
          "text": "Un método de debugging",
          "isCorrect": false
        },
        {
          "text": "Un operador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`tap` llama al bloque pasándole el objeto receptor y luego devuelve ese mismo objeto. Por ejemplo: `usuario.tap { |u| u.nombre = \"Ana\"; puts u.inspect }`. Es útil para inicializar objetos en cadena y para depurar sin romper cadenas de métodos."
    },
    {
      "question": "¿Qué hace el método dig en Ruby?",
      "options": [
        {
          "text": "Excava",
          "isCorrect": false
        },
        {
          "text": "Navega estructuras anidadas de forma segura",
          "isCorrect": true
        },
        {
          "text": "Busca archivos",
          "isCorrect": false
        },
        {
          "text": "Elimina elementos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`dig` permite acceder a valores anidados en hashes, arrays u objetos similares sin levantar errores si algo es `nil`. Por ejemplo: `data.dig(:usuario, :perfil, :email)` devuelve `nil` si alguna de esas claves intermedias no existe, en lugar de lanzar `NoMethodError`."
    },
    {
      "question": "¿Qué son las expresiones regulares en Ruby?",
      "options": [
        {
          "text": "Expresiones matemáticas",
          "isCorrect": false
        },
        {
          "text": "Patrones para buscar y manipular texto",
          "isCorrect": true
        },
        {
          "text": "Funciones regulares",
          "isCorrect": false
        },
        {
          "text": "Variables constantes",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las expresiones regulares (regex) son patrones que describen conjuntos de cadenas de texto. En Ruby se usan para buscar, validar y reemplazar texto, por ejemplo `/\\A\\d{3}\\z/` para tres dígitos. Están integradas en muchos métodos de `String` como `match`, `gsub`, `scan`, etc."
    },
    {
      "question": "¿Cómo se define una regex en Ruby?",
      "options": [
        {
          "text": "regex()",
          "isCorrect": false
        },
        {
          "text": "/patrón/ o Regexp.new",
          "isCorrect": true
        },
        {
          "text": "\"patrón\"",
          "isCorrect": false
        },
        {
          "text": "[patrón]",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una regex se define normalmente encerrando el patrón entre barras `/.../`, por ejemplo `/\\d+/`, o usando `Regexp.new(\"patrón\")`. La forma con barras es la más común y soporta flags como `/i` para case-insensitive."
    },
    {
      "question": "¿Qué operador compara con regex en Ruby?",
      "options": [
        {
          "text": "==",
          "isCorrect": false
        },
        {
          "text": "=~",
          "isCorrect": true
        },
        {
          "text": "===",
          "isCorrect": false
        },
        {
          "text": "~=",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El operador `=~` compara un string con una expresión regular. Devuelve el índice de la primera coincidencia o `nil` si no hay match: `\"abc123\" =~ /\\d+/ #=> 3`. Se usa mucho en condicionales y también establece variables globales como `$&`, `$1`, `$2`, etc. para los grupos coincidentes."
    },
    {
      "question": "¿Qué método busca coincidencias de regex?",
      "options": [
        {
          "text": ".find",
          "isCorrect": false
        },
        {
          "text": ".match",
          "isCorrect": true
        },
        {
          "text": ".search",
          "isCorrect": false
        },
        {
          "text": ".scan",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`String#match` (o `Regexp#match`) busca una coincidencia y devuelve un objeto `MatchData` con información detallada del match y sus grupos de captura, o `nil` si no hay coincidencia. Por ejemplo: `\"ana@example.com\".match(/(.+)@(.+)/)` te permite acceder a los grupos con `m[1]`, `m[2]`, etc."
    },
    {
      "question": "¿Qué es $1, $2 en Ruby después de un match?",
      "options": [
        {
          "text": "Variables globales normales",
          "isCorrect": false
        },
        {
          "text": "Grupos de captura de la regex",
          "isCorrect": true
        },
        {
          "text": "Errores",
          "isCorrect": false
        },
        {
          "text": "Índices de array",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Después de una coincidencia de regex, `$1`, `$2`, `$3`, etc. contienen los valores de los grupos de captura 1, 2, 3, en orden. Por ejemplo, `/(\\d+)-(\\d+)/.match(\"10-20\")` hace que `$1 == \"10\"` y `$2 == \"20\"`. Son variables globales especiales de Ruby."
    },
    {
      "question": "¿Qué hace el método gsub en Ruby?",
      "options": [
        {
          "text": "Busca globalmente",
          "isCorrect": false
        },
        {
          "text": "Reemplaza todas las ocurrencias de un patrón",
          "isCorrect": true
        },
        {
          "text": "Elimina texto",
          "isCorrect": false
        },
        {
          "text": "Valida strings",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`gsub` (\"global substitute\") reemplaza **todas** las apariciones de un patrón (string o regex) por otro string o por el resultado de un bloque. Por ejemplo: `\"hola mundo\".gsub(\"o\", \"0\") #=> \"h0la mund0\"`. No modifica el original a menos que uses `gsub!`."
    },
    {
      "question": "¿Qué diferencia hay entre gsub y sub?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "gsub reemplaza todas las ocurrencias, sub solo la primera",
          "isCorrect": true
        },
        {
          "text": "sub es más rápido",
          "isCorrect": false
        },
        {
          "text": "gsub es obsoleto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`sub` reemplaza solo la **primera** coincidencia del patrón, mientras que `gsub` reemplaza todas. Por ejemplo: `\"foo foo\".sub(\"foo\",\"bar\") #=> \"bar foo\"` `\"foo foo\".gsub(\"foo\",\"bar\") #=> \"bar bar\"`."
    },
    {
      "question": "¿Qué es prepend en Ruby?",
      "options": [
        {
          "text": "Añade al final",
          "isCorrect": false
        },
        {
          "text": "Incluye un módulo con precedencia sobre la clase",
          "isCorrect": true
        },
        {
          "text": "Elimina elementos",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`prepend` inserta un módulo en la cadena de ancestros **antes** de la propia clase, de modo que sus métodos tienen prioridad sobre los métodos de la clase. Es útil para decorar o interceptar comportamiento sin modificar directamente la implementación original."
    },
    {
      "question": "¿Cuáles son formas de incluir módulos? (selección múltiple)",
      "options": [
        {
          "text": "include",
          "isCorrect": true
        },
        {
          "text": "extend",
          "isCorrect": true
        },
        {
          "text": "prepend",
          "isCorrect": true
        },
        {
          "text": "import",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los módulos se pueden \"mezclar\" de varias formas: `include`: añade los métodos del módulo como **métodos de instancia** de la clase. `extend`: añade los métodos del módulo como **métodos de clase** del objeto/clase donde se usa. `prepend`: como `include`, pero con mayor precedencia que los métodos de la clase. Estas tres formas permiten reutilizar comportamiento sin herencia."
    },
    {
      "question": "¿Qué hace extend en Ruby?",
      "options": [
        {
          "text": "Extiende strings",
          "isCorrect": false
        },
        {
          "text": "Añade métodos de módulo como métodos de clase",
          "isCorrect": true
        },
        {
          "text": "Hereda de una clase",
          "isCorrect": false
        },
        {
          "text": "Expande arrays",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`extend` agrega los métodos de un módulo como métodos **de clase** (o del objeto sobre el que se llama). Por ejemplo: `class Usuario; extend MiModulo; end` hace que los métodos de `MiModulo` se puedan llamar como `Usuario.metodo_modulo`."
    },
    {
      "question": "¿Qué es Comparable en Ruby?",
      "options": [
        {
          "text": "Una función de comparación",
          "isCorrect": false
        },
        {
          "text": "Un mixin que proporciona operadores de comparación",
          "isCorrect": true
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        },
        {
          "text": "Un operador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`Comparable` es un módulo que, al incluirlo en una clase, genera operadores como `<`, `<=`, `==`, `>=` y `>` a partir de la implementación del operador `<=>`. Es útil para definir objetos que se pueden ordenar naturalmente, como Fechas, Dinero, etc."
    },
    {
      "question": "¿Qué método debe implementarse para usar Comparable?",
      "options": [
        {
          "text": "compare",
          "isCorrect": false
        },
        {
          "text": "<=>",
          "isCorrect": true
        },
        {
          "text": "equals",
          "isCorrect": false
        },
        {
          "text": "==",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Para aprovechar `Comparable`, la clase debe implementar el operador `<=>`, conocido como *spaceship operator*. Debe devolver `-1` si `self` es menor, `0` si es igual y `1` si es mayor que el otro objeto. Con eso, `Comparable` genera el resto de operadores de comparación."
    },
    {
      "question": "¿Qué es Enumerable en Ruby?",
      "options": [
        {
          "text": "Un enumerador",
          "isCorrect": false
        },
        {
          "text": "Un mixin que proporciona métodos de iteración",
          "isCorrect": true
        },
        {
          "text": "Un tipo de array",
          "isCorrect": false
        },
        {
          "text": "Una clase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`Enumerable` es un módulo que aporta muchos métodos de colecciones (`map`, `select`, `reduce`, `any?`, etc.) siempre que la clase implemente al menos un método `each`. Arrays, Hashes y muchos otros tipos lo incluyen, lo que permite un estilo uniforme de trabajo con colecciones."
    },
    {
      "question": "¿Qué es defined? en Ruby?",
      "options": [
        {
          "text": "Un método de definición",
          "isCorrect": false
        },
        {
          "text": "Un operador que verifica si una variable está definida",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`defined?` es un operador que devuelve una cadena describiendo qué está definido (`\"local-variable\"`, `\"method\"`, etc.) o `nil` si no lo está. Se usa para comprobar la existencia de variables, métodos o constantes sin lanzar errores."
    },
    {
      "question": "¿Qué hace el operador <=> en Ruby?",
      "options": [
        {
          "text": "Menor o igual",
          "isCorrect": false
        },
        {
          "text": "Operador de comparación que retorna -1, 0 o 1",
          "isCorrect": true
        },
        {
          "text": "Asignación",
          "isCorrect": false
        },
        {
          "text": "Mayor o igual",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El operador `<=>` compara dos objetos y devuelve `-1` si el receptor es menor, `0` si son iguales y `1` si es mayor. Es la base de `Comparable` y se usa internamente para ordenar arrays (`sort`) y otras operaciones de comparación."
    },
    {
      "question": "¿Qué es __FILE__ en Ruby?",
      "options": [
        {
          "text": "Un archivo",
          "isCorrect": false
        },
        {
          "text": "Una constante con el nombre del archivo actual",
          "isCorrect": true
        },
        {
          "text": "Un método",
          "isCorrect": false
        },
        {
          "text": "Una variable global",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`__FILE__` es una constante mágica que contiene la ruta del archivo Ruby donde se está evaluando ese código. Se usa, por ejemplo, para construir rutas relativas (`File.dirname(__FILE__)`) o para saber desde qué archivo se ejecuta un script."
    },
    {
      "question": "¿Qué es __LINE__ en Ruby?",
      "options": [
        {
          "text": "Una línea",
          "isCorrect": false
        },
        {
          "text": "Una constante con el número de línea actual",
          "isCorrect": true
        },
        {
          "text": "Un método",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`__LINE__` es una constante mágica que devuelve el número de línea actual dentro del archivo Ruby. Es útil para logging, debugging y para generar mensajes de error que indiquen de dónde vienen."
    },
    {
      "question": "¿Qué hace require en Ruby?",
      "options": [
        {
          "text": "Requiere permiso",
          "isCorrect": false
        },
        {
          "text": "Carga un archivo o gema una sola vez",
          "isCorrect": true
        },
        {
          "text": "Valida datos",
          "isCorrect": false
        },
        {
          "text": "Solicita input",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`require` carga un archivo (o gema) y evalúa su contenido, pero solo la primera vez que se invoca para ese path. Si se llama de nuevo con el mismo archivo, no lo recarga. Es la forma habitual de traer dependencias a tu código."
    },
    {
      "question": "¿Qué diferencia hay entre require y load?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "require carga una vez, load carga cada vez que se llama",
          "isCorrect": true
        },
        {
          "text": "load es más rápido",
          "isCorrect": false
        },
        {
          "text": "require es obsoleto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`require` carga un archivo solo una vez por ejecución (lo marca como cargado) mientras que `load` vuelve a cargar y reevaluar el archivo **cada vez** que se llama. `load` se usa cuando necesitas recargar código dinámicamente, como en scripts o REPLs."
    },
    {
      "question": "¿Qué hace require_relative?",
      "options": [
        {
          "text": "Requiere parientes",
          "isCorrect": false
        },
        {
          "text": "Carga un archivo relativo al archivo actual",
          "isCorrect": true
        },
        {
          "text": "Carga archivos remotos",
          "isCorrect": false
        },
        {
          "text": "Valida rutas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`require_relative` funciona como `require`, pero interpreta la ruta de forma relativa al archivo donde se escribe la llamada, no al `$LOAD_PATH`. Es muy útil para organizar proyectos pequeños o librerías donde los archivos están en carpetas cercanas."
    },
    {
      "question": "¿Qué es Gem en Ruby?",
      "options": [
        {
          "text": "Una joya",
          "isCorrect": false
        },
        {
          "text": "Un paquete de código reutilizable",
          "isCorrect": true
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        },
        {
          "text": "Un operador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un *gem* es un paquete de código Ruby reutilizable que se puede distribuir e instalar fácilmente (por ejemplo, `rails`, `rspec`, `devise`). Define su metadata y dependencias en un `gemspec` y se instala normalmente con `gem install` o a través de Bundler."
    },
    {
      "question": "¿Qué es Bundler en Ruby?",
      "options": [
        {
          "text": "Un empaquetador",
          "isCorrect": false
        },
        {
          "text": "Un gestor de dependencias para gems",
          "isCorrect": true
        },
        {
          "text": "Un framework",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Bundler es la herramienta estándar para gestionar dependencias (gems) en proyectos Ruby. Lee el `Gemfile`, resuelve versiones compatibles y genera un `Gemfile.lock`. Luego, `bundle exec` garantiza que tu aplicación use exactamente las versiones definidas."
    },
    {
      "question": "¿Qué archivo usa Bundler para definir dependencias?",
      "options": [
        {
          "text": "packages.json",
          "isCorrect": false
        },
        {
          "text": "Gemfile",
          "isCorrect": true
        },
        {
          "text": "dependencies.rb",
          "isCorrect": false
        },
        {
          "text": "gems.txt",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El `Gemfile` es el archivo donde declaras las dependencias de tu proyecto Ruby: qué gems necesitas y opcionalmente sus versiones o grupos (`group :test do ... end`). Bundler lo usa como fuente de verdad para instalar y bloquear las versiones."
    },
    {
      "question": "¿Qué comando instala las gems del Gemfile?",
      "options": [
        {
          "text": "gem install",
          "isCorrect": false
        },
        {
          "text": "bundle install",
          "isCorrect": true
        },
        {
          "text": "bundler install",
          "isCorrect": false
        },
        {
          "text": "install gems",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`bundle install` lee el `Gemfile`, resuelve y descarga las gems necesarias (y sus dependencias) y actualiza el `Gemfile.lock`. Es el comando que se ejecuta al configurar un proyecto Ruby o Rails recién clonado."
    },
    {
      "question": "¿Qué es RSpec en Ruby?",
      "options": [
        {
          "text": "Una especificación",
          "isCorrect": false
        },
        {
          "text": "Un framework de testing BDD",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "RSpec es un framework de testing para Ruby basado en BDD (Behavior-Driven Development). Permite describir el comportamiento esperado del código con una sintaxis muy legible, usando bloques `describe`, `context`, `it` y expectativas con `expect(...).to`."
    },
    {
      "question": "¿Cuáles son métodos de testing en RSpec? (selección múltiple)",
      "options": [
        {
          "text": "describe",
          "isCorrect": false
        },
        {
          "text": "it",
          "isCorrect": true
        },
        {
          "text": "expect",
          "isCorrect": true
        },
        {
          "text": "test",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "En RSpec, `it` define un ejemplo o caso de prueba (`it \"hace algo\" do ... end`) y `expect` se usa para definir aserciones (`expect(resultado).to eq(42)`). Juntos permiten expresar de forma clara qué comportamiento se espera del código bajo prueba."
    }
  ],
  "rails": [
    {
      "question": "¿Qué patrón arquitectónico usa Rails?",
      "options": [
        {
          "text": "MVP",
          "isCorrect": false
        },
        {
          "text": "MVC (Model-View-Controller)",
          "isCorrect": true
        },
        {
          "text": "MVVM",
          "isCorrect": false
        },
        {
          "text": "Singleton",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Rails sigue el patrón **MVC**, separando la lógica de negocio (Model), la interfaz (View) y el flujo de peticiones/respuestas (Controller), lo que organiza mejor el código y responsabilidades."
    },
    {
      "question": "¿Qué es ActiveRecord en Rails?",
      "options": [
        {
          "text": "Un registro activo de usuarios",
          "isCorrect": false
        },
        {
          "text": "Un ORM donde cada modelo representa una tabla con métodos CRUD",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un tipo de controlador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ActiveRecord es el ORM de Rails: cada modelo Ruby mapea a una tabla y proporciona métodos listos para usar para operaciones CRUD, asociaciones y validaciones sobre la base de datos."
    },
    {
      "question": "¿Cómo se genera un modelo en Rails?",
      "options": [
        {
          "text": "rails new model Nombre",
          "isCorrect": false
        },
        {
          "text": "rails generate model Nombre",
          "isCorrect": true
        },
        {
          "text": "rails create model Nombre",
          "isCorrect": false
        },
        {
          "text": "rails make:model Nombre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`rails generate model Nombre` crea el modelo, la migración y archivos relacionados. Es la forma estándar de definir nuevas tablas/modelos en una app Rails."
    },
    {
      "question": "¿Cómo se ejecutan las migraciones en Rails?",
      "options": [
        {
          "text": "rails migrate",
          "isCorrect": false
        },
        {
          "text": "rails db:migrate",
          "isCorrect": true
        },
        {
          "text": "rails run migrations",
          "isCorrect": false
        },
        {
          "text": "rails exec migrate",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`rails db:migrate` ejecuta todas las migraciones pendientes, aplicando los cambios definidos en los archivos de migración al esquema de la base de datos."
    },
    {
      "question": "¿Qué son las migraciones en Rails?",
      "options": [
        {
          "text": "Cambios versionados en la estructura de la base de datos (migraciones de schema)",
          "isCorrect": true
        },
        {
          "text": "Movimiento de archivos",
          "isCorrect": false
        },
        {
          "text": "Actualizaciones del framework",
          "isCorrect": false
        },
        {
          "text": "Cambios en las rutas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En Rails, las migraciones son scripts Ruby que describen cambios en la base de datos (crear tablas, columnas, índices, etc.), permitiendo versionar y evolucionar el esquema de forma segura."
    },
    {
      "question": "¿Cómo se define una ruta en Rails?",
      "options": [
        {
          "text": "En config/routes.rb",
          "isCorrect": true
        },
        {
          "text": "En el controlador",
          "isCorrect": false
        },
        {
          "text": "En el modelo",
          "isCorrect": false
        },
        {
          "text": "En la vista",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las rutas en Rails se definen en `config/routes.rb`, donde se mapean URLs y verbos HTTP a acciones de controladores usando helpers como `resources` o `get/post`."
    },
    {
      "question": "¿Qué es un callback en Rails?",
      "options": [
        {
          "text": "Una función JavaScript",
          "isCorrect": false
        },
        {
          "text": "Métodos que se ejecutan en momentos específicos del ciclo de vida de un objeto",
          "isCorrect": true
        },
        {
          "text": "Un tipo de validación",
          "isCorrect": false
        },
        {
          "text": "Una ruta especial",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un callback es un método del modelo que se ejecuta automáticamente en ciertos momentos del ciclo de vida del registro, como antes de validar, guardar o después de crear."
    },
    {
      "question": "¿Cuál es un ejemplo de callback en Rails?",
      "options": [
        {
          "text": "before_save",
          "isCorrect": false
        },
        {
          "text": "after_create",
          "isCorrect": true
        },
        {
          "text": "before_validation",
          "isCorrect": false
        },
        {
          "text": "Todas las anteriores",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`after_create` es un callback que se ejecuta justo después de que un registro haya sido creado y guardado por primera vez en la base de datos."
    },
    {
      "question": "¿Cómo se evita el problema N+1 en Rails?",
      "options": [
        {
          "text": "Usando cache",
          "isCorrect": false
        },
        {
          "text": "Usando includes o eager loading para precargar asociaciones",
          "isCorrect": true
        },
        {
          "text": "Añadiendo más memoria",
          "isCorrect": false
        },
        {
          "text": "Usando índices",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El problema N+1 ocurre cuando se hace una query por registro relacionado. Usar `includes`/eager loading carga las asociaciones en una sola consulta adicional, evitando muchas querys pequeñas."
    },
    {
      "question": "¿Qué es Sidekiq en Rails?",
      "options": [
        {
          "text": "Un servidor web",
          "isCorrect": false
        },
        {
          "text": "Una librería para procesamiento de trabajos en segundo plano",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un framework de testing",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Sidekiq es una librería que permite ejecutar trabajos en segundo plano (background jobs) usando Redis, ideal para tareas lentas como emails, procesar archivos o integraciones externas."
    },
    {
      "question": "¿Qué es un scope en Rails?",
      "options": [
        {
          "text": "Un ámbito de variables",
          "isCorrect": false
        },
        {
          "text": "Un método de consulta reutilizable definido en el modelo",
          "isCorrect": true
        },
        {
          "text": "Un tipo de ruta",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un scope es una consulta reutilizable definida en el modelo (por ejemplo `scope :active, -> { where(active: true) }`) que devuelve un objeto ActiveRecord::Relation y se puede encadenar."
    },
    {
      "question": "¿Cómo se definen validaciones en Rails?",
      "options": [
        {
          "text": "En el controlador",
          "isCorrect": false
        },
        {
          "text": "En el modelo usando validates",
          "isCorrect": true
        },
        {
          "text": "En la vista",
          "isCorrect": false
        },
        {
          "text": "En las rutas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las validaciones se declaran en el modelo con macros como `validates :name, presence: true`, asegurando que los datos cumplan ciertas reglas antes de guardarse."
    },
    {
      "question": "¿Qué es un helper en Rails?",
      "options": [
        {
          "text": "Módulos con métodos auxiliares para vistas",
          "isCorrect": true
        },
        {
          "text": "Un tipo de controlador",
          "isCorrect": false
        },
        {
          "text": "Una validación especial",
          "isCorrect": false
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un helper es un módulo con métodos de ayuda usados en las vistas (por ejemplo para formatear fechas o generar enlaces), manteniendo la lógica de presentación fuera de los controladores."
    },
    {
      "question": "¿Cómo se define una asociación has_many en Rails?",
      "options": [
        {
          "text": "En el controlador",
          "isCorrect": false
        },
        {
          "text": "En el modelo: has_many :items",
          "isCorrect": true
        },
        {
          "text": "En la vista",
          "isCorrect": false
        },
        {
          "text": "En las rutas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las asociaciones `has_many` se definen en el modelo, por ejemplo `has_many :items`, indicando que un registro puede estar relacionado con muchos registros de otra tabla."
    },
    {
      "question": "¿Qué es el Asset Pipeline en Rails?",
      "options": [
        {
          "text": "Una tubería de agua",
          "isCorrect": false
        },
        {
          "text": "Un framework que concatena y minifica archivos CSS y JavaScript",
          "isCorrect": true
        },
        {
          "text": "Un tipo de middleware",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El Asset Pipeline de Rails gestiona CSS, JS e imágenes: permite concatenar, minificar, precompilar y servir estos archivos de forma eficiente en producción."
    },
    {
      "question": "¿Qué archivo contiene la configuración de la base de datos en Rails?",
      "options": [
        {
          "text": "config/database.yml",
          "isCorrect": true
        },
        {
          "text": "db.config",
          "isCorrect": false
        },
        {
          "text": "config/db.rb",
          "isCorrect": false
        },
        {
          "text": "database.json",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La configuración de la base de datos se define en `config/database.yml`, donde se especifican adaptador, nombre de base de datos, usuario, contraseña y settings por entorno."
    },
    {
      "question": "¿Qué es un partial en Rails?",
      "options": [
        {
          "text": "Un fragmento de vista reutilizable",
          "isCorrect": true
        },
        {
          "text": "Un modelo incompleto",
          "isCorrect": false
        },
        {
          "text": "Una validación parcial",
          "isCorrect": false
        },
        {
          "text": "Un controlador auxiliar",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un partial es una vista parcial (por ejemplo `_form.html.erb`) que representa un fragmento reutilizable de HTML, normalmente renderizado dentro de otras vistas."
    },
    {
      "question": "¿Qué gema se usa comúnmente para autenticación en Rails?",
      "options": [
        {
          "text": "AuthRails",
          "isCorrect": false
        },
        {
          "text": "Devise",
          "isCorrect": true
        },
        {
          "text": "SecureAuth",
          "isCorrect": false
        },
        {
          "text": "RailsAuth",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Devise es una gema muy usada en Rails que proporciona un sistema de autenticación completo: registro, login, recuperación de contraseña, confirmación de email, etc."
    },
    {
      "question": "¿Qué comando inicia el servidor de desarrollo en Rails?",
      "options": [
        {
          "text": "rails start",
          "isCorrect": false
        },
        {
          "text": "rails server o rails s",
          "isCorrect": true
        },
        {
          "text": "rails run",
          "isCorrect": false
        },
        {
          "text": "rails up",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`rails server` o `rails s` arrancan el servidor de desarrollo local de Rails, normalmente en `http://localhost:3000`, para probar la aplicación."
    },
    {
      "question": "¿Qué es un concern en Rails?",
      "options": [
        {
          "text": "Una preocupación de seguridad",
          "isCorrect": false
        },
        {
          "text": "Un módulo que encapsula lógica compartida entre modelos o controladores",
          "isCorrect": true
        },
        {
          "text": "Un tipo de vista",
          "isCorrect": false
        },
        {
          "text": "Una validación especial",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un concern es un módulo (en `app/models/concerns` o `app/controllers/concerns`) donde se coloca lógica compartida para incluirla en varios modelos o controladores sin duplicar código."
    },
    {
      "question": "¿Qué es el Asset Pipeline en Rails? (expansión)",
      "options": [
        {
          "text": "Un sistema de carga",
          "isCorrect": false
        },
        {
          "text": "Concatena, minifica y precompila assets (CSS, JS, imágenes)",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un tipo de middleware",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El Asset Pipeline no solo concatena y minifica CSS/JS, también precompila assets y puede procesar imágenes, SASS/SCSS, CoffeeScript, etc., generando versiones optimizadas para producción."
    },
    {
      "question": "¿Cuáles son ambientes por defecto en Rails? (selección múltiple)",
      "options": [
        {
          "text": "development",
          "isCorrect": false
        },
        {
          "text": "test",
          "isCorrect": true
        },
        {
          "text": "production",
          "isCorrect": true
        },
        {
          "text": "staging",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Rails trae tres entornos por defecto: `development`, `test` y `production`. Cada uno tiene configuración distinta; aquí se destacan `test` y `production` como entornos clave para pruebas y despliegue."
    },
    {
      "question": "¿Qué es Strong Parameters en Rails?",
      "options": [
        {
          "text": "Parámetros fuertes",
          "isCorrect": false
        },
        {
          "text": "Un mecanismo de seguridad para permitir solo ciertos parámetros",
          "isCorrect": true
        },
        {
          "text": "Validación de datos",
          "isCorrect": false
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Strong Parameters obliga a declarar explícitamente qué parámetros se permiten para un modelo, protegiendo de asignación masiva de atributos no deseados o peligrosos."
    },
    {
      "question": "¿Cómo se definen Strong Parameters?",
      "options": [
        {
          "text": "En el modelo",
          "isCorrect": false
        },
        {
          "text": "Con los métodos require y permit en el controlador",
          "isCorrect": true
        },
        {
          "text": "En la vista",
          "isCorrect": false
        },
        {
          "text": "En las rutas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En el controlador, se usa algo como `params.require(:user).permit(:name, :email)` para exigir una clave raíz (`require`) y listar los atributos permitidos (`permit`)."
    },
    {
      "question": "¿Qué es un filtro (filter) en controladores Rails?",
      "options": [
        {
          "text": "Un filtro de datos",
          "isCorrect": false
        },
        {
          "text": "Un método que se ejecuta before, after o around de una acción",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de ruta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un filtro (como `before_action`) es un método del controlador que se ejecuta antes, después o alrededor de una acción, por ejemplo para autenticar usuarios o cargar recursos comunes."
    },
    {
      "question": "¿Cuáles son tipos de filtros en Rails? (selección múltiple)",
      "options": [
        {
          "text": "before_action",
          "isCorrect": false
        },
        {
          "text": "after_action",
          "isCorrect": true
        },
        {
          "text": "around_action",
          "isCorrect": true
        },
        {
          "text": "during_action",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "`after_action` se ejecuta después de la acción y `around_action` envuelve la acción antes y después, permitiendo lógica que rodea la ejecución (como medir tiempos, transacciones, etc.)."
    },
    {
      "question": "¿Qué es render en Rails?",
      "options": [
        {
          "text": "Renderizar HTML",
          "isCorrect": false
        },
        {
          "text": "Muestra una vista o respuesta sin ejecutar otra acción",
          "isCorrect": true
        },
        {
          "text": "Valida datos",
          "isCorrect": false
        },
        {
          "text": "Ejecuta código",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`render` genera una respuesta (vista, JSON, texto…) dentro de la misma petición, sin redirigir ni hacer un nuevo request al servidor."
    },
    {
      "question": "¿Qué es redirect_to en Rails?",
      "options": [
        {
          "text": "Redirecciona tráfico",
          "isCorrect": false
        },
        {
          "text": "Redirige a otra URL o acción",
          "isCorrect": true
        },
        {
          "text": "Muestra una vista",
          "isCorrect": false
        },
        {
          "text": "Valida rutas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`redirect_to` envía una redirección HTTP al navegador para que haga una nueva petición a otra URL o acción, cambiando la ruta en el navegador."
    },
    {
      "question": "¿Diferencia entre render y redirect_to?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "render muestra vista sin nueva petición, redirect_to hace nueva petición HTTP",
          "isCorrect": true
        },
        {
          "text": "redirect_to es más rápido",
          "isCorrect": false
        },
        {
          "text": "render es obsoleto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`render` responde directamente en esa misma petición, mientras que `redirect_to` manda una redirección, provocando una nueva petición del cliente a otra URL."
    },
    {
      "question": "¿Qué es flash en Rails?",
      "options": [
        {
          "text": "Un mensaje rápido",
          "isCorrect": false
        },
        {
          "text": "Un hash para mostrar mensajes temporales entre peticiones",
          "isCorrect": true
        },
        {
          "text": "Una animación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de cookie",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`flash` es un hash especial que permite pasar mensajes (por ejemplo de éxito o error) a la siguiente petición, típico para mostrar avisos después de un `redirect_to`."
    },
    {
      "question": "¿Cuáles son tipos de flash en Rails? (selección múltiple)",
      "options": [
        {
          "text": "flash[:notice]",
          "isCorrect": false
        },
        {
          "text": "flash[:alert]",
          "isCorrect": true
        },
        {
          "text": "flash[:error]",
          "isCorrect": true
        },
        {
          "text": "flash[:warning]",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Claves como `flash[:alert]` o `flash[:error]` se usan para mostrar mensajes de error. También es común `flash[:notice]` para mensajes informativos o de éxito."
    },
    {
      "question": "¿Qué es un layout en Rails?",
      "options": [
        {
          "text": "Un diseño",
          "isCorrect": false
        },
        {
          "text": "Una plantilla que envuelve las vistas",
          "isCorrect": true
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        },
        {
          "text": "Una hoja de estilos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un layout es una plantilla marco (por ejemplo `application.html.erb`) que envuelve al contenido de cada vista, compartiendo cabeceras, menús, pie de página, etc."
    },
    {
      "question": "¿Dónde se ubican los layouts por defecto?",
      "options": [
        {
          "text": "app/views/layouts",
          "isCorrect": false
        },
        {
          "text": "app/layouts",
          "isCorrect": true
        },
        {
          "text": "public/layouts",
          "isCorrect": false
        },
        {
          "text": "config/layouts",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Por convención, los layouts se guardan en `app/views/layouts/`. Rails usará `application.html.erb` como layout por defecto si no se indica otro."
    },
    {
      "question": "¿Qué es yield en vistas Rails?",
      "options": [
        {
          "text": "Un método de modelo",
          "isCorrect": false
        },
        {
          "text": "Marca donde se insertará el contenido de la vista",
          "isCorrect": true
        },
        {
          "text": "Una variable",
          "isCorrect": false
        },
        {
          "text": "Un helper",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En un layout, `yield` marca el punto donde se insertará el contenido de la vista específica que se está renderizando en esa petición."
    },
    {
      "question": "¿Qué son los helpers en Rails?",
      "options": [
        {
          "text": "Ayudantes humanos",
          "isCorrect": false
        },
        {
          "text": "Módulos con métodos auxiliares para las vistas",
          "isCorrect": true
        },
        {
          "text": "Tipos de modelos",
          "isCorrect": false
        },
        {
          "text": "Configuraciones",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los helpers son módulos con métodos que ayudan en las vistas (por ejemplo formatear textos, generar enlaces o botones) y mantienen las vistas más limpias y DRY."
    },
    {
      "question": "¿Qué es link_to en Rails?",
      "options": [
        {
          "text": "Un enlace",
          "isCorrect": false
        },
        {
          "text": "Un helper que genera enlaces HTML",
          "isCorrect": true
        },
        {
          "text": "Una ruta",
          "isCorrect": false
        },
        {
          "text": "Un método de modelo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`link_to` genera un enlace `<a>` en HTML. Recibe normalmente el texto a mostrar y la ruta o URL a la que apuntará, además de opciones extra (clases CSS, método, etc.)."
    },
    {
      "question": "¿Qué es form_with en Rails?",
      "options": [
        {
          "text": "Un formulario",
          "isCorrect": false
        },
        {
          "text": "Un helper para crear formularios",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de vista",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`form_with` es el helper moderno para construir formularios, ya sea asociados a un modelo o no, generando automáticamente campos, acción y método HTTP apropiados."
    },
    {
      "question": "¿Cuáles son asociaciones en Rails? (selección múltiple)",
      "options": [
        {
          "text": "has_many",
          "isCorrect": false
        },
        {
          "text": "belongs_to",
          "isCorrect": true
        },
        {
          "text": "has_one",
          "isCorrect": true
        },
        {
          "text": "has_and_belongs_to_many",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "`belongs_to` y `has_one` son tipos de asociaciones. `belongs_to` indica que el modelo tiene una clave foránea a otro, y `has_one` indica una relación uno-a-uno desde el otro lado."
    },
    {
      "question": "¿Qué es una asociación polymorphic en Rails?",
      "options": [
        {
          "text": "Una asociación múltiple",
          "isCorrect": false
        },
        {
          "text": "Una asociación donde un modelo puede pertenecer a varios tipos de modelos",
          "isCorrect": true
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una asociación polimórfica permite que un modelo (por ejemplo `Comment`) pertenezca a diferentes modelos (`Post`, `Photo`, etc.) usando columnas como `commentable_id` y `commentable_type`."
    },
    {
      "question": "¿Qué es nested resources en Rails?",
      "options": [
        {
          "text": "Rutas anidadas que reflejan relaciones entre recursos (por ejemplo, posts/:post_id/comments)",
          "isCorrect": true
        },
        {
          "text": "Un tipo de asociación",
          "isCorrect": false
        },
        {
          "text": "Un modelo anidado",
          "isCorrect": false
        },
        {
          "text": "Una validación compuesta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Nested resources son rutas anidadas en `routes.rb`, por ejemplo `resources :posts do resources :comments end`, reflejando que comentarios pertenecen a un post."
    },
    {
      "question": "¿Qué es un namespace en rutas Rails?",
      "options": [
        {
          "text": "Agrupación de rutas bajo un mismo espacio de nombres",
          "isCorrect": true
        },
        {
          "text": "Una variable",
          "isCorrect": false
        },
        {
          "text": "Un tipo de controlador",
          "isCorrect": false
        },
        {
          "text": "Una configuración de base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `namespace` en rutas agrupa rutas bajo un prefijo y módulo de controladores, por ejemplo `namespace :admin do ... end` para rutas y controladores de administración."
    },
    {
      "question": "¿Qué es ActiveJob en Rails?",
      "options": [
        {
          "text": "Un trabajo activo",
          "isCorrect": false
        },
        {
          "text": "Un framework para declarar trabajos en segundo plano",
          "isCorrect": true
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ActiveJob es la capa de abstracción de Rails para trabajos en segundo plano; define jobs de forma unificada y luego los envía al adaptador de cola que elijas (Sidekiq, Resque, etc.)."
    },
    {
      "question": "¿Cuáles son adaptadores de ActiveJob? (selección múltiple)",
      "options": [
        {
          "text": "Sidekiq",
          "isCorrect": false
        },
        {
          "text": "Resque",
          "isCorrect": true
        },
        {
          "text": "Delayed Job",
          "isCorrect": true
        },
        {
          "text": "Rails Queue",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Resque y Delayed Job son adaptadores de colas soportados por ActiveJob; permiten ejecutar los jobs definidos en Rails usando distintos backends de procesamiento."
    },
    {
      "question": "¿Qué es ActionCable en Rails?",
      "options": [
        {
          "text": "Un cable",
          "isCorrect": false
        },
        {
          "text": "Framework para WebSockets en tiempo real",
          "isCorrect": true
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ActionCable es el framework de WebSockets de Rails, que integra canales en tiempo real dentro de la aplicación para cosas como chats o notificaciones en vivo."
    },
    {
      "question": "¿Qué es Turbo en Rails (Hotwire)?",
      "options": [
        {
          "text": "Un modo turbo",
          "isCorrect": false
        },
        {
          "text": "Framework para SPAs sin mucho JavaScript",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Turbo (parte de Hotwire) permite construir experiencias tipo SPA usando HTML sobre el cable, minimizando la necesidad de JavaScript complejo en el frontend."
    },
    {
      "question": "¿Qué es Stimulus en Rails?",
      "options": [
        {
          "text": "Un estímulo",
          "isCorrect": false
        },
        {
          "text": "Framework JavaScript modesto para Rails",
          "isCorrect": true
        },
        {
          "text": "Un tipo de validación",
          "isCorrect": false
        },
        {
          "text": "Un modelo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Stimulus es un pequeño framework JavaScript orientado a controlar el HTML existente con controladores ligeros, complementando a Turbo sin reemplazar el HTML renderizado por Rails."
    },
    {
      "question": "¿Qué son las validaciones personalizadas en Rails?",
      "options": [
        {
          "text": "Validaciones custom",
          "isCorrect": false
        },
        {
          "text": "Métodos de validación definidos por el usuario",
          "isCorrect": true
        },
        {
          "text": "Validaciones automáticas",
          "isCorrect": false
        },
        {
          "text": "Tipos de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las validaciones personalizadas son métodos propios que implementan reglas de validación específicas que no cubren los helpers estándar como `presence`, `uniqueness`, etc."
    },
    {
      "question": "¿Cómo se crea una validación custom?",
      "options": [
        {
          "text": "En el controlador",
          "isCorrect": false
        },
        {
          "text": "Definiendo un método y usando validate :metodo",
          "isCorrect": true
        },
        {
          "text": "En la vista",
          "isCorrect": false
        },
        {
          "text": "En las rutas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Para crear una validación custom defines un método en el modelo y lo registras con `validate :nombre_del_metodo`, donde dentro del método agregas errores al objeto si algo no se cumple."
    },
    {
      "question": "¿Qué es accepts_nested_attributes_for?",
      "options": [
        {
          "text": "Acepta atributos",
          "isCorrect": false
        },
        {
          "text": "Permite guardar asociaciones anidadas desde un formulario",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de ruta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`accepts_nested_attributes_for` permite que un modelo reciba y guarde atributos de asociaciones relacionadas a través de un mismo formulario (por ejemplo un `Post` y sus `Comments`)."
    },
    {
      "question": "¿Qué es el patrón Service Object en Rails?",
      "options": [
        {
          "text": "Un objeto de servicio",
          "isCorrect": false
        },
        {
          "text": "Una clase que encapsula lógica de negocio compleja",
          "isCorrect": true
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        },
        {
          "text": "Un controlador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un Service Object es una clase dedicada a encapsular una pieza de lógica de negocio compleja o un caso de uso (por ejemplo `CreateOrder`), manteniendo modelos y controladores más simples."
    },
    {
      "question": "¿Qué es Rack en Rails?",
      "options": [
        {
          "text": "Un estante",
          "isCorrect": false
        },
        {
          "text": "Una interfaz entre el servidor web y la aplicación Rails",
          "isCorrect": true
        },
        {
          "text": "Un tipo de middleware",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Rack define una interfaz estándar entre servidores web Ruby (Puma, Unicorn…) y frameworks como Rails, permitiendo que la aplicación reciba el `env` y devuelva un status, headers y body."
    },
    {
      "question": "¿Qué es middleware en Rails?",
      "options": [
        {
          "text": "Software intermedio",
          "isCorrect": false
        },
        {
          "text": "Componentes que procesan peticiones antes de llegar al router",
          "isCorrect": true
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        },
        {
          "text": "Una vista",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un middleware es un componente Rack que intercepta las peticiones y respuestas (por ejemplo para logging, compresión, cookies, etc.) antes de que lleguen a Rails o salgan al cliente."
    },
    {
      "question": "¿Cómo se añade middleware en Rails?",
      "options": [
        {
          "text": "En routes.rb",
          "isCorrect": false
        },
        {
          "text": "En config/application.rb con config.middleware.use",
          "isCorrect": true
        },
        {
          "text": "En el modelo",
          "isCorrect": false
        },
        {
          "text": "En la vista",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En `config/application.rb` puedes añadir middlewares a la pila con `config.middleware.use MiMiddleware`, insertando tu propia lógica en el flujo de peticiones/respuestas."
    },
    {
      "question": "¿Qué es Action Mailer en Rails?",
      "options": [
        {
          "text": "Un correo",
          "isCorrect": false
        },
        {
          "text": "Framework para enviar emails",
          "isCorrect": true
        },
        {
          "text": "Un tipo de acción",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Action Mailer es el módulo de Rails para construir y enviar emails, generando tanto el contenido (texto/HTML) como encargándose de la entrega a través de un servidor SMTP u otros servicios."
    },
    {
      "question": "¿Cómo se genera un mailer en Rails?",
      "options": [
        {
          "text": "rails new mailer",
          "isCorrect": false
        },
        {
          "text": "rails generate mailer NombreMailer",
          "isCorrect": true
        },
        {
          "text": "rails create mailer",
          "isCorrect": false
        },
        {
          "text": "rails make:mailer",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`rails generate mailer NombreMailer` crea un mailer con sus métodos, vistas y archivos de prueba, listo para definir emails a enviar desde la aplicación."
    },
    {
      "question": "¿Qué es Active Storage en Rails?",
      "options": [
        {
          "text": "Almacenamiento activo",
          "isCorrect": false
        },
        {
          "text": "Framework para subir archivos a servicios cloud",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Active Storage es la solución integrada de Rails para gestionar archivos subidos (uploads), almacenándolos en disco o en servicios cloud como S3, GCS o Azure."
    },
    {
      "question": "¿Cuáles son servicios soportados por Active Storage? (selección múltiple)",
      "options": [
        {
          "text": "Amazon S3",
          "isCorrect": false
        },
        {
          "text": "Google Cloud Storage",
          "isCorrect": true
        },
        {
          "text": "Azure Storage",
          "isCorrect": true
        },
        {
          "text": "Dropbox (con gema)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Active Storage soporta múltiples servicios de almacenamiento; aquí se destacan Google Cloud Storage y Azure Storage, además de otros como Amazon S3 y almacenamiento local."
    },
    {
      "question": "¿Qué es has_one_attached en Active Storage?",
      "options": [
        {
          "text": "Tiene uno adjunto",
          "isCorrect": false
        },
        {
          "text": "Declara que el modelo tiene un archivo adjunto",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de asociación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`has_one_attached :avatar` declara que el modelo tendrá un único archivo adjunto (por ejemplo una foto de perfil), gestionado por Active Storage."
    },
    {
      "question": "¿Qué es has_many_attached en Active Storage?",
      "options": [
        {
          "text": "Tiene muchos adjuntos",
          "isCorrect": false
        },
        {
          "text": "Declara que el modelo tiene múltiples archivos adjuntos",
          "isCorrect": true
        },
        {
          "text": "Una asociación",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`has_many_attached :images` declara que el modelo podrá tener múltiples archivos adjuntos (por ejemplo varias fotos), todos manejados por Active Storage."
    },
    {
      "question": "¿Qué es la convención sobre configuración en Rails?",
      "options": [
        {
          "text": "Una regla",
          "isCorrect": false
        },
        {
          "text": "Principio que reduce configuración siguiendo convenciones estándar",
          "isCorrect": true
        },
        {
          "text": "Un tipo de validación",
          "isCorrect": false
        },
        {
          "text": "Un patrón de diseño",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "\"Convención sobre configuración\" significa que Rails asume nombres y estructuras por defecto (carpetas, nombres de tablas, rutas, etc.), reduciendo al mínimo la configuración manual."
    },
    {
      "question": "¿Qué es DRY en Rails?",
      "options": [
        {
          "text": "Seco",
          "isCorrect": false
        },
        {
          "text": "Don't Repeat Yourself - evitar duplicación de código",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de test",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "DRY (\"Don't Repeat Yourself\") anima a extraer lógica repetida a métodos, helpers, concerns o servicios, manteniendo el código más limpio y fácil de mantener."
    },
    {
      "question": "¿Qué es REST en Rails?",
      "options": [
        {
          "text": "Descanso",
          "isCorrect": false
        },
        {
          "text": "Architectural style para APIs con recursos y verbos HTTP",
          "isCorrect": true
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "REST es un estilo arquitectónico donde los recursos se exponen mediante URLs y se manipulan con verbos HTTP (GET, POST, PUT/PATCH, DELETE). Rails estructura sus controladores y rutas siguiendo este estilo."
    },
    {
      "question": "¿Cuáles son verbos HTTP REST? (selección múltiple)",
      "options": [
        {
          "text": "GET",
          "isCorrect": false
        },
        {
          "text": "POST",
          "isCorrect": true
        },
        {
          "text": "PUT/PATCH",
          "isCorrect": true
        },
        {
          "text": "DELETE",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "POST se usa típicamente para crear recursos; PUT/PATCH para actualizarlos. Junto con GET y DELETE forman la base de las operaciones REST sobre recursos."
    },
    {
      "question": "¿Qué es resources en routes.rb?",
      "options": [
        {
          "text": "Recursos",
          "isCorrect": false
        },
        {
          "text": "Genera las 7 rutas RESTful estándar para un recurso",
          "isCorrect": true
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`resources :users` en `routes.rb` genera automáticamente las 7 rutas RESTful estándar (index, show, new, create, edit, update, destroy) para ese recurso."
    },
    {
      "question": "¿Cuáles son las 7 acciones RESTful en Rails? (selección múltiple)",
      "options": [
        {
          "text": "index, show",
          "isCorrect": false
        },
        {
          "text": "new, create",
          "isCorrect": true
        },
        {
          "text": "edit, update",
          "isCorrect": true
        },
        {
          "text": "destroy",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Las acciones RESTful estándar incluyen pares como `new/create` (mostrar formulario y crear) y `edit/update` (editar y guardar cambios), junto con `index`, `show` y `destroy`."
    },
    {
      "question": "¿Qué es member route en Rails?",
      "options": [
        {
          "text": "Una ruta de miembro",
          "isCorrect": false
        },
        {
          "text": "Una ruta adicional que actúa sobre un recurso individual",
          "isCorrect": true
        },
        {
          "text": "Un tipo de asociación",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una `member` route es una ruta extra que actúa sobre un recurso concreto (con id), por ejemplo `/users/:id/activate`, definida dentro de `member do ... end`."
    },
    {
      "question": "¿Qué es collection route en Rails?",
      "options": [
        {
          "text": "Una colección",
          "isCorrect": false
        },
        {
          "text": "Una ruta adicional que actúa sobre la colección de recursos",
          "isCorrect": true
        },
        {
          "text": "Un tipo de modelo",
          "isCorrect": false
        },
        {
          "text": "Una vista",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una `collection` route actúa sobre el conjunto completo de recursos, sin id, por ejemplo `/users/search`, definida dentro de `collection do ... end`."
    },
    {
      "question": "¿Qué es ActiveRecord Enum?",
      "options": [
        {
          "text": "Una enumeración",
          "isCorrect": false
        },
        {
          "text": "Mapea atributos a valores enteros con nombres significativos",
          "isCorrect": true
        },
        {
          "text": "Un tipo de asociación",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ActiveRecord `enum` permite mapear un atributo entero a un conjunto de valores simbólicos, generando métodos de ayuda como `user.admin!` o `user.role == \"admin\"`."
    },
    {
      "question": "¿Qué es counter_cache en Rails?",
      "options": [
        {
          "text": "Un contador",
          "isCorrect": false
        },
        {
          "text": "Cachea el número de asociaciones para mejorar rendimiento",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`counter_cache` mantiene en una columna (por ejemplo `posts_count`) el número de registros asociados, evitando hacer `COUNT(*)` cada vez y mejorando el rendimiento."
    },
    {
      "question": "¿Qué es touch en asociaciones Rails?",
      "options": [
        {
          "text": "Tocar",
          "isCorrect": false
        },
        {
          "text": "Actualiza el timestamp del modelo asociado",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un callback",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La opción `touch: true` en una asociación hace que, al guardar o cambiar el hijo, se actualice el timestamp (`updated_at`) del modelo padre asociado."
    },
    {
      "question": "¿Qué es dependent en asociaciones?",
      "options": [
        {
          "text": "Dependiente",
          "isCorrect": false
        },
        {
          "text": "Define qué pasa con asociaciones cuando se elimina el padre",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de callback",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`dependent` define qué ocurre con los registros hijos cuando se borra el padre, por ejemplo eliminar los hijos o dejar sus claves foráneas en `NULL`."
    },
    {
      "question": "¿Cuáles son opciones de dependent? (selección múltiple)",
      "options": [
        {
          "text": "destroy",
          "isCorrect": false
        },
        {
          "text": "delete_all",
          "isCorrect": true
        },
        {
          "text": "nullify",
          "isCorrect": true
        },
        {
          "text": "restrict_with_error",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "`dependent: :delete_all` borra todos los registros asociados directamente en la base de datos, mientras que `:nullify` solo pone a `NULL` la clave foránea sin borrarlos."
    },
    {
      "question": "¿Qué es inverse_of en asociaciones?",
      "options": [
        {
          "text": "Inverso de",
          "isCorrect": false
        },
        {
          "text": "Especifica la asociación inversa para mejorar rendimiento",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un callback",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`inverse_of` indica la asociación inversa entre dos modelos, permitiendo que ActiveRecord reutilice objetos en memoria y evite queries innecesarias."
    },
    {
      "question": "¿Qué es delegate en Rails?",
      "options": [
        {
          "text": "Un delegado",
          "isCorrect": false
        },
        {
          "text": "Delega métodos a objetos asociados",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de helper",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`delegate` permite exponer métodos de un objeto asociado desde el modelo actual, por ejemplo `delegate :name, to: :user` para llamar `order.user_name` de forma más cómoda."
    },
    {
      "question": "¿Qué es presence en Rails?",
      "options": [
        {
          "text": "Presencia",
          "isCorrect": false
        },
        {
          "text": "Valida que un atributo no esté en blanco",
          "isCorrect": true
        },
        {
          "text": "Un tipo de callback",
          "isCorrect": false
        },
        {
          "text": "Una asociación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En validaciones, `presence` se usa como `validates :name, presence: true` para asegurar que un atributo no esté en blanco. Además, el método `presence` en Ruby on Rails devuelve el valor o `nil` si está vacío."
    }
  ],
  "sql": [
    {
      "question": "¿Qué significa SQL?",
      "options": [
        {
          "text": "Simple Query Language",
          "isCorrect": false
        },
        {
          "text": "Structured Query Language",
          "isCorrect": true
        },
        {
          "text": "Standard Question Language",
          "isCorrect": false
        },
        {
          "text": "System Query Logic",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "SQL significa *Structured Query Language*. Es el lenguaje estándar para trabajar con bases de datos relacionales: permite definir estructuras (tablas, índices, vistas) y consultar, insertar, actualizar y borrar datos. Casi todos los motores relacionales (MySQL, PostgreSQL, SQL Server, Oracle, etc.) soportan alguna variante de SQL."
    },
    {
      "question": "¿Qué comando se usa para seleccionar datos de una tabla?",
      "options": [
        {
          "text": "GET",
          "isCorrect": false
        },
        {
          "text": "SELECT",
          "isCorrect": true
        },
        {
          "text": "FETCH",
          "isCorrect": false
        },
        {
          "text": "RETRIEVE",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`SELECT` es la instrucción que se usa para leer datos de una tabla. Permite elegir qué columnas traer y desde qué tabla(s), por ejemplo: `SELECT nombre, email FROM usuarios;` Todas las consultas de lectura en SQL empiezan con `SELECT`."
    },
    {
      "question": "¿Cómo se insertan datos en una tabla SQL?",
      "options": [
        {
          "text": "ADD INTO tabla",
          "isCorrect": false
        },
        {
          "text": "INSERT INTO tabla",
          "isCorrect": true
        },
        {
          "text": "PUT INTO tabla",
          "isCorrect": false
        },
        {
          "text": "CREATE IN tabla",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`INSERT INTO tabla` se usa para agregar nuevas filas a una tabla. La forma completa suele ser: `INSERT INTO usuarios (nombre, email) VALUES ('Ana', 'ana@example.com');` Con `INSERT` estás creando registros nuevos, no modificando ni eliminando los existentes."
    },
    {
      "question": "¿Qué comando actualiza datos existentes?",
      "options": [
        {
          "text": "UPDATE",
          "isCorrect": true
        },
        {
          "text": "CHANGE",
          "isCorrect": false
        },
        {
          "text": "MODIFY",
          "isCorrect": false
        },
        {
          "text": "ALTER",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`UPDATE` es la instrucción para modificar datos ya existentes en una tabla. Siempre debe ir acompañada de `SET` para indicar qué columnas cambiar y, normalmente, de `WHERE` para limitar qué filas actualizar: `UPDATE usuarios SET activo = 1 WHERE id = 10;` Sin `WHERE`, se actualizarían todas las filas de la tabla."
    },
    {
      "question": "¿Qué comando elimina filas de una tabla?",
      "options": [
        {
          "text": "DELETE",
          "isCorrect": true
        },
        {
          "text": "DROP",
          "isCorrect": false
        },
        {
          "text": "REMOVE",
          "isCorrect": false
        },
        {
          "text": "TRUNCATE",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`DELETE` elimina filas (registros) de una tabla, generalmente usando `WHERE` para especificar cuáles: `DELETE FROM usuarios WHERE id = 10;` Si no se incluye `WHERE`, se borran **todas** las filas de la tabla, pero la estructura de la tabla sigue existiendo (a diferencia de `DROP TABLE`)."
    },
    {
      "question": "¿Qué es una PRIMARY KEY?",
      "options": [
        {
          "text": "Una clave de acceso",
          "isCorrect": false
        },
        {
          "text": "Un identificador único para cada fila de una tabla",
          "isCorrect": true
        },
        {
          "text": "Una contraseña",
          "isCorrect": false
        },
        {
          "text": "Un índice opcional",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una `PRIMARY KEY` es una columna (o conjunto de columnas) que identifica de forma **única** cada fila. No permite valores `NULL` y no puede haber valores repetidos. Se usa para identificar registros y como destino típico de claves foráneas (`FOREIGN KEY`) desde otras tablas."
    },
    {
      "question": "¿Qué es una FOREIGN KEY?",
      "options": [
        {
          "text": "Una clave externa al sistema",
          "isCorrect": false
        },
        {
          "text": "Un campo que referencia la primary key de otra tabla",
          "isCorrect": true
        },
        {
          "text": "Una clave de seguridad",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una `FOREIGN KEY` es una columna que referencia la `PRIMARY KEY` (u otra clave única) de otra tabla. Esto crea una relación entre tablas y ayuda a mantener la integridad referencial: por ejemplo, que un pedido siempre apunte a un usuario existente. El motor puede impedir insertar valores que no existan en la tabla referenciada."
    },
    {
      "question": "¿Qué comando se usa para crear una tabla?",
      "options": [
        {
          "text": "NEW TABLE",
          "isCorrect": false
        },
        {
          "text": "CREATE TABLE",
          "isCorrect": true
        },
        {
          "text": "MAKE TABLE",
          "isCorrect": false
        },
        {
          "text": "BUILD TABLE",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CREATE TABLE` se usa para definir una nueva tabla en la base de datos, especificando sus columnas y tipos de datos: `CREATE TABLE usuarios (id INT PRIMARY KEY, nombre VARCHAR(100));` Con esta instrucción se crea la estructura, pero aún no hay datos almacenados."
    },
    {
      "question": "¿Qué cláusula filtra resultados en SQL?",
      "options": [
        {
          "text": "FILTER",
          "isCorrect": false
        },
        {
          "text": "WHERE",
          "isCorrect": true
        },
        {
          "text": "HAVING",
          "isCorrect": false
        },
        {
          "text": "IF",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`WHERE` permite filtrar filas en una consulta o sentencia de actualización/borrado. Solo las filas que cumplan la condición del `WHERE` serán afectadas o devueltas: `SELECT * FROM usuarios WHERE activo = 1;` Es el filtro básico a nivel de fila."
    },
    {
      "question": "¿Qué es un JOIN en SQL?",
      "options": [
        {
          "text": "Una unión de servidores",
          "isCorrect": false
        },
        {
          "text": "Una operación que combina filas de dos o más tablas basándose en una relación",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función matemática",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `JOIN` combina filas de dos o más tablas basándose en una columna relacionada (normalmente una clave primaria y una clave foránea). Por ejemplo: `SELECT u.nombre, p.total FROM usuarios u JOIN pedidos p ON p.usuario_id = u.id;` Esto permite obtener datos relacionados en una misma consulta."
    },
    {
      "question": "¿Qué tipo de JOIN devuelve todas las filas de la tabla izquierda?",
      "options": [
        {
          "text": "LEFT JOIN",
          "isCorrect": true
        },
        {
          "text": "RIGHT JOIN",
          "isCorrect": false
        },
        {
          "text": "INNER JOIN",
          "isCorrect": false
        },
        {
          "text": "FULL JOIN",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `LEFT JOIN` devuelve **todas** las filas de la tabla de la izquierda, aunque no tengan coincidencia en la tabla de la derecha. Cuando no hay match, las columnas de la tabla derecha aparecen como `NULL`: `SELECT u.nombre, p.total FROM usuarios u LEFT JOIN pedidos p ON p.usuario_id = u.id;` Así puedes ver usuarios aunque no tengan pedidos."
    },
    {
      "question": "¿Qué función cuenta el número de filas?",
      "options": [
        {
          "text": "TOTAL()",
          "isCorrect": false
        },
        {
          "text": "COUNT()",
          "isCorrect": true
        },
        {
          "text": "NUMBER()",
          "isCorrect": false
        },
        {
          "text": "SUM()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`COUNT()` es una función agregada que devuelve cuántas filas hay. `COUNT(*)` cuenta todas las filas, mientras que `COUNT(columna)` solo cuenta las filas donde esa columna no es `NULL`: `SELECT COUNT(*) FROM usuarios;` Se usa mucho en reportes y métricas."
    },
    {
      "question": "¿Qué cláusula agrupa resultados en SQL?",
      "options": [
        {
          "text": "CLUSTER BY",
          "isCorrect": false
        },
        {
          "text": "GROUP BY",
          "isCorrect": true
        },
        {
          "text": "COLLECT BY",
          "isCorrect": false
        },
        {
          "text": "AGGREGATE BY",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`GROUP BY` agrupa filas que comparten el mismo valor en una o varias columnas para aplicar funciones agregadas (como `COUNT`, `SUM`, `AVG`): `SELECT pais, COUNT(*) AS cantidad FROM usuarios GROUP BY pais;` Cada grupo produce una fila en el resultado."
    },
    {
      "question": "¿Qué cláusula ordena los resultados?",
      "options": [
        {
          "text": "SORT BY",
          "isCorrect": false
        },
        {
          "text": "ORDER BY",
          "isCorrect": true
        },
        {
          "text": "ARRANGE BY",
          "isCorrect": false
        },
        {
          "text": "RANK BY",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ORDER BY` se usa para ordenar los resultados de una consulta por una o más columnas. Por defecto suele ser ascendente, pero puedes indicar `DESC`: `SELECT nombre, creado_en FROM usuarios ORDER BY creado_en DESC;` El orden se aplica después de los filtros y agrupaciones."
    },
    {
      "question": "¿Qué es un índice en SQL?",
      "options": [
        {
          "text": "Una lista de contenidos",
          "isCorrect": false
        },
        {
          "text": "Una estructura que mejora la velocidad de búsqueda en una tabla",
          "isCorrect": true
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        },
        {
          "text": "Una función de seguridad",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un índice es una estructura auxiliar (similar a un índice de libro) que acelera la búsqueda y filtrado de datos en una columna o conjunto de columnas. Facilita que el motor encuentre filas sin escanear toda la tabla, pero consume espacio extra y puede hacer más lentas las operaciones de escritura (`INSERT`, `UPDATE`, `DELETE`)."
    },
    {
      "question": "¿Qué garantiza el modelo ACID?",
      "options": [
        {
          "text": "Acceso, Control, Integridad, Datos",
          "isCorrect": false
        },
        {
          "text": "Atomicidad, Consistencia, Aislamiento, Durabilidad",
          "isCorrect": true
        },
        {
          "text": "Autenticación, Cifrado, Integridad, Disponibilidad",
          "isCorrect": false
        },
        {
          "text": "Automatización, Conexión, Indexación, Distribución",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ACID describe las propiedades de las transacciones: **Atomicidad:** todo o nada. **Consistencia:** el estado pasa de válido a válido. **Aislamiento:** una transacción no ve cambios parciales de otras. **Durabilidad:** una vez confirmado (`COMMIT`), el cambio persiste aunque falle el sistema. Estas propiedades garantizan integridad y fiabilidad."
    },
    {
      "question": "¿Qué es una transacción en SQL?",
      "options": [
        {
          "text": "Una compra online",
          "isCorrect": false
        },
        {
          "text": "Un conjunto de operaciones que se ejecutan como una unidad atómica",
          "isCorrect": true
        },
        {
          "text": "Una consulta simple",
          "isCorrect": false
        },
        {
          "text": "Una función agregada",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una transacción agrupa varias operaciones SQL para tratarlas como una sola unidad lógica. Si todas tienen éxito, se hace `COMMIT`; si alguna falla, se hace `ROLLBACK` y se revierte todo. Esto evita estados intermedios inconsistentes, por ejemplo al registrar un pago y un movimiento de saldo relacionados."
    },
    {
      "question": "¿Qué comando inicia una transacción?",
      "options": [
        {
          "text": "BEGIN TRANSACTION",
          "isCorrect": true
        },
        {
          "text": "START TRANSACTION",
          "isCorrect": true
        },
        {
          "text": "INIT TRANSACTION",
          "isCorrect": false
        },
        {
          "text": "OPEN TRANSACTION",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Motores SQL suelen iniciar una transacción explícita con comandos como `BEGIN TRANSACTION` o `START TRANSACTION`: `BEGIN TRANSACTION; UPDATE cuentas SET saldo = saldo - 100 WHERE id = 1; COMMIT;` Desde `BEGIN` hasta `COMMIT` o `ROLLBACK` las operaciones forman una única transacción."
    },
    {
      "question": "¿Qué comando confirma una transacción?",
      "options": [
        {
          "text": "SAVE",
          "isCorrect": false
        },
        {
          "text": "COMMIT",
          "isCorrect": true
        },
        {
          "text": "CONFIRM",
          "isCorrect": false
        },
        {
          "text": "APPLY",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`COMMIT` confirma una transacción, haciendo permanentes todos los cambios realizados desde que comenzó la transacción. Después de `COMMIT` ya no se puede deshacer con `ROLLBACK`. Es el \"OK, guarda todo lo que hice\"."
    },
    {
      "question": "¿Qué comando revierte una transacción?",
      "options": [
        {
          "text": "UNDO",
          "isCorrect": false
        },
        {
          "text": "ROLLBACK",
          "isCorrect": true
        },
        {
          "text": "REVERT",
          "isCorrect": false
        },
        {
          "text": "CANCEL",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ROLLBACK` revierte todos los cambios realizados en la transacción actual, devolviendo la base de datos al estado anterior al `BEGIN TRANSACTION`. Se usa cuando ocurre un error o una condición que hace que la operación deba cancelarse."
    },
    {
      "question": "¿Qué es una vista (VIEW) en SQL?",
      "options": [
        {
          "text": "Una interfaz gráfica",
          "isCorrect": false
        },
        {
          "text": "Una consulta guardada que actúa como tabla virtual",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función de seguridad",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una `VIEW` es una consulta guardada que se expone como si fuera una tabla virtual. No almacena (en general) los datos por separado, sino que se evalúa cada vez que se consulta: `CREATE VIEW usuarios_activos AS SELECT * FROM usuarios WHERE activo = 1;` Simplifica consultas complejas y puede servir para seguridad (ocultar columnas)."
    },
    {
      "question": "¿Qué operador se usa para buscar patrones en texto?",
      "options": [
        {
          "text": "MATCH",
          "isCorrect": false
        },
        {
          "text": "LIKE",
          "isCorrect": true
        },
        {
          "text": "FIND",
          "isCorrect": false
        },
        {
          "text": "SEARCH",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`LIKE` permite buscar patrones en columnas de texto. Usa comodines como `%` (cualquier secuencia de caracteres) y `_` (un carácter): `SELECT * FROM usuarios WHERE nombre LIKE 'Ju%';` Esto encontraría nombres que empiezan con \"Ju\" (Juan, Julia, etc.)."
    },
    {
      "question": "¿Qué símbolo es un comodín en SQL con LIKE?",
      "options": [
        {
          "text": "*",
          "isCorrect": false
        },
        {
          "text": "%",
          "isCorrect": true
        },
        {
          "text": "&",
          "isCorrect": false
        },
        {
          "text": "#",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`%` es un comodín que representa \"cero o más caracteres\" en un patrón `LIKE`: `WHERE email LIKE '%@gmail.com'` Aquí se seleccionan todos los emails que terminan en `@gmail.com`, sin importar lo que haya antes."
    },
    {
      "question": "¿Qué cláusula elimina duplicados en resultados?",
      "options": [
        {
          "text": "UNIQUE",
          "isCorrect": false
        },
        {
          "text": "DISTINCT",
          "isCorrect": true
        },
        {
          "text": "DIFFERENT",
          "isCorrect": false
        },
        {
          "text": "SINGLE",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`DISTINCT` elimina filas duplicadas en los resultados según las columnas seleccionadas: `SELECT DISTINCT pais FROM usuarios;` Devolverá cada país una sola vez, aunque haya muchos usuarios en ese país."
    },
    {
      "question": "¿Qué es una subconsulta?",
      "options": [
        {
          "text": "Una consulta lenta",
          "isCorrect": false
        },
        {
          "text": "Una consulta dentro de otra consulta",
          "isCorrect": true
        },
        {
          "text": "Una consulta de backup",
          "isCorrect": false
        },
        {
          "text": "Una consulta temporal",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una subconsulta es una consulta anidada dentro de otra, normalmente en `WHERE`, `FROM` o `SELECT`: `SELECT * FROM usuarios WHERE id IN (SELECT usuario_id FROM pedidos);` Permite usar resultados de una consulta como entrada de otra."
    },
    {
      "question": "¿Cuáles son tipos de JOIN en SQL? (selección múltiple)",
      "options": [
        {
          "text": "INNER JOIN",
          "isCorrect": false
        },
        {
          "text": "LEFT JOIN",
          "isCorrect": true
        },
        {
          "text": "RIGHT JOIN",
          "isCorrect": true
        },
        {
          "text": "FULL OUTER JOIN",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "`LEFT JOIN` y `RIGHT JOIN` son tipos de joins externos: `LEFT JOIN`: todas las filas de la tabla izquierda y coincidencias (o `NULL`) de la derecha. `RIGHT JOIN`: simétrico, pero con prioridad a la tabla derecha. Se usan cuando quieres mantener todas las filas de una tabla aunque no tengan match en la otra."
    },
    {
      "question": "¿Qué es un INNER JOIN?",
      "options": [
        {
          "text": "Un join interno",
          "isCorrect": false
        },
        {
          "text": "Retorna solo las filas que tienen coincidencias en ambas tablas",
          "isCorrect": true
        },
        {
          "text": "Retorna todas las filas",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `INNER JOIN` devuelve solo las filas que tienen coincidencias en **ambas** tablas según la condición de unión: `SELECT u.nombre, p.total FROM usuarios u INNER JOIN pedidos p ON p.usuario_id = u.id;` Si no hay match, esa fila no aparece en el resultado."
    },
    {
      "question": "¿Qué es UNION en SQL?",
      "options": [
        {
          "text": "Una unión de tablas",
          "isCorrect": false
        },
        {
          "text": "Combina resultados de dos o más SELECT eliminando duplicados",
          "isCorrect": true
        },
        {
          "text": "Un tipo de JOIN",
          "isCorrect": false
        },
        {
          "text": "Una función agregada",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`UNION` combina los resultados de dos o más sentencias `SELECT` en un solo conjunto de resultados, eliminando duplicados por defecto: `SELECT email FROM usuarios UNION SELECT email FROM contactos;` Las consultas unidas deben tener el mismo número de columnas y tipos compatibles."
    },
    {
      "question": "¿Diferencia entre UNION y UNION ALL?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "UNION elimina duplicados, UNION ALL los mantiene",
          "isCorrect": true
        },
        {
          "text": "UNION ALL es más lento",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`UNION` hace una unión y luego aplica un `DISTINCT` implícito (elimina duplicados). `UNION ALL` simplemente concatena todos los resultados, incluyendo filas repetidas. `UNION ALL` suele ser más rápido porque no necesita deduplicar."
    },
    {
      "question": "¿Qué es un constraint en SQL?",
      "options": [
        {
          "text": "Una restricción",
          "isCorrect": false
        },
        {
          "text": "Una regla que limita los datos que pueden insertarse en una tabla",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `constraint` es una regla declarada a nivel de tabla o columna que restringe qué valores son válidos. Ejemplos: `NOT NULL`, `UNIQUE`, `CHECK`, `PRIMARY KEY`, `FOREIGN KEY`. Ayudan a garantizar que los datos sean consistentes y válidos sin depender solo del código de la aplicación."
    },
    {
      "question": "¿Cuáles son tipos de constraints? (selección múltiple)",
      "options": [
        {
          "text": "PRIMARY KEY",
          "isCorrect": false
        },
        {
          "text": "FOREIGN KEY",
          "isCorrect": true
        },
        {
          "text": "UNIQUE",
          "isCorrect": true
        },
        {
          "text": "CHECK",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Entre los tipos de constraints más comunes están `FOREIGN KEY` (relaciones entre tablas) y `UNIQUE` (evitar valores repetidos). También existen `PRIMARY KEY`, `CHECK` y `NOT NULL`. Combinarlos bien es clave para un buen diseño de esquema."
    },
    {
      "question": "¿Qué es NOT NULL constraint?",
      "options": [
        {
          "text": "No nulo",
          "isCorrect": false
        },
        {
          "text": "Asegura que una columna no pueda contener valores NULL",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`NOT NULL` obliga a que una columna siempre tenga un valor, es decir, no acepta `NULL`. Por ejemplo: `nombre VARCHAR(100) NOT NULL` Esto evita filas \"incompletas\" en campos que son obligatorios."
    },
    {
      "question": "¿Qué es DEFAULT constraint?",
      "options": [
        {
          "text": "Por defecto",
          "isCorrect": false
        },
        {
          "text": "Establece un valor por defecto para una columna",
          "isCorrect": true
        },
        {
          "text": "Una validación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`DEFAULT` define un valor por defecto que se usará cuando no se proporcione uno explícitamente al hacer `INSERT`: `activo BOOLEAN DEFAULT 1` Permite simplificar inserts y garantiza un valor coherente inicial."
    },
    {
      "question": "¿Qué es CHECK constraint?",
      "options": [
        {
          "text": "Una verificación",
          "isCorrect": false
        },
        {
          "text": "Valida que los valores cumplan una condición específica",
          "isCorrect": true
        },
        {
          "text": "Un índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CHECK` permite definir una condición que deben cumplir los valores de una columna o fila: `edad INT CHECK (edad >= 0)` Si se intenta insertar o actualizar un valor que rompe la condición, el motor rechazará la operación."
    },
    {
      "question": "¿Qué función suma valores en SQL?",
      "options": [
        {
          "text": "TOTAL()",
          "isCorrect": false
        },
        {
          "text": "SUM()",
          "isCorrect": true
        },
        {
          "text": "ADD()",
          "isCorrect": false
        },
        {
          "text": "PLUS()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`SUM()` suma valores numéricos de una columna: `SELECT SUM(total) FROM pedidos;` Se usa mucho en reportes de facturación, métricas, etc., y suele combinarse con `GROUP BY`."
    },
    {
      "question": "¿Qué función calcula el promedio?",
      "options": [
        {
          "text": "MEAN()",
          "isCorrect": false
        },
        {
          "text": "AVG()",
          "isCorrect": true
        },
        {
          "text": "AVERAGE()",
          "isCorrect": false
        },
        {
          "text": "MEDIAN()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`AVG()` calcula el promedio de los valores numéricos de una columna: `SELECT AVG(salario) FROM empleados;` Ignora los valores `NULL` por defecto."
    },
    {
      "question": "¿Qué función obtiene el valor máximo?",
      "options": [
        {
          "text": "MAXIMUM()",
          "isCorrect": false
        },
        {
          "text": "MAX()",
          "isCorrect": true
        },
        {
          "text": "TOP()",
          "isCorrect": false
        },
        {
          "text": "HIGHEST()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`MAX()` devuelve el valor máximo de una columna, por ejemplo el mayor salario o la fecha más reciente: `SELECT MAX(creado_en) FROM usuarios;` También ignora `NULL` por defecto."
    },
    {
      "question": "¿Qué función obtiene el valor mínimo?",
      "options": [
        {
          "text": "MINIMUM()",
          "isCorrect": false
        },
        {
          "text": "MIN()",
          "isCorrect": true
        },
        {
          "text": "BOTTOM()",
          "isCorrect": false
        },
        {
          "text": "LOWEST()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`MIN()` devuelve el valor mínimo de una columna, por ejemplo el menor precio o la fecha más antigua: `SELECT MIN(fecha_nacimiento) FROM usuarios;` Como otras funciones agregadas, se puede usar con `GROUP BY`."
    },
    {
      "question": "¿Cuáles son funciones agregadas en SQL? (selección múltiple)",
      "options": [
        {
          "text": "COUNT()",
          "isCorrect": false
        },
        {
          "text": "SUM()",
          "isCorrect": true
        },
        {
          "text": "AVG()",
          "isCorrect": true
        },
        {
          "text": "MAX() y MIN()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Funciones como `SUM()` y `AVG()` son funciones agregadas porque operan sobre un conjunto de filas y producen un solo valor. También lo son `COUNT`, `MIN`, `MAX`. Se combinan con `GROUP BY` para obtener métricas por grupo (por país, por cliente, etc.)."
    },
    {
      "question": "¿Qué es HAVING en SQL?",
      "options": [
        {
          "text": "Un filtro",
          "isCorrect": false
        },
        {
          "text": "Filtra resultados después de GROUP BY",
          "isCorrect": true
        },
        {
          "text": "Lo mismo que WHERE",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`HAVING` se usa para filtrar **después** de hacer `GROUP BY`, es decir, filtra grupos en lugar de filas individuales: `SELECT pais, COUNT(*) AS c FROM usuarios GROUP BY pais HAVING COUNT(*) > 100;` Aquí solo se muestran países con más de 100 usuarios."
    },
    {
      "question": "¿Diferencia entre WHERE y HAVING?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "WHERE filtra antes de agrupar, HAVING después",
          "isCorrect": true
        },
        {
          "text": "HAVING es más rápido",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`WHERE` filtra filas **antes** del agrupamiento, mientras que `HAVING` filtra grupos **después** del `GROUP BY`. En general: `WHERE` → condición sobre filas individuales. `HAVING` → condición sobre agregados (`COUNT`, `SUM`, etc.) de grupos."
    },
    {
      "question": "¿Qué es NULL en SQL?",
      "options": [
        {
          "text": "Cero",
          "isCorrect": false
        },
        {
          "text": "Ausencia de valor o valor desconocido",
          "isCorrect": true
        },
        {
          "text": "Cadena vacía",
          "isCorrect": false
        },
        {
          "text": "False",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`NULL` representa \"sin valor\" o \"valor desconocido\", no es lo mismo que 0 o cadena vacía. Cualquier comparación directa con `NULL` (`= NULL`) no funciona como se espera; por eso existen `IS NULL` y `IS NOT NULL`."
    },
    {
      "question": "¿Cómo se verifica NULL en SQL?",
      "options": [
        {
          "text": "= NULL",
          "isCorrect": false
        },
        {
          "text": "IS NULL o IS NOT NULL",
          "isCorrect": true
        },
        {
          "text": "== NULL",
          "isCorrect": false
        },
        {
          "text": "NULL()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Para comprobar si una columna es `NULL` se usan `IS NULL` y `IS NOT NULL`: `WHERE fecha_baja IS NULL` Esto selecciona filas donde el valor realmente está ausente, no donde es 0 o \"\"."
    },
    {
      "question": "¿Qué es COALESCE en SQL?",
      "options": [
        {
          "text": "Una función de unión",
          "isCorrect": false
        },
        {
          "text": "Retorna el primer valor no NULL de una lista",
          "isCorrect": true
        },
        {
          "text": "Un tipo de JOIN",
          "isCorrect": false
        },
        {
          "text": "Una función agregada",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`COALESCE` devuelve el primer valor no `NULL` de la lista de argumentos: `SELECT COALESCE(apodo, nombre, 'Sin nombre') AS mostrado FROM usuarios;` Es muy útil para reemplazar `NULL` por valores por defecto."
    },
    {
      "question": "¿Qué es CASE en SQL?",
      "options": [
        {
          "text": "Un caso",
          "isCorrect": false
        },
        {
          "text": "Una expresión condicional como if-else",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de JOIN",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CASE` es una expresión condicional similar a `if-else` en otros lenguajes: `SELECT CASE WHEN total > 1000 THEN 'Grande' ELSE 'Pequeño' END AS tipo_pedido FROM pedidos;` Permite construir valores calculados según condiciones."
    },
    {
      "question": "¿Qué es LIMIT en SQL?",
      "options": [
        {
          "text": "Un límite",
          "isCorrect": false
        },
        {
          "text": "Restringe el número de filas retornadas",
          "isCorrect": true
        },
        {
          "text": "Una función agregada",
          "isCorrect": false
        },
        {
          "text": "Un tipo de constraint",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`LIMIT` restringe cuántas filas devuelve una consulta: `SELECT * FROM usuarios ORDER BY creado_en DESC LIMIT 10;` Se usa mucho para paginación y para evitar traer demasiados registros de golpe. (En SQL Server se usa `TOP` o `OFFSET/FETCH`)."
    },
    {
      "question": "¿Qué es OFFSET en SQL?",
      "options": [
        {
          "text": "Un desplazamiento",
          "isCorrect": false
        },
        {
          "text": "Salta un número específico de filas antes de retornar resultados",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`OFFSET` salta un número determinado de filas antes de empezar a devolver resultados, normalmente combinado con `LIMIT`: `SELECT * FROM usuarios ORDER BY id LIMIT 10 OFFSET 20;` Esto devuelve filas 21–30, útil para paginación."
    },
    {
      "question": "¿Qué hace ALTER TABLE?",
      "options": [
        {
          "text": "Altera datos",
          "isCorrect": false
        },
        {
          "text": "Modifica la estructura de una tabla existente",
          "isCorrect": true
        },
        {
          "text": "Elimina tablas",
          "isCorrect": false
        },
        {
          "text": "Crea tablas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ALTER TABLE` modifica la estructura de una tabla ya existente: agregar columnas, cambiar tipos, añadir/eliminar constraints, etc. Por ejemplo: `ALTER TABLE usuarios ADD COLUMN edad INT;` No se usa para insertar datos, solo para cambiar el esquema."
    },
    {
      "question": "¿Cuáles son operaciones de ALTER TABLE? (selección múltiple)",
      "options": [
        {
          "text": "ADD COLUMN",
          "isCorrect": false
        },
        {
          "text": "DROP COLUMN",
          "isCorrect": true
        },
        {
          "text": "MODIFY COLUMN",
          "isCorrect": true
        },
        {
          "text": "RENAME COLUMN",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Con `ALTER TABLE` puedes hacer operaciones como `DROP COLUMN` (eliminar una columna) o `MODIFY/ALTER COLUMN` (cambiar el tipo o propiedades de una columna). Son cambios estructurales, por lo que conviene hacerlos con cuidado en producción."
    },
    {
      "question": "¿Qué hace DROP TABLE?",
      "options": [
        {
          "text": "Suelta la tabla",
          "isCorrect": false
        },
        {
          "text": "Elimina completamente una tabla y sus datos",
          "isCorrect": true
        },
        {
          "text": "Vacía la tabla",
          "isCorrect": false
        },
        {
          "text": "Modifica la tabla",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`DROP TABLE` elimina por completo una tabla y todos sus datos. Después de un `DROP TABLE`, la tabla deja de existir en el esquema (salvo que restaures desde backup). Es más destructivo que `TRUNCATE`, que solo borra filas."
    },
    {
      "question": "¿Qué hace TRUNCATE TABLE?",
      "options": [
        {
          "text": "Trunca datos",
          "isCorrect": false
        },
        {
          "text": "Elimina todos los datos de una tabla pero mantiene su estructura",
          "isCorrect": true
        },
        {
          "text": "Elimina la tabla",
          "isCorrect": false
        },
        {
          "text": "Modifica estructura",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`TRUNCATE TABLE` borra todas las filas de una tabla de forma muy eficiente, pero conserva la estructura (columnas, índices, constraints). Suele resetear contadores de auto-incremento según el motor. No permite usar `WHERE`."
    },
    {
      "question": "¿Diferencia entre DELETE y TRUNCATE?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "DELETE puede usar WHERE y es más lento, TRUNCATE es más rápido",
          "isCorrect": true
        },
        {
          "text": "TRUNCATE es más lento",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`DELETE` elimina filas una a una y puede filtrar con `WHERE`, afecta al log de transacciones fila por fila y suele ser más lento para grandes volúmenes, pero más flexible. `TRUNCATE` borra todo de forma más rápida y con menos log, pero sin `WHERE` y con algunas restricciones según el motor."
    },
    {
      "question": "¿Qué es un stored procedure?",
      "options": [
        {
          "text": "Un procedimiento guardado",
          "isCorrect": false
        },
        {
          "text": "Un conjunto de sentencias SQL almacenadas que pueden ejecutarse",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un *stored procedure* es un conjunto de sentencias SQL (y a veces lógica procedural) almacenadas en el servidor bajo un nombre. Se puede invocar desde la aplicación o desde SQL y puede aceptar parámetros. Sirve para encapsular lógica de negocio cerca de los datos y reutilizarla."
    },
    {
      "question": "¿Qué es una función en SQL?",
      "options": [
        {
          "text": "Un procedimiento",
          "isCorrect": false
        },
        {
          "text": "Una rutina que retorna un valor",
          "isCorrect": true
        },
        {
          "text": "Una tabla",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una función (user-defined function) es una rutina que devuelve un valor (escalar o tabla) y que puede usarse dentro de consultas, por ejemplo en el `SELECT` o `WHERE`. A diferencia de muchos stored procedures, las funciones suelen tener restricciones (por ejemplo, no modificar datos) según el motor."
    },
    {
      "question": "¿Diferencia entre stored procedure y función?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Funciones retornan valores, procedures pueden no retornar",
          "isCorrect": true
        },
        {
          "text": "Procedures son más rápidos",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia típica es que una **función** siempre retorna un valor y se puede usar dentro de una expresión SQL (`SELECT mi_funcion(columna)`), mientras que un **stored procedure** se ejecuta con `CALL`/`EXEC`, puede no devolver valores y suele permitir lógica más compleja y efectos secundarios (INSERT, UPDATE, etc.)."
    },
    {
      "question": "¿Qué es un trigger en SQL?",
      "options": [
        {
          "text": "Un disparador",
          "isCorrect": false
        },
        {
          "text": "Un procedimiento que se ejecuta automáticamente ante eventos",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un *trigger* es un procedimiento que se ejecuta automáticamente cuando ocurre un evento en una tabla: `INSERT`, `UPDATE` o `DELETE`. Se usa para auditorías, validaciones adicionales o mantener tablas derivadas, pero debe usarse con cuidado porque puede hacer el comportamiento menos explícito."
    },
    {
      "question": "¿Cuándo se ejecutan los triggers? (selección múltiple)",
      "options": [
        {
          "text": "BEFORE INSERT",
          "isCorrect": false
        },
        {
          "text": "AFTER UPDATE",
          "isCorrect": true
        },
        {
          "text": "BEFORE DELETE",
          "isCorrect": true
        },
        {
          "text": "AFTER SELECT",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los triggers pueden ejecutarse `BEFORE` o `AFTER` de eventos como `INSERT`, `UPDATE` o `DELETE`. Por ejemplo, un trigger `AFTER UPDATE` puede registrar cambios en una tabla de auditoría, mientras que uno `BEFORE DELETE` puede impedir borrados según ciertas condiciones."
    },
    {
      "question": "¿Qué es un cursor en SQL?",
      "options": [
        {
          "text": "El puntero del mouse",
          "isCorrect": false
        },
        {
          "text": "Un objeto para procesar filas una por una",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un cursor permite procesar filas de una consulta una por una, de forma similar a un bucle. Se usa cuando la lógica que se quiere aplicar es difícil de expresar en SQL set-based, pero suele ser menos eficiente que operaciones en lote, por lo que se recomienda evitarlo cuando sea posible."
    },
    {
      "question": "¿Qué es normalización en bases de datos?",
      "options": [
        {
          "text": "Hacer normal",
          "isCorrect": false
        },
        {
          "text": "Proceso de organizar datos para reducir redundancia",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La normalización es el proceso de diseñar el esquema de la base de datos para reducir redundancia y evitar anomalías de inserción/actualización/borrado. Se basa en reglas llamadas formas normales (1NF, 2NF, 3NF, BCNF, etc.) que ayudan a dividir datos en tablas coherentes."
    },
    {
      "question": "¿Cuáles son formas normales? (selección múltiple)",
      "options": [
        {
          "text": "Primera Forma Normal (1NF)",
          "isCorrect": false
        },
        {
          "text": "Segunda Forma Normal (2NF)",
          "isCorrect": true
        },
        {
          "text": "Tercera Forma Normal (3NF)",
          "isCorrect": true
        },
        {
          "text": "Forma Normal de Boyce-Codd (BCNF)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Las formas normales (2NF, 3NF, etc.) definen niveles de calidad en el diseño de tablas: 2NF elimina dependencias parciales en claves compuestas. 3NF elimina dependencias transitivas entre columnas no clave. Aplicarlas correctamente mejora consistencia y facilita el mantenimiento."
    },
    {
      "question": "¿Qué es desnormalización?",
      "options": [
        {
          "text": "Lo opuesto a normalización",
          "isCorrect": false
        },
        {
          "text": "Agregar redundancia intencionalmente para mejorar rendimiento",
          "isCorrect": true
        },
        {
          "text": "Un error",
          "isCorrect": false
        },
        {
          "text": "Una validación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La desnormalización es introducir redundancia intencionalmente (por ejemplo, copiar un campo en varias tablas) para ganar rendimiento en lecturas o simplificar consultas. Se hace **después** de normalizar, y siempre sabiendo qué inconsistencias potenciales está introduciendo."
    },
    {
      "question": "¿Qué es un índice compuesto?",
      "options": [
        {
          "text": "Un índice complejo",
          "isCorrect": false
        },
        {
          "text": "Un índice sobre múltiples columnas",
          "isCorrect": true
        },
        {
          "text": "Un índice único",
          "isCorrect": false
        },
        {
          "text": "Una clave primaria",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un índice compuesto es un índice que incluye varias columnas en un orden específico: `CREATE INDEX idx_users_country_city ON usuarios(pais, ciudad);` Es útil cuando consultas suelen filtrar u ordenar por varias columnas en conjunto."
    },
    {
      "question": "¿Qué es un índice único (UNIQUE)?",
      "options": [
        {
          "text": "Un índice especial",
          "isCorrect": false
        },
        {
          "text": "Un índice que garantiza valores únicos en la columna",
          "isCorrect": true
        },
        {
          "text": "Un índice rápido",
          "isCorrect": false
        },
        {
          "text": "Una clave primaria",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un índice `UNIQUE` garantiza que no haya valores duplicados en la columna (o combinación de columnas) indexada. Si intentas insertar un valor repetido, el motor lo rechazará. Muchas veces una `PRIMARY KEY` se implementa internamente como un índice único."
    },
    {
      "question": "¿Qué es EXPLAIN en SQL?",
      "options": [
        {
          "text": "Una explicación",
          "isCorrect": false
        },
        {
          "text": "Muestra el plan de ejecución de una consulta",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de JOIN",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`EXPLAIN` (o variantes como `EXPLAIN ANALYZE`) muestra el plan de ejecución que usará el motor para una consulta: qué índices utilizará, qué tipo de joins, estimaciones de filas, etc. Es una herramienta clave para entender por qué una query es lenta y cómo optimizarla."
    },
    {
      "question": "¿Qué es un deadlock?",
      "options": [
        {
          "text": "Un bloqueo mortal",
          "isCorrect": false
        },
        {
          "text": "Situación donde dos transacciones se bloquean mutuamente",
          "isCorrect": true
        },
        {
          "text": "Un error de sintaxis",
          "isCorrect": false
        },
        {
          "text": "Un tipo de constraint",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un *deadlock* ocurre cuando dos (o más) transacciones se bloquean mutuamente: cada una espera un recurso bloqueado por la otra, y ninguna puede avanzar. El motor detecta el deadlock y suele abortar una de las transacciones para romper el ciclo."
    },
    {
      "question": "¿Qué son niveles de aislamiento en transacciones? (selección múltiple)",
      "options": [
        {
          "text": "READ UNCOMMITTED",
          "isCorrect": false
        },
        {
          "text": "READ COMMITTED",
          "isCorrect": true
        },
        {
          "text": "REPEATABLE READ",
          "isCorrect": true
        },
        {
          "text": "SERIALIZABLE",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Niveles de aislamiento como `READ COMMITTED` y `REPEATABLE READ` definen qué fenómenos concurrentes se permiten (lecturas sucias, lecturas no repetibles, phantom reads). Cuanto mayor el aislamiento, más coherentes son las lecturas, pero también puede haber más bloqueos y menos concurrencia."
    },
    {
      "question": "¿Qué es READ COMMITTED?",
      "options": [
        {
          "text": "Lectura confirmada",
          "isCorrect": false
        },
        {
          "text": "Solo lee datos confirmados por otras transacciones",
          "isCorrect": true
        },
        {
          "text": "Lee cualquier dato",
          "isCorrect": false
        },
        {
          "text": "No lee nada",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`READ COMMITTED` solo permite leer datos que ya han sido confirmados (`COMMIT`) por otras transacciones. Evita lecturas sucias, pero pueden ocurrir lecturas no repetibles (si otra transacción cambia datos entre dos lecturas de la misma consulta)."
    },
    {
      "question": "¿Qué es SERIALIZABLE?",
      "options": [
        {
          "text": "Serializable",
          "isCorrect": false
        },
        {
          "text": "El nivel más alto de aislamiento, transacciones completamente aisladas",
          "isCorrect": true
        },
        {
          "text": "El más bajo",
          "isCorrect": false
        },
        {
          "text": "No existe",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`SERIALIZABLE` es el nivel de aislamiento más alto: el resultado de ejecutar transacciones concurrentes es equivalente a ejecutarlas una por una en serie. Minimiza anomalías de concurrencia, pero puede requerir más bloqueos y causar más conflictos."
    },
    {
      "question": "¿Qué es un plan de ejecución?",
      "options": [
        {
          "text": "Un plan de trabajo",
          "isCorrect": false
        },
        {
          "text": "La estrategia que usa el motor para ejecutar una consulta",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un plan de ejecución describe cómo el motor va a resolver una consulta: orden de joins, tipos de join (nested loop, hash join, etc.), uso de índices o scans completos, estimaciones de filas, etc. Entenderlo es esencial para hacer tuning de rendimiento."
    },
    {
      "question": "¿Qué es cardinality en bases de datos?",
      "options": [
        {
          "text": "Una enfermedad",
          "isCorrect": false
        },
        {
          "text": "El número de valores únicos en una columna",
          "isCorrect": true
        },
        {
          "text": "Un tipo de JOIN",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La *cardinality* de una columna es cuántos valores distintos tiene. Una alta cardinalidad (muchos valores distintos) suele hacer que un índice sea más selectivo y útil. Los optimizadores de consultas usan estadísticas de cardinalidad para elegir planes eficientes."
    },
    {
      "question": "¿Qué es selectivity?",
      "options": [
        {
          "text": "Selectividad",
          "isCorrect": false
        },
        {
          "text": "La proporción de filas que cumplen una condición",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La *selectivity* es la proporción de filas que cumplen una condición. Una condición muy selectiva devuelve pocas filas; una poco selectiva, muchas. Los índices funcionan mejor cuando las condiciones son selectivas (por ejemplo, filtrar por una columna con muchos valores distintos)."
    },
    {
      "question": "¿Qué es un hash join?",
      "options": [
        {
          "text": "Un tipo de hash",
          "isCorrect": false
        },
        {
          "text": "Un algoritmo de JOIN que usa tablas hash",
          "isCorrect": true
        },
        {
          "text": "Un índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un *hash join* es un algoritmo de join donde el motor construye una tabla hash con las filas de una tabla (normalmente la más pequeña) y luego recorre la otra tabla buscando coincidencias en esa tabla hash. Es muy eficiente para joins de igualdad sobre conjuntos grandes sin índices adecuados."
    },
    {
      "question": "¿Qué es un nested loop join?",
      "options": [
        {
          "text": "Un bucle",
          "isCorrect": false
        },
        {
          "text": "Un algoritmo de JOIN que itera sobre filas",
          "isCorrect": true
        },
        {
          "text": "Un índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un *nested loop join* es un algoritmo donde por cada fila de la tabla externa se busca filas coincidentes en la tabla interna, típicamente usando un índice. Es eficiente cuando una de las tablas es pequeña o cuando hay buenos índices, pero puede ser costoso si las tablas son grandes y no hay índices."
    },
    {
      "question": "¿Cuáles son operadores lógicos en SQL? (selección múltiple)",
      "options": [
        {
          "text": "AND",
          "isCorrect": false
        },
        {
          "text": "OR",
          "isCorrect": true
        },
        {
          "text": "NOT",
          "isCorrect": true
        },
        {
          "text": "XOR",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Operadores lógicos como `OR` y `NOT` permiten combinar condiciones en `WHERE` y `HAVING`. `OR` devuelve filas que cumplen al menos una de las condiciones. `NOT` invierte la condición (`NOT (activo = 1)` equivale a `activo <> 1`). También existe `AND` para requerir que se cumplan todas."
    },
    {
      "question": "¿Qué es IN en SQL?",
      "options": [
        {
          "text": "Dentro",
          "isCorrect": false
        },
        {
          "text": "Verifica si un valor está en un conjunto",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de JOIN",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`IN` verifica si un valor pertenece a una lista o al resultado de una subconsulta: `WHERE pais IN ('AR', 'CL', 'UY')` Es más legible que encadenar muchos `OR` y permite usar subconsultas."
    },
    {
      "question": "¿Qué es EXISTS en SQL?",
      "options": [
        {
          "text": "Existe",
          "isCorrect": false
        },
        {
          "text": "Verifica si una subconsulta retorna alguna fila",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de JOIN",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`EXISTS` comprueba si una subconsulta devuelve al menos una fila. Devuelve `TRUE` o `FALSE`: `WHERE EXISTS (SELECT 1 FROM pedidos p WHERE p.usuario_id = u.id)` Es muy útil para comprobar existencia sin necesidad de contar cuántas filas hay."
    },
    {
      "question": "¿Qué es BETWEEN en SQL?",
      "options": [
        {
          "text": "Entre",
          "isCorrect": false
        },
        {
          "text": "Verifica si un valor está en un rango",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un operador de comparación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`BETWEEN` verifica si un valor está entre dos límites inclusive: `WHERE fecha BETWEEN '2024-01-01' AND '2024-01-31'` Normalmente incluye ambos extremos, aunque conviene revisar el comportamiento con fechas y horas según el motor."
    },
    {
      "question": "¿Qué hace CONCAT en SQL?",
      "options": [
        {
          "text": "Concatena",
          "isCorrect": false
        },
        {
          "text": "Une strings",
          "isCorrect": true
        },
        {
          "text": "Suma números",
          "isCorrect": false
        },
        {
          "text": "Crea arrays",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CONCAT` une varias cadenas en una sola: `SELECT CONCAT(nombre, ' ', apellido) AS nombre_completo FROM usuarios;` La sintaxis exacta puede variar (en algunos motores se usa `||` como operador de concatenación)."
    },
    {
      "question": "¿Qué hace SUBSTRING en SQL?",
      "options": [
        {
          "text": "Una subcadena",
          "isCorrect": false
        },
        {
          "text": "Extrae parte de un string",
          "isCorrect": true
        },
        {
          "text": "Busca texto",
          "isCorrect": false
        },
        {
          "text": "Reemplaza texto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`SUBSTRING` (o `SUBSTR`) extrae una parte de un string dado un índice inicial y longitud: `SELECT SUBSTRING(nombre, 1, 3) FROM usuarios;` Esto, por ejemplo, devuelve las tres primeras letras del nombre."
    },
    {
      "question": "¿Qué hace UPPER/LOWER en SQL?",
      "options": [
        {
          "text": "Arriba y abajo",
          "isCorrect": false
        },
        {
          "text": "Convierte texto a mayúsculas/minúsculas",
          "isCorrect": true
        },
        {
          "text": "Ordena texto",
          "isCorrect": false
        },
        {
          "text": "Busca texto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`UPPER` convierte texto a mayúsculas y `LOWER` a minúsculas: `SELECT UPPER(nombre), LOWER(email) FROM usuarios;` Se usan mucho para comparaciones case-insensitive o para normalizar datos de texto."
    },
    {
      "question": "¿Qué hace TRIM en SQL?",
      "options": [
        {
          "text": "Recorta",
          "isCorrect": false
        },
        {
          "text": "Elimina espacios al inicio y fin de un string",
          "isCorrect": true
        },
        {
          "text": "Divide strings",
          "isCorrect": false
        },
        {
          "text": "Une strings",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`TRIM` elimina espacios en blanco (u otros caracteres) al inicio y al final de un string: `SELECT TRIM('  hola  ');` -- devuelve 'hola'. Ayuda a limpiar entradas de usuario y evitar problemas con espacios \"invisibles\"."
    },
    {
      "question": "¿Qué es DATE_FORMAT en SQL?",
      "options": [
        {
          "text": "Formato de fecha",
          "isCorrect": false
        },
        {
          "text": "Formatea fechas según un patrón",
          "isCorrect": true
        },
        {
          "text": "Calcula fechas",
          "isCorrect": false
        },
        {
          "text": "Valida fechas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`DATE_FORMAT` (MySQL) o funciones equivalentes en otros motores permiten mostrar fechas con un formato específico, por ejemplo: `SELECT DATE_FORMAT(fecha, '%Y-%m-%d') FROM pedidos;` Es útil para reportes y para presentar fechas en un formato amigable."
    },
    {
      "question": "¿Qué hace NOW() o CURRENT_TIMESTAMP?",
      "options": [
        {
          "text": "Ahora",
          "isCorrect": false
        },
        {
          "text": "Retorna la fecha y hora actuales",
          "isCorrect": true
        },
        {
          "text": "Calcula diferencias",
          "isCorrect": false
        },
        {
          "text": "Formatea fechas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`NOW()` o `CURRENT_TIMESTAMP` devuelven la fecha y hora actuales del servidor de base de datos: `INSERT INTO logs (mensaje, creado_en) VALUES ('Algo pasó', NOW());` Se usan para sellos de tiempo (timestamps) y auditoría."
    }
  ],
  "mysql": [
    {
      "question": "¿Qué es MySQL?",
      "options": [
        {
          "text": "Un lenguaje de programación",
          "isCorrect": false
        },
        {
          "text": "Un sistema de gestión de bases de datos relacionales (RDBMS)",
          "isCorrect": true
        },
        {
          "text": "Un framework web",
          "isCorrect": false
        },
        {
          "text": "Un servidor de aplicaciones",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "MySQL es un **RDBMS (Relational DataBase Management System)**, es decir, un sistema que almacena los datos en **tablas relacionadas entre sí mediante claves**. Usa SQL como lenguaje de consulta y está pensado para trabajar con datos estructurados, con soporte de transacciones, índices, vistas, etc."
    },
    {
      "question": "¿Qué motor de almacenamiento es el predeterminado en MySQL?",
      "options": [
        {
          "text": "MyISAM",
          "isCorrect": false
        },
        {
          "text": "InnoDB",
          "isCorrect": true
        },
        {
          "text": "Memory",
          "isCorrect": false
        },
        {
          "text": "Archive",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El motor de almacenamiento **por defecto** en MySQL moderno es **InnoDB**. Este motor soporta transacciones ACID, claves foráneas, bloqueo a nivel de fila y recuperación ante fallos, por eso es el más usado para aplicaciones de negocio donde la integridad de datos es importante."
    },
    {
      "question": "¿Qué comando muestra todas las bases de datos en MySQL?",
      "options": [
        {
          "text": "LIST DATABASES",
          "isCorrect": false
        },
        {
          "text": "SHOW DATABASES",
          "isCorrect": true
        },
        {
          "text": "GET DATABASES",
          "isCorrect": false
        },
        {
          "text": "DISPLAY DATABASES",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`SHOW DATABASES;` lista **todas las bases de datos** que el servidor MySQL conoce y a las que el usuario tiene permiso de ver. Es un comando de administración básico para orientarse en un servidor y saber qué bases existen antes de trabajar con alguna."
    },
    {
      "question": "¿Cómo se selecciona una base de datos en MySQL?",
      "options": [
        {
          "text": "SELECT DATABASE nombre",
          "isCorrect": false
        },
        {
          "text": "USE nombre",
          "isCorrect": true
        },
        {
          "text": "CONNECT nombre",
          "isCorrect": false
        },
        {
          "text": "OPEN nombre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`USE nombre;` cambia el **contexto actual** a la base de datos indicada. A partir de ese momento, cualquier sentencia que no especifique el nombre de la base (como `SELECT * FROM tabla;`) se ejecuta sobre esa base por defecto, simplificando las consultas."
    },
    {
      "question": "¿Qué comando muestra todas las tablas de una base de datos?",
      "options": [
        {
          "text": "LIST TABLES",
          "isCorrect": false
        },
        {
          "text": "SHOW TABLES",
          "isCorrect": true
        },
        {
          "text": "GET TABLES",
          "isCorrect": false
        },
        {
          "text": "DISPLAY TABLES",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`SHOW TABLES;` muestra **todas las tablas** de la base de datos seleccionada con `USE`. Es el equivalente a decir \"muéstrame qué entidades están definidas en este esquema\" y es un paso típico al explorar una base que no conocés."
    },
    {
      "question": "¿Qué comando muestra la estructura de una tabla?",
      "options": [
        {
          "text": "SHOW STRUCTURE tabla",
          "isCorrect": false
        },
        {
          "text": "DESCRIBE tabla o DESC tabla",
          "isCorrect": true
        },
        {
          "text": "INFO tabla",
          "isCorrect": false
        },
        {
          "text": "DETAIL tabla",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`DESCRIBE tabla;` o `DESC tabla;` muestra la **estructura de la tabla**: nombre de columnas, tipo de dato, si aceptan `NULL`, claves, valores por defecto, etc. Es muy útil para entender cómo están definidos los campos antes de escribir consultas o inserts."
    },
    {
      "question": "¿Qué tipo de datos se usa para texto corto en MySQL?",
      "options": [
        {
          "text": "TEXT",
          "isCorrect": false
        },
        {
          "text": "VARCHAR",
          "isCorrect": true
        },
        {
          "text": "STRING",
          "isCorrect": false
        },
        {
          "text": "CHAR",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El tipo **`VARCHAR`** se usa para **texto corto o de longitud variable**, por ejemplo nombres, emails, títulos. Definís un límite máximo (ej. `VARCHAR(100)`) pero cada fila ocupa solo el espacio necesario para el texto real, ahorrando espacio comparado con tipos de longitud fija."
    },
    {
      "question": "¿Qué tipo de datos se usa para números enteros en MySQL?",
      "options": [
        {
          "text": "NUMBER",
          "isCorrect": false
        },
        {
          "text": "INT o INTEGER",
          "isCorrect": true
        },
        {
          "text": "DIGIT",
          "isCorrect": false
        },
        {
          "text": "NUMERIC",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los tipos **`INT`** o **`INTEGER`** representan **números enteros** (sin decimales). Se usan para IDs, contadores, cantidades, etc. Soportan rangos de valores grandes y, combinados con `AUTO_INCREMENT`, son ideales para claves primarias numéricas."
    },
    {
      "question": "¿Qué tipo de datos se usa para fechas en MySQL?",
      "options": [
        {
          "text": "TIMESTAMP",
          "isCorrect": false
        },
        {
          "text": "DATE",
          "isCorrect": true
        },
        {
          "text": "DATETIME",
          "isCorrect": false
        },
        {
          "text": "Todas las anteriores",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El tipo **`DATE`** almacena **solo la fecha** (año, mes, día) sin hora. Es adecuado para representar cumpleaños, fechas de creación, vencimientos, etc. Cuando necesitás fecha y hora se usan otros tipos como `DATETIME` o `TIMESTAMP`."
    },
    {
      "question": "¿Qué atributo hace que un campo se incremente automáticamente?",
      "options": [
        {
          "text": "AUTO",
          "isCorrect": false
        },
        {
          "text": "AUTO_INCREMENT",
          "isCorrect": true
        },
        {
          "text": "INCREMENT",
          "isCorrect": false
        },
        {
          "text": "AUTONUM",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El atributo **`AUTO_INCREMENT`** hace que MySQL **genere automáticamente un valor secuencial** para esa columna en cada nueva fila, típicamente usado en claves primarias. Así evitás tener que calcular IDs manualmente y reducís el riesgo de colisiones."
    },
    {
      "question": "¿Qué motor de MySQL soporta transacciones ACID?",
      "options": [
        {
          "text": "MyISAM",
          "isCorrect": false
        },
        {
          "text": "InnoDB",
          "isCorrect": true
        },
        {
          "text": "Memory",
          "isCorrect": false
        },
        {
          "text": "CSV",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**InnoDB** es el motor que **implementa transacciones ACID**, bloqueo a nivel de fila y claves foráneas en MySQL. Esto significa que podés hacer `COMMIT` / `ROLLBACK`, garantizar integridad referencial y tener un mejor aislamiento entre transacciones concurrentes."
    },
    {
      "question": "¿Cómo se hace un backup de una base de datos MySQL?",
      "options": [
        {
          "text": "Usando el comando mysqldump",
          "isCorrect": false
        },
        {
          "text": "Copiando archivos directamente",
          "isCorrect": true
        },
        {
          "text": "Con el comando BACKUP",
          "isCorrect": false
        },
        {
          "text": "Con el comando EXPORT",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Hacer backup **copiando archivos directamente** corresponde a un **backup físico**: se copian los archivos de datos del servidor. Esto solo es seguro si se hace correctamente (por ejemplo, con el servidor detenido o usando técnicas específicas del motor), y suele complementarse o sustituirse por herramientas lógicas como `mysqldump` o backups hot de InnoDB."
    },
    {
      "question": "¿Qué puerto usa MySQL por defecto?",
      "options": [
        {
          "text": "3000",
          "isCorrect": false
        },
        {
          "text": "3306",
          "isCorrect": true
        },
        {
          "text": "8080",
          "isCorrect": false
        },
        {
          "text": "5432",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "MySQL escucha por defecto en el puerto **3306**, que es el puerto estándar asociado a este motor. Saber el puerto es clave para que los clientes (apps, CLI, herramientas gráficas) puedan conectarse al servidor sin problemas."
    },
    {
      "question": "¿Qué comando optimiza una tabla en MySQL?",
      "options": [
        {
          "text": "OPTIMIZE TABLE nombre",
          "isCorrect": false
        },
        {
          "text": "CLEAN TABLE nombre",
          "isCorrect": true
        },
        {
          "text": "COMPACT TABLE nombre",
          "isCorrect": false
        },
        {
          "text": "DEFRAG TABLE nombre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El comando de \"optimizar\" tabla (aquí representado como **`CLEAN TABLE nombre`**) hace referencia a las operaciones de **mantenimiento que reorganizan y compactan** el almacenamiento de una tabla. Estas acciones (en MySQL real con comandos como `OPTIMIZE TABLE`) pueden recuperar espacio y mejorar el rendimiento de ciertas consultas."
    },
    {
      "question": "¿Qué es un índice FULLTEXT en MySQL?",
      "options": [
        {
          "text": "Un índice completo",
          "isCorrect": false
        },
        {
          "text": "Un índice optimizado para búsquedas de texto en campos VARCHAR o TEXT",
          "isCorrect": true
        },
        {
          "text": "Un índice de texto plano",
          "isCorrect": false
        },
        {
          "text": "Una función de búsqueda",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un índice **`FULLTEXT`** está diseñado para **búsqueda de texto natural** sobre columnas `VARCHAR` o `TEXT`. Permite consultas del tipo `MATCH(columna) AGAINST('palabras' IN NATURAL LANGUAGE MODE)`, mucho más eficientes y relevantes que un simple `LIKE '%texto%'`."
    },
    {
      "question": "¿Cómo se verifica la integridad de una tabla en MySQL?",
      "options": [
        {
          "text": "TEST TABLE nombre",
          "isCorrect": false
        },
        {
          "text": "CHECK TABLE nombre",
          "isCorrect": true
        },
        {
          "text": "VERIFY TABLE nombre",
          "isCorrect": false
        },
        {
          "text": "VALIDATE TABLE nombre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CHECK TABLE nombre;` se usa para **verificar la integridad** y el estado interno de una tabla. Permite detectar problemas de corrupción o inconsistencias a nivel de estructura y, según el motor, puede sugerir o requerir acciones de reparación."
    },
    {
      "question": "¿Qué es un stored procedure en MySQL?",
      "options": [
        {
          "text": "Un procedimiento de backup",
          "isCorrect": false
        },
        {
          "text": "Un conjunto de sentencias SQL almacenadas que pueden ejecutarse como una unidad",
          "isCorrect": true
        },
        {
          "text": "Una función de seguridad",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **stored procedure** es un **bloque de sentencias SQL almacenadas en el servidor** que se ejecuta como una unidad con `CALL`. Encapsula lógica de negocio cerca de los datos, permite reutilizar código y puede mejorar rendimiento al reducir el tráfico entre aplicación y base."
    },
    {
      "question": "¿Qué comando crea un usuario en MySQL?",
      "options": [
        {
          "text": "ADD USER",
          "isCorrect": false
        },
        {
          "text": "CREATE USER",
          "isCorrect": true
        },
        {
          "text": "NEW USER",
          "isCorrect": false
        },
        {
          "text": "INSERT USER",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CREATE USER` sirve para **definir un nuevo usuario de MySQL**, especificando nombre y, opcionalmente, host y contraseña. Separar la creación del usuario de la asignación de permisos (`GRANT`) ayuda a tener una gestión de seguridad más clara y controlada."
    },
    {
      "question": "¿Cómo se otorgan permisos a un usuario en MySQL?",
      "options": [
        {
          "text": "GIVE PRIVILEGES",
          "isCorrect": false
        },
        {
          "text": "GRANT permisos ON base.tabla TO usuario",
          "isCorrect": true
        },
        {
          "text": "PERMIT usuario",
          "isCorrect": false
        },
        {
          "text": "ALLOW usuario",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`GRANT permisos ON base.tabla TO usuario;` asigna **privilegios específicos** (SELECT, INSERT, UPDATE, etc.) sobre una base o tabla a un usuario. Es la forma estándar de implementar el **principio de mínimo privilegio**, dando solo los accesos necesarios."
    },
    {
      "question": "¿Qué comando recarga los privilegios en MySQL?",
      "options": [
        {
          "text": "RELOAD PRIVILEGES",
          "isCorrect": false
        },
        {
          "text": "FLUSH PRIVILEGES",
          "isCorrect": true
        },
        {
          "text": "REFRESH PRIVILEGES",
          "isCorrect": false
        },
        {
          "text": "UPDATE PRIVILEGES",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`FLUSH PRIVILEGES;` indica a MySQL que **recargue las tablas de privilegios** (como `mysql.user`) en memoria. Es útil cuando se han hecho cambios manuales sobre ellas y se quiere que el servidor aplique esos cambios sin reiniciar."
    },
    {
      "question": "¿Qué es el query cache en MySQL?",
      "options": [
        {
          "text": "Un cache de consultas",
          "isCorrect": false
        },
        {
          "text": "Una caché que almacena resultados de consultas para mejorar rendimiento",
          "isCorrect": true
        },
        {
          "text": "Un archivo temporal",
          "isCorrect": false
        },
        {
          "text": "Una tabla de memoria",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **query cache** almacenaba los **resultados de consultas SELECT** para devolvérselos directamente si se repetía la misma consulta sobre los mismos datos. Esto podía mejorar el rendimiento en cargas de lectura repetitivas, aunque tenía limitaciones y complejidades que llevaron a su deprecación en versiones modernas."
    },
    {
      "question": "¿Qué herramienta gráfica es popular para administrar MySQL?",
      "options": [
        {
          "text": "pgAdmin",
          "isCorrect": false
        },
        {
          "text": "phpMyAdmin",
          "isCorrect": true
        },
        {
          "text": "MySQL Admin",
          "isCorrect": false
        },
        {
          "text": "DB Manager",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**phpMyAdmin** es una herramienta web muy popular para **administrar MySQL desde el navegador**. Permite crear bases, tablas, ejecutar consultas, hacer backups, gestionar usuarios y más, sin necesidad de usar la línea de comandos."
    },
    {
      "question": "¿Qué es un trigger en MySQL?",
      "options": [
        {
          "text": "Un disparador de eventos",
          "isCorrect": false
        },
        {
          "text": "Un procedimiento que se ejecuta automáticamente antes o después de INSERT, UPDATE o DELETE",
          "isCorrect": true
        },
        {
          "text": "Una función de seguridad",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **trigger** es un tipo de objeto que se ejecuta **automáticamente** antes o después de una operación `INSERT`, `UPDATE` o `DELETE` sobre una tabla. Se usa para validar datos, mantener auditorías, actualizar tablas derivadas u otras acciones que deben ocurrir en respuesta a cambios."
    },
    {
      "question": "¿Cómo se ven las variables del sistema en MySQL?",
      "options": [
        {
          "text": "GET VARIABLES",
          "isCorrect": false
        },
        {
          "text": "SHOW VARIABLES",
          "isCorrect": true
        },
        {
          "text": "LIST VARIABLES",
          "isCorrect": false
        },
        {
          "text": "DISPLAY VARIABLES",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`SHOW VARIABLES;` muestra las **variables de sistema y de configuración** que MySQL tiene activas (como `innodb_buffer_pool_size`, `max_connections`, etc.). Esto es clave para entender cómo está tuneado el servidor y diagnosticar problemas de rendimiento."
    },
    {
      "question": "¿Qué es el binary log en MySQL?",
      "options": [
        {
          "text": "Un registro binario",
          "isCorrect": false
        },
        {
          "text": "Un archivo que registra todas las modificaciones de datos para replicación y recuperación",
          "isCorrect": true
        },
        {
          "text": "Un archivo de configuración",
          "isCorrect": false
        },
        {
          "text": "Un log de errores",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **binary log (binlog)** es un archivo donde MySQL registra **todas las operaciones que modifican datos** (INSERT, UPDATE, DELETE, cambios de estructura). Se usa para replicación (los esclavos reproducen esas operaciones) y para recuperación punto en el tiempo después de restaurar un backup."
    },
    {
      "question": "¿Cuáles son tipos de logs en MySQL? (selección múltiple)",
      "options": [
        {
          "text": "Error log",
          "isCorrect": false
        },
        {
          "text": "General query log",
          "isCorrect": true
        },
        {
          "text": "Binary log",
          "isCorrect": true
        },
        {
          "text": "Slow query log",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Tanto el **general query log** como el **binary log** son tipos de logs importantes:\n\n* El *general query log* registra casi todas las consultas que llegan al servidor (útil para debug).\n* El *binary log* registra las modificaciones de datos para replicación y recuperación.\n\nCada uno cumple un rol distinto en administración y diagnóstico."
    },
    {
      "question": "¿Qué es el slow query log?",
      "options": [
        {
          "text": "Un log lento",
          "isCorrect": false
        },
        {
          "text": "Registra consultas que tardan más de un tiempo específico",
          "isCorrect": true
        },
        {
          "text": "Un archivo de errores",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **slow query log** guarda las **consultas que tardan más de un umbral configurado**. Es una herramienta fundamental para detectar qué queries son candidatas a optimización (índices, reescritura, cambios de diseño, etc.)."
    },
    {
      "question": "¿Qué es EXPLAIN en MySQL?",
      "options": [
        {
          "text": "Una explicación",
          "isCorrect": false
        },
        {
          "text": "Muestra el plan de ejecución y uso de índices",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de JOIN",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`EXPLAIN` (o `EXPLAIN ANALYZE` en versiones más nuevas) muestra el **plan de ejecución** que MySQL planea usar para una consulta: qué índices utilizará, cómo hará los joins, cuántas filas estima leer, etc. Leer bien `EXPLAIN` es clave para optimizar SQL."
    },
    {
      "question": "¿Qué es el query optimizer en MySQL?",
      "options": [
        {
          "text": "Un optimizador",
          "isCorrect": false
        },
        {
          "text": "Componente que determina la mejor manera de ejecutar consultas",
          "isCorrect": true
        },
        {
          "text": "Una herramienta externa",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **query optimizer** es el componente del motor que decide **la mejor estrategia para ejecutar una consulta**, dada la estructura de las tablas, los índices y las estadísticas. El mismo SQL se puede ejecutar de formas muy diferentes, y el optimizador busca el plan más eficiente."
    },
    {
      "question": "¿Cuáles son motores de almacenamiento en MySQL? (selección múltiple)",
      "options": [
        {
          "text": "InnoDB",
          "isCorrect": false
        },
        {
          "text": "MyISAM",
          "isCorrect": true
        },
        {
          "text": "Memory (HEAP)",
          "isCorrect": true
        },
        {
          "text": "Archive",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "MySQL soporta varios **motores de almacenamiento**; entre ellos:\n\n* **MyISAM**, antiguo motor por defecto, rápido en lecturas pero sin transacciones ni FK.\n* **Memory (HEAP)**, que almacena datos en memoria RAM para acceso muy rápido (pero volátil).\n\nElegir el motor adecuado depende del caso de uso y requisitos de integridad/rendimiento."
    },
    {
      "question": "¿Diferencia principal entre InnoDB y MyISAM?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "InnoDB soporta transacciones y FK, MyISAM no",
          "isCorrect": true
        },
        {
          "text": "MyISAM es más moderno",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia clave es que **InnoDB** soporta **transacciones ACID y claves foráneas**, mientras que **MyISAM** no. MyISAM suele ser más simple y rápido para lecturas sin muchas escrituras, pero InnoDB es el estándar actual cuando se necesita integridad y concurrencia segura."
    },
    {
      "question": "¿Qué es el buffer pool en InnoDB?",
      "options": [
        {
          "text": "Una piscina",
          "isCorrect": false
        },
        {
          "text": "Área de memoria que cachea datos y índices",
          "isCorrect": true
        },
        {
          "text": "Un archivo temporal",
          "isCorrect": false
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **buffer pool** de InnoDB es un área de memoria donde se **cachean páginas de datos e índices**. Cuanto más grande (hasta un límite razonable del servidor), más operaciones se pueden resolver desde memoria en lugar de disco, mejorando mucho el rendimiento."
    },
    {
      "question": "¿Qué son las foreign keys en InnoDB?",
      "options": [
        {
          "text": "Llaves foráneas",
          "isCorrect": false
        },
        {
          "text": "Constraints que mantienen integridad referencial",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las **foreign keys** (claves foráneas) en InnoDB son **constraints que vinculan filas de tablas distintas** (por ejemplo, `orders.customer_id` → `customers.id`). Garantizan integridad referencial: no podés tener referencias a filas que no existen, y podés definir qué pasa cuando se borra o actualiza el registro padre."
    },
    {
      "question": "¿Qué es ON DELETE CASCADE?",
      "options": [
        {
          "text": "Una cascada",
          "isCorrect": false
        },
        {
          "text": "Elimina automáticamente filas relacionadas cuando se elimina el padre",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ON DELETE CASCADE` indica que, si se elimina la fila **padre**, MySQL eliminará **automáticamente todas las filas hijas** relacionadas. Esto es útil para mantener las tablas limpias de registros huérfanos sin tener que borrar manualmente en la aplicación."
    },
    {
      "question": "¿Cuáles son opciones de ON DELETE? (selección múltiple)",
      "options": [
        {
          "text": "CASCADE",
          "isCorrect": false
        },
        {
          "text": "SET NULL",
          "isCorrect": true
        },
        {
          "text": "RESTRICT",
          "isCorrect": true
        },
        {
          "text": "NO ACTION",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Opciones como **`SET NULL`** y **`RESTRICT`** controlan qué sucede cuando se borra o actualiza el registro referenciado:\n\n* `SET NULL`: pone el campo foráneo en `NULL` para \"desvincular\" el hijo.\n* `RESTRICT`: impide la eliminación/actualización si hay registros hijos.\n\nEstas reglas ayudan a modelar distintas políticas de integridad."
    },
    {
      "question": "¿Qué es AUTO_INCREMENT?",
      "options": [
        {
          "text": "Incremento automático",
          "isCorrect": false
        },
        {
          "text": "Genera valores secuenciales automáticamente",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**`AUTO_INCREMENT`** hace que la columna genere **valores numéricos secuenciales** automáticamente. Esto simplifica la creación de claves primarias únicas, especialmente cuando muchas filas se insertan concurrentemente."
    },
    {
      "question": "¿Cómo se reinicia AUTO_INCREMENT?",
      "options": [
        {
          "text": "RESET AUTO_INCREMENT",
          "isCorrect": false
        },
        {
          "text": "ALTER TABLE tabla AUTO_INCREMENT = 1",
          "isCorrect": true
        },
        {
          "text": "No se puede reiniciar",
          "isCorrect": false
        },
        {
          "text": "TRUNCATE lo reinicia automáticamente",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ALTER TABLE tabla AUTO_INCREMENT = 1;` permite **reiniciar el contador** de `AUTO_INCREMENT` a un valor específico. Es útil, por ejemplo, tras borrar muchos registros y querer que los próximos IDs arranquen desde un número más bajo (respetando que no existan filas con ese ID)."
    },
    {
      "question": "¿Qué es ENUM en MySQL?",
      "options": [
        {
          "text": "Una enumeración",
          "isCorrect": false
        },
        {
          "text": "Un tipo de dato con valores predefinidos",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**`ENUM`** define una columna que solo puede tomar **uno de varios valores predefinidos** (por ejemplo, `'activo', 'inactivo', 'pendiente'`). Esto limita el dominio de valores posibles y puede simplificar validaciones, aunque también acopla la lista al esquema."
    },
    {
      "question": "¿Qué es SET en MySQL (tipo de dato)?",
      "options": [
        {
          "text": "Un conjunto",
          "isCorrect": false
        },
        {
          "text": "Permite almacenar múltiples valores de una lista predefinida",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El tipo **`SET`** permite almacenar **cero o más valores** de una lista predefinida en una sola columna, como si fuera un conjunto de flags. Es útil cuando un registro puede tener múltiples opciones simultáneamente (por ejemplo, \"roles\" simples), aunque para modelos complejos se prefiere normalizar."
    },
    {
      "question": "¿Diferencia entre CHAR y VARCHAR?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "CHAR es longitud fija, VARCHAR variable",
          "isCorrect": true
        },
        {
          "text": "VARCHAR es más lento",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CHAR` y `VARCHAR` almacenan texto, pero:\n\n* **`CHAR(n)`** es de **longitud fija**: se rellena con espacios y es eficiente para datos siempre del mismo tamaño (ej. códigos).\n* **`VARCHAR(n)`** es de **longitud variable**, ideal cuando las longitudes cambian mucho y querés ahorrar espacio."
    },
    {
      "question": "¿Cuándo usar CHAR vs VARCHAR?",
      "options": [
        {
          "text": "Siempre VARCHAR",
          "isCorrect": false
        },
        {
          "text": "CHAR para datos de longitud fija, VARCHAR para variable",
          "isCorrect": true
        },
        {
          "text": "Siempre CHAR",
          "isCorrect": false
        },
        {
          "text": "Da igual",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Usás **`CHAR`** cuando el dato tiene **tamaño constante** (códigos de país, hashes de longitud fija, etc.), lo que puede ser más eficiente y predecible. Usás **`VARCHAR`** cuando la longitud varía (nombres, descripciones cortas) para no desperdiciar espacio de almacenamiento."
    },
    {
      "question": "¿Qué es TEXT en MySQL?",
      "options": [
        {
          "text": "Texto",
          "isCorrect": false
        },
        {
          "text": "Tipo para strings largos",
          "isCorrect": true
        },
        {
          "text": "Igual que VARCHAR",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El tipo **`TEXT`** sirve para **cadenas largas**, como comentarios extensos, descripciones, contenido de artículos, etc. A diferencia de `VARCHAR`, está pensado para textos mucho más grandes y se almacena de forma algo diferente internamente."
    },
    {
      "question": "¿Cuáles son tipos TEXT en MySQL? (selección múltiple)",
      "options": [
        {
          "text": "TINYTEXT",
          "isCorrect": false
        },
        {
          "text": "TEXT",
          "isCorrect": true
        },
        {
          "text": "MEDIUMTEXT",
          "isCorrect": true
        },
        {
          "text": "LONGTEXT",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "MySQL ofrece varios tamaños de `TEXT`, como **`TEXT`** y **`MEDIUMTEXT`**, que se diferencian por la **cantidad máxima de caracteres** que pueden almacenar. Elegir el tipo correcto ayuda a balancear espacio de almacenamiento y necesidades reales de longitud."
    },
    {
      "question": "¿Qué es BLOB en MySQL?",
      "options": [
        {
          "text": "Un blob",
          "isCorrect": false
        },
        {
          "text": "Binary Large Object para datos binarios",
          "isCorrect": true
        },
        {
          "text": "Un tipo de texto",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **`BLOB` (Binary Large Object)** se usa para almacenar **datos binarios**: imágenes, archivos, contenido cifrado, etc. A diferencia de `TEXT`, no se asume codificación de caracteres, sino bytes \"crudos\", tal como los recibe la aplicación."
    },
    {
      "question": "¿Qué es JSON en MySQL?",
      "options": [
        {
          "text": "Un archivo JSON",
          "isCorrect": false
        },
        {
          "text": "Un tipo de dato nativo para documentos JSON",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El tipo **`JSON`** en MySQL permite guardar **documentos JSON de forma nativa**, con validación de formato y funciones para manipularlos (`JSON_SET`, `JSON_EXTRACT`, etc.). Es útil para datos semi–estructurados dentro de un modelo principalmente relacional."
    },
    {
      "question": "¿Qué funciones JSON existen en MySQL? (selección múltiple)",
      "options": [
        {
          "text": "JSON_EXTRACT",
          "isCorrect": false
        },
        {
          "text": "JSON_SET",
          "isCorrect": true
        },
        {
          "text": "JSON_ARRAY",
          "isCorrect": true
        },
        {
          "text": "JSON_OBJECT",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Funciones como **`JSON_SET`** y **`JSON_ARRAY`** son utilidades para **crear y modificar valores JSON** dentro de MySQL:\n\n* `JSON_ARRAY` construye un array JSON.\n* `JSON_SET` permite actualizar o agregar claves dentro de un documento JSON existente.\n\nEsto permite operar sobre JSON sin tener que traerlo y procesarlo en la aplicación."
    },
    {
      "question": "¿Qué es una partición en MySQL?",
      "options": [
        {
          "text": "Una división",
          "isCorrect": false
        },
        {
          "text": "División de una tabla en partes más pequeñas",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **partición** de una tabla es una técnica donde MySQL **divide físicamente la tabla en varias partes**, pero la sigue presentando lógicamente como una sola. Esto puede mejorar rendimiento y manejo de datos grandes (por ejemplo, por rango de fechas)."
    },
    {
      "question": "¿Cuáles son tipos de particionamiento? (selección múltiple)",
      "options": [
        {
          "text": "RANGE",
          "isCorrect": false
        },
        {
          "text": "LIST",
          "isCorrect": true
        },
        {
          "text": "HASH",
          "isCorrect": true
        },
        {
          "text": "KEY",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Entre los esquemas de particionamiento están:\n\n* **`LIST`**, que asigna filas a particiones según valores concretos de una columna.\n* **`HASH`**, que reparte filas automáticamente usando una función hash.\n\nCada estrategia sirve para distintos patrones de acceso y distribución de datos."
    },
    {
      "question": "¿Qué es replicación en MySQL?",
      "options": [
        {
          "text": "Una copia",
          "isCorrect": false
        },
        {
          "text": "Proceso de copiar datos de un servidor maestro a esclavos",
          "isCorrect": true
        },
        {
          "text": "Un backup",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **replicación** en MySQL es el proceso en el que un **servidor maestro envía sus cambios a uno o más esclavos** (réplicas). Esto permite escalado de lecturas, alta disponibilidad y backups más seguros, ya que hay copias adicionales de los datos."
    },
    {
      "question": "¿Cuáles son tipos de replicación? (selección múltiple)",
      "options": [
        {
          "text": "Asíncrona",
          "isCorrect": false
        },
        {
          "text": "Semi-síncrona",
          "isCorrect": true
        },
        {
          "text": "Group Replication",
          "isCorrect": true
        },
        {
          "text": "Síncrona pura",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Tipos de replicación como la **semi-síncrona** y la **Group Replication** agregan diferentes niveles de **consistencia y tolerancia a fallos**:\n\n* Semi-síncrona: el maestro espera confirmación de al menos una réplica.\n* Group Replication: ofrece un grupo de nodos con consenso y conmutación automática."
    },
    {
      "question": "¿Qué es un master-slave setup?",
      "options": [
        {
          "text": "Una configuración",
          "isCorrect": false
        },
        {
          "text": "Arquitectura con un servidor maestro y réplicas esclavas",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un entorno **master-slave** (maestro–esclavo) tiene un servidor **maestro que recibe las escrituras** y uno o varios **esclavos que replican esos cambios**. Las lecturas pueden distribuirse a las réplicas para aliviar la carga del maestro."
    },
    {
      "question": "¿Qué es MySQL Cluster?",
      "options": [
        {
          "text": "Un grupo",
          "isCorrect": false
        },
        {
          "text": "Solución de alta disponibilidad con replicación síncrona",
          "isCorrect": true
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**MySQL Cluster** es una solución que combina MySQL con un motor distribuido y **replicación síncrona**, orientado a alta disponibilidad y tolerancia a fallos. La idea es que la base siga disponible incluso si caen algunos nodos del cluster."
    },
    {
      "question": "¿Qué es el file-per-table en InnoDB?",
      "options": [
        {
          "text": "Un archivo por tabla",
          "isCorrect": false
        },
        {
          "text": "Configuración donde cada tabla tiene su propio archivo",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Con la opción **file-per-table**, InnoDB almacena cada tabla en **su propio archivo de datos** en lugar de un gran tablespace compartido. Esto facilita tareas como mover tablas, liberar espacio cuando se borran y aislar problemas de almacenamiento."
    },
    {
      "question": "¿Qué es el tablespace en InnoDB?",
      "options": [
        {
          "text": "Un espacio de tabla",
          "isCorrect": false
        },
        {
          "text": "Contenedor de almacenamiento para tablas y índices",
          "isCorrect": true
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **tablespace** en InnoDB es un **contenedor lógico de almacenamiento** donde residen las páginas de datos e índices. Podés tener un tablespace global compartido o múltiples tablespaces por tabla, según la configuración (`file-per-table`, tablespaces generales, etc.)."
    },
    {
      "question": "¿Qué es INFORMATION_SCHEMA?",
      "options": [
        {
          "text": "Un esquema de información",
          "isCorrect": false
        },
        {
          "text": "Base de datos con metadatos sobre el servidor MySQL",
          "isCorrect": true
        },
        {
          "text": "Una tabla normal",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La base **`INFORMATION_SCHEMA`** expone **metadatos del servidor**: qué tablas existen, columnas, índices, permisos, caracteres, etc. No almacena datos de negocio, sino información sobre la estructura y configuración de la base de datos."
    },
    {
      "question": "¿Qué es PERFORMANCE_SCHEMA?",
      "options": [
        {
          "text": "Un esquema de rendimiento",
          "isCorrect": false
        },
        {
          "text": "Base de datos para monitorear rendimiento del servidor",
          "isCorrect": true
        },
        {
          "text": "Una tabla normal",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**`PERFORMANCE_SCHEMA`** es una base especial que recopila **métricas detalladas de rendimiento**: tiempos de ejecución, esperas de locks, uso de I/O, etc. Es muy útil para tunear el servidor y encontrar cuellos de botella sin depender solo de logs externos."
    },
    {
      "question": "¿Qué es el thread pool en MySQL?",
      "options": [
        {
          "text": "Una piscina de hilos",
          "isCorrect": false
        },
        {
          "text": "Gestión eficiente de conexiones con threads reutilizables",
          "isCorrect": true
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **thread pool** es un mecanismo para **gestionar conexiones reutilizando threads**, en lugar de crear uno por conexión. Esto reduce el overhead de creación de threads y mejora la escalabilidad cuando hay muchas conexiones simultáneas."
    },
    {
      "question": "¿Qué son las vistas materializadas en MySQL?",
      "options": [
        {
          "text": "Vistas especiales",
          "isCorrect": false
        },
        {
          "text": "No existen nativamente en MySQL, requieren workarounds",
          "isCorrect": true
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "MySQL **no soporta vistas materializadas nativas**, por lo que si las necesitás debes simularlas con tablas físicas que se actualizan mediante procedimientos, triggers o eventos. La idea es guardar resultados precalculados para acelerar ciertas consultas pesadas."
    },
    {
      "question": "¿Qué es el Event Scheduler en MySQL?",
      "options": [
        {
          "text": "Un programador",
          "isCorrect": false
        },
        {
          "text": "Ejecuta tareas programadas automáticamente",
          "isCorrect": true
        },
        {
          "text": "Un tipo de trigger",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **Event Scheduler** permite definir **tareas programadas** que se ejecutan dentro del propio servidor MySQL (parecido a un cron interno). Podés usarlo para limpiezas periódicas, agregados, rotaciones de datos, etc., sin depender de scripts externos."
    },
    {
      "question": "¿Cómo se crea un evento programado?",
      "options": [
        {
          "text": "CREATE SCHEDULE",
          "isCorrect": false
        },
        {
          "text": "CREATE EVENT",
          "isCorrect": true
        },
        {
          "text": "NEW EVENT",
          "isCorrect": false
        },
        {
          "text": "SCHEDULE EVENT",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CREATE EVENT` se usa para **definir un evento programado**, indicando cuándo y con qué frecuencia se ejecuta, y qué sentencia SQL corre. Es una forma de automatizar tareas repetitivas directamente en la base de datos."
    },
    {
      "question": "¿Qué es LOAD DATA INFILE?",
      "options": [
        {
          "text": "Cargar datos",
          "isCorrect": false
        },
        {
          "text": "Importa datos masivamente desde un archivo",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de backup",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`LOAD DATA INFILE` es una de las formas más rápidas de **importar datos masivamente desde un archivo de texto** (por ejemplo CSV) a una tabla. Permite definir separadores, comillas, salto de líneas, etc., y es ideal para cargas iniciales o integraciones batch."
    },
    {
      "question": "¿Qué es mysqldump?",
      "options": [
        {
          "text": "Un dump",
          "isCorrect": false
        },
        {
          "text": "Herramienta para exportar bases de datos",
          "isCorrect": true
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`mysqldump` es una herramienta de línea de comandos que **exporta bases de datos a un archivo de texto con sentencias SQL** (`CREATE TABLE`, `INSERT`, etc.). Ese archivo luego se puede usar para restaurar la base o migrarla a otro servidor."
    },
    {
      "question": "¿Cuáles son opciones comunes de mysqldump? (selección múltiple)",
      "options": [
        {
          "text": "--all-databases",
          "isCorrect": false
        },
        {
          "text": "--single-transaction",
          "isCorrect": true
        },
        {
          "text": "--no-data",
          "isCorrect": true
        },
        {
          "text": "--routines",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Opciones como **`--single-transaction`** y **`--no-data`** modifican el comportamiento de `mysqldump`:\n\n* `--single-transaction`: hace un dump consistente usando una transacción, sin bloquear las tablas mucho tiempo.\n* `--no-data`: exporta solo la estructura (DDL) sin filas, útil para clonar esquemas."
    },
    {
      "question": "¿Qué es mysqlimport?",
      "options": [
        {
          "text": "Una importación",
          "isCorrect": false
        },
        {
          "text": "Herramienta para importar archivos de datos",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`mysqlimport` es una herramienta complementaria que **importa archivos de datos** (por ejemplo generados por `SELECT ... INTO OUTFILE` o formatos CSV) directamente en tablas. Internamente usa `LOAD DATA INFILE`, pero ofrece una interfaz más conveniente desde CLI."
    },
    {
      "question": "¿Qué es REPAIR TABLE?",
      "options": [
        {
          "text": "Reparar tabla",
          "isCorrect": false
        },
        {
          "text": "Intenta reparar una tabla corrupta",
          "isCorrect": true
        },
        {
          "text": "Una función de optimización",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`REPAIR TABLE` intenta **reparar estructuras corruptas** de ciertas tablas (especialmente MyISAM). Se usa cuando se detectan errores de integridad física en la tabla, aunque en motores modernos como InnoDB se prefieren otros mecanismos de recuperación."
    },
    {
      "question": "¿Qué es ANALYZE TABLE?",
      "options": [
        {
          "text": "Analizar tabla",
          "isCorrect": false
        },
        {
          "text": "Actualiza estadísticas de distribución de datos",
          "isCorrect": true
        },
        {
          "text": "Una función de búsqueda",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ANALYZE TABLE` **actualiza las estadísticas** de distribución de datos que usa el optimizador de consultas. Tener estadísticas precisas ayuda a que el optimizador elija mejores planes de ejecución (por ejemplo, decidir qué índice usar y en qué orden hacer joins)."
    },
    {
      "question": "¿Qué es el query cache en MySQL?",
      "options": [
        {
          "text": "Una caché",
          "isCorrect": false
        },
        {
          "text": "Caché de resultados de consultas (deprecated en 8.0)",
          "isCorrect": true
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **query cache** almacenaba resultados de consultas SELECT para reutilizarlos, pero en MySQL 8.0 fue **deprecado y eliminado** porque generaba problemas de contención y escalabilidad. La respuesta aclara esto: existía como caché de resultados, pero ya no se recomienda ni está disponible en versiones recientes."
    },
    {
      "question": "¿Por qué se deprecó el query cache?",
      "options": [
        {
          "text": "Era muy lento",
          "isCorrect": false
        },
        {
          "text": "Problemas de escalabilidad y contención",
          "isCorrect": true
        },
        {
          "text": "No funcionaba",
          "isCorrect": false
        },
        {
          "text": "Era muy complejo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Se deprecó el query cache porque, en entornos con muchas escrituras, **invalidar continuamente la caché** y manejar los locks internos generaba **cuellos de botella**. En lugar de eso, hoy se prefiere caché a nivel de aplicación, proxies o soluciones externas como Redis."
    },
    {
      "question": "¿Qué es innodb_buffer_pool_size?",
      "options": [
        {
          "text": "Un tamaño",
          "isCorrect": false
        },
        {
          "text": "Parámetro crucial que define memoria para caché de InnoDB",
          "isCorrect": true
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`innodb_buffer_pool_size` es uno de los parámetros más importantes de MySQL: define **cuánta memoria se reserva para el buffer pool de InnoDB**. Un valor adecuado (grande pero no excesivo) permite que la mayoría de accesos a datos/índices ocurran en memoria, mejorando el rendimiento."
    },
    {
      "question": "¿Qué es max_connections?",
      "options": [
        {
          "text": "Conexiones máximas",
          "isCorrect": false
        },
        {
          "text": "Número máximo de conexiones simultáneas",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`max_connections` define el **número máximo de conexiones simultáneas** que el servidor MySQL aceptará. Si se alcanza este límite, nuevas conexiones serán rechazadas, por lo que hay que dimensionarlo según la carga esperada y los recursos de la máquina."
    },
    {
      "question": "¿Qué es wait_timeout?",
      "options": [
        {
          "text": "Tiempo de espera",
          "isCorrect": false
        },
        {
          "text": "Segundos que el servidor espera antes de cerrar conexión inactiva",
          "isCorrect": true
        },
        {
          "text": "Un tipo de delay",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`wait_timeout` indica cuántos **segundos una conexión inactiva** puede permanecer abierta antes de que el servidor la cierre. Un valor muy alto puede dejar muchas conexiones \"muertas\" consumiendo recursos; uno muy bajo puede cerrar conexiones legítimas si la aplicación no las usa frecuentemente."
    },
    {
      "question": "¿Qué herramientas gráficas existen para MySQL? (selección múltiple)",
      "options": [
        {
          "text": "phpMyAdmin",
          "isCorrect": false
        },
        {
          "text": "MySQL Workbench",
          "isCorrect": true
        },
        {
          "text": "Adminer",
          "isCorrect": true
        },
        {
          "text": "DBeaver",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Herramientas gráficas como **MySQL Workbench** y **Adminer** permiten **administrar MySQL con interfaz visual**: ejecutar consultas, diseñar esquemas, ver estadísticas y gestionar usuarios. Son muy útiles tanto para desarrollo como para operaciones."
    },
    {
      "question": "¿Qué es MySQL Workbench?",
      "options": [
        {
          "text": "Un banco de trabajo",
          "isCorrect": false
        },
        {
          "text": "Herramienta oficial de administración y diseño de MySQL",
          "isCorrect": true
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**MySQL Workbench** es la **herramienta oficial** de MySQL para diseño y administración. Incluye modelado de bases (diagramas ER), ejecución de consultas, migraciones, monitoreo y otras funciones que centralizan las tareas típicas de DBA."
    },
    {
      "question": "¿Qué es pt-query-digest?",
      "options": [
        {
          "text": "Un digest",
          "isCorrect": false
        },
        {
          "text": "Herramienta de Percona para analizar logs de consultas",
          "isCorrect": true
        },
        {
          "text": "Una función MySQL",
          "isCorrect": false
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**pt-query-digest** es una herramienta de Percona que analiza **logs de consultas** (slow log, general log, tcpdump, etc.) para identificar las queries más costosas. Agrupa, ordena y resume las consultas para ayudar a priorizar la optimización."
    },
    {
      "question": "¿Qué es ProxySQL?",
      "options": [
        {
          "text": "Un proxy",
          "isCorrect": false
        },
        {
          "text": "Proxy de alto rendimiento para MySQL con load balancing",
          "isCorrect": true
        },
        {
          "text": "Un tipo de replicación",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**ProxySQL** es un **proxy de alto rendimiento** específico para MySQL que ofrece **balanceo de carga, routing avanzado, caché, filtrado de queries**, y más. Se coloca entre la aplicación y el cluster MySQL para gestionar mejor la distribución del tráfico."
    },
    {
      "question": "¿Qué es Percona Server?",
      "options": [
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Fork mejorado de MySQL con características adicionales",
          "isCorrect": true
        },
        {
          "text": "Un cliente",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Percona Server** es un **fork de MySQL** con mejoras de rendimiento, diagnósticos y herramientas adicionales. Mantiene compatibilidad con MySQL, pero añade funcionalidades avanzadas muy valoradas en entornos de alta carga."
    },
    {
      "question": "¿Qué es MariaDB?",
      "options": [
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Fork de MySQL con compatibilidad y mejoras",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**MariaDB** es otro **fork de MySQL**, creado por los desarrolladores originales, que mantiene alta compatibilidad a nivel de protocolo y SQL, pero incorpora motores de almacenamiento y características adicionales. Además, su desarrollo es más abierto y comunitario."
    },
    {
      "question": "¿Diferencias entre MySQL y MariaDB? (selección múltiple)",
      "options": [
        {
          "text": "MariaDB tiene más motores de almacenamiento",
          "isCorrect": false
        },
        {
          "text": "Algunas características adicionales",
          "isCorrect": true
        },
        {
          "text": "Desarrollo más abierto",
          "isCorrect": true
        },
        {
          "text": "Son totalmente incompatibles",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Las diferencias entre MySQL y MariaDB incluyen **características extra en MariaDB** (nuevos motores, funciones, optimizaciones) y un **modelo de desarrollo más abierto**. Aun así, en muchos casos las aplicaciones pueden conectarse a uno u otro con cambios mínimos."
    },
    {
      "question": "¿Qué es el adaptive hash index en InnoDB?",
      "options": [
        {
          "text": "Un índice adaptativo",
          "isCorrect": false
        },
        {
          "text": "Índice hash automático en memoria para acceso frecuente",
          "isCorrect": true
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **adaptive hash index** es una optimización de InnoDB que **construye automáticamente índices hash en memoria** para accesos frecuentes, basándose en el uso de los índices B-Tree. Esto acelera ciertos patrones de lectura repetitiva sin que el DBA tenga que definir nada extra."
    },
    {
      "question": "¿Qué es change buffer en InnoDB?",
      "options": [
        {
          "text": "Un buffer de cambios",
          "isCorrect": false
        },
        {
          "text": "Caché para operaciones de índices secundarios",
          "isCorrect": true
        },
        {
          "text": "Un tipo de tabla",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **change buffer** de InnoDB es una **caché para operaciones sobre índices secundarios** cuando las páginas afectadas aún no están en memoria. En lugar de leerlas inmediatamente de disco, acumula los cambios y los aplica más tarde, reduciendo I/O aleatorio."
    },
    {
      "question": "¿Qué es doublewrite buffer?",
      "options": [
        {
          "text": "Doble escritura",
          "isCorrect": false
        },
        {
          "text": "Protección contra páginas parcialmente escritas",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **doublewrite buffer** protege contra **páginas parcialmente escritas** en caso de caída del sistema. Antes de escribir una página al tablespace definitivo, InnoDB la escribe en este buffer; así, si ocurre un fallo en medio de la escritura, aún hay una copia consistente para recuperarse."
    },
    {
      "question": "¿Qué son los redo logs en InnoDB?",
      "options": [
        {
          "text": "Logs de rehacer",
          "isCorrect": false
        },
        {
          "text": "Logs para recuperación de transacciones",
          "isCorrect": true
        },
        {
          "text": "Logs de errores",
          "isCorrect": false
        },
        {
          "text": "Logs de consultas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los **redo logs** registran las **operaciones de modificación** que realizan las transacciones. En caso de caída, InnoDB los usa para **reaplicar cambios pendientes** y garantizar que todas las transacciones comprometidas (COMMIT) se reflejen correctamente en los datos."
    },
    {
      "question": "¿Qué son los undo logs en InnoDB?",
      "options": [
        {
          "text": "Logs de deshacer",
          "isCorrect": false
        },
        {
          "text": "Logs para revertir transacciones y MVCC",
          "isCorrect": true
        },
        {
          "text": "Logs de errores",
          "isCorrect": false
        },
        {
          "text": "Logs de respaldo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los **undo logs** guardan la información necesaria para **revertir cambios** de una transacción si se hace `ROLLBACK`. Además, permiten implementar **MVCC (Multi-Version Concurrency Control)**, de modo que las lecturas puedan ver versiones consistentes de las filas mientras otras transacciones las modifican."
    }
  ],
  "mongodb": [
    {
      "question": "¿Qué es MongoDB?",
      "options": [
        {
          "text": "Una base de datos relacional",
          "isCorrect": false
        },
        {
          "text": "Una base de datos NoSQL orientada a documentos",
          "isCorrect": true
        },
        {
          "text": "Un lenguaje de programación",
          "isCorrect": false
        },
        {
          "text": "Un framework web",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "MongoDB es una base de datos NoSQL **orientada a documentos**, donde cada registro es un documento similar a JSON. Esto permite esquemas flexibles (sin columnas fijas como en SQL) y facilita evolucionar la estructura de datos sin migraciones complejas."
    },
    {
      "question": "¿En qué formato almacena MongoDB los documentos?",
      "options": [
        {
          "text": "XML",
          "isCorrect": false
        },
        {
          "text": "BSON (Binary JSON)",
          "isCorrect": true
        },
        {
          "text": "CSV",
          "isCorrect": false
        },
        {
          "text": "TXT",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Internamente MongoDB almacena los documentos en **BSON (Binary JSON)**, un formato binario inspirado en JSON. BSON soporta más tipos de datos (como `Date`, `ObjectId`, binarios, etc.) y es más eficiente para almacenamiento y transporte que texto plano JSON."
    },
    {
      "question": "¿Qué es una colección en MongoDB?",
      "options": [
        {
          "text": "Un array de datos",
          "isCorrect": false
        },
        {
          "text": "Un grupo de documentos, equivalente a una tabla en SQL",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función de agregación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una **colección** es un grupo de documentos, parecido a una tabla en SQL pero **sin esquema rígido**. En la misma colección podés tener documentos con distintos campos, lo que da mucha flexibilidad para iterar sobre el modelo de datos."
    },
    {
      "question": "¿Qué es un documento en MongoDB?",
      "options": [
        {
          "text": "Un archivo de texto",
          "isCorrect": false
        },
        {
          "text": "Una estructura de datos similar a JSON con pares clave-valor",
          "isCorrect": true
        },
        {
          "text": "Una tabla",
          "isCorrect": false
        },
        {
          "text": "Una fila",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **documento** es la unidad básica de datos en MongoDB: una estructura similar a JSON con pares clave–valor. Puede incluir tipos simples, arrays y documentos embebidos, lo que permite representar estructuras complejas en un solo registro."
    },
    {
      "question": "¿Qué comando inserta un documento en MongoDB?",
      "options": [
        {
          "text": "db.coleccion.add()",
          "isCorrect": false
        },
        {
          "text": "db.coleccion.insertOne() o insertMany()",
          "isCorrect": true
        },
        {
          "text": "db.coleccion.create()",
          "isCorrect": false
        },
        {
          "text": "db.coleccion.new()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`db.coleccion.insertOne()` inserta **un solo documento**, mientras que `insertMany()` inserta **varios documentos de una vez**. Ambos reciben objetos (o arrays de objetos) en formato similar a JSON y devuelven información sobre la operación (IDs, estado, etc.)."
    },
    {
      "question": "¿Qué comando busca documentos en MongoDB?",
      "options": [
        {
          "text": "db.coleccion.search()",
          "isCorrect": false
        },
        {
          "text": "db.coleccion.find()",
          "isCorrect": true
        },
        {
          "text": "db.coleccion.query()",
          "isCorrect": false
        },
        {
          "text": "db.coleccion.select()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`db.coleccion.find()` se usa para **consultar documentos** de una colección. Acepta un filtro (query) en forma de objeto, y opcionalmente una proyección para indicar qué campos devolver, muy similar a un `SELECT ... WHERE` en SQL."
    },
    {
      "question": "¿Qué comando actualiza documentos en MongoDB?",
      "options": [
        {
          "text": "db.collection.updateOne()",
          "isCorrect": true
        },
        {
          "text": "update",
          "isCorrect": false
        },
        {
          "text": "db.collection.modify()",
          "isCorrect": false
        },
        {
          "text": "db.collection.change()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`db.coleccion.updateOne()` actualiza **el primer documento que cumple el filtro**, mientras que `updateMany()` actualiza **todos los que coinciden**. Se combinan con operadores como `$set`, `$inc`, etc., para modificar solo los campos necesarios."
    },
    {
      "question": "¿Qué comando elimina documentos en MongoDB?",
      "options": [
        {
          "text": "db.coleccion.remove()",
          "isCorrect": false
        },
        {
          "text": "db.coleccion.deleteOne() o deleteMany()",
          "isCorrect": true
        },
        {
          "text": "db.coleccion.erase()",
          "isCorrect": false
        },
        {
          "text": "Tanto a como b son correctos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`db.coleccion.deleteOne()` elimina **un solo documento** que cumpla la condición, y `deleteMany()` elimina **todos los documentos** que cumplan con el filtro. Es importante usar filtros precisos para evitar borrar más datos de los deseados."
    },
    {
      "question": "¿Qué es el _id en MongoDB?",
      "options": [
        {
          "text": "Un identificador de usuario",
          "isCorrect": false
        },
        {
          "text": "Un campo único generado automáticamente para cada documento",
          "isCorrect": true
        },
        {
          "text": "Una contraseña",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El campo `_id` es la **clave primaria** de cada documento y es único dentro de la colección. Si no lo especificás al insertar, MongoDB genera automáticamente un `ObjectId`, que sirve para identificar y buscar el documento de forma eficiente."
    },
    {
      "question": "¿Qué es un índice en MongoDB?",
      "options": [
        {
          "text": "Una lista de contenidos",
          "isCorrect": false
        },
        {
          "text": "Una estructura que mejora el rendimiento de las consultas",
          "isCorrect": true
        },
        {
          "text": "Un tipo de colección",
          "isCorrect": false
        },
        {
          "text": "Una función de seguridad",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **índice** es una estructura adicional que MongoDB mantiene para **acelerar las consultas** sobre uno o varios campos. A cambio de algo más de espacio en disco y costo en escrituras, las búsquedas y ordenamientos sobre esos campos se vuelven mucho más rápidas."
    },
    {
      "question": "¿Qué comando crea un índice en MongoDB?",
      "options": [
        {
          "text": "db.coleccion.newIndex()",
          "isCorrect": false
        },
        {
          "text": "db.coleccion.createIndex()",
          "isCorrect": true
        },
        {
          "text": "db.coleccion.addIndex()",
          "isCorrect": false
        },
        {
          "text": "db.coleccion.makeIndex()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`db.coleccion.createIndex()` crea un índice sobre uno o más campos, por ejemplo:\n`db.users.createIndex({ email: 1 })`.\n\nEl `1` indica orden ascendente (también existe `-1` para descendente); después de crearlo, las consultas que filtren u ordenen por ese campo se aceleran."
    },
    {
      "question": "¿Qué es el aggregation pipeline en MongoDB?",
      "options": [
        {
          "text": "db.collection.aggregate([...])",
          "isCorrect": true
        },
        {
          "text": "pipeline()",
          "isCorrect": false
        },
        {
          "text": "db.collection.pipeline()",
          "isCorrect": false
        },
        {
          "text": "db.aggregate()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **aggregation pipeline** es un framework donde los documentos pasan por **etapas encadenadas** (`$match`, `$group`, `$project`, etc.) para transformarse. Permite hacer reportes, estadísticas, joins simples y transformaciones complejas directamente en la base."
    },
    {
      "question": "¿Qué operador se usa en aggregation para filtrar documentos?",
      "options": [
        {
          "text": "$filter",
          "isCorrect": false
        },
        {
          "text": "$match",
          "isCorrect": true
        },
        {
          "text": "$where",
          "isCorrect": false
        },
        {
          "text": "$find",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En el pipeline de agregación, `$match` cumple el rol de **filtrar documentos**, similar a un `WHERE` en SQL. Se suele poner al inicio para reducir la cantidad de datos que pasan por las siguientes etapas y así mejorar el rendimiento."
    },
    {
      "question": "¿Qué operador se usa en aggregation para agrupar documentos?",
      "options": [
        {
          "text": "$collect",
          "isCorrect": false
        },
        {
          "text": "$group",
          "isCorrect": true
        },
        {
          "text": "$aggregate",
          "isCorrect": false
        },
        {
          "text": "$join",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$group` se usa para **agrupar documentos** según uno o más campos y calcular agregados (sumas, conteos, promedios, etc.). Es el equivalente a `GROUP BY` en SQL dentro del aggregation pipeline."
    },
    {
      "question": "¿Qué es un replica set en MongoDB?",
      "options": [
        {
          "text": "Una copia de seguridad",
          "isCorrect": false
        },
        {
          "text": "Un grupo de instancias MongoDB que mantienen los mismos datos para alta disponibilidad",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función de seguridad",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **replica set** es un grupo de instancias de MongoDB donde una actúa como **primaria** y las demás como **secundarias**, todas con los mismos datos. Esto proporciona alta disponibilidad: si el primario cae, una secundaria puede ser elegida como nuevo primario."
    },
    {
      "question": "¿Qué es sharding en MongoDB?",
      "options": [
        {
          "text": "Fragmentación de discos",
          "isCorrect": false
        },
        {
          "text": "Distribución de datos entre múltiples servidores para escalabilidad horizontal",
          "isCorrect": true
        },
        {
          "text": "Un tipo de backup",
          "isCorrect": false
        },
        {
          "text": "Una función de compresión",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **sharding** distribuye los datos de una colección en **múltiples servidores (shards)** usando una clave de partición. Así se logra escalabilidad horizontal: más máquinas para manejar más volumen de datos y más carga de consultas/escrituras."
    },
    {
      "question": "¿Qué comando muestra todas las bases de datos en MongoDB?",
      "options": [
        {
          "text": "list databases",
          "isCorrect": false
        },
        {
          "text": "show dbs o show databases",
          "isCorrect": true
        },
        {
          "text": "get databases",
          "isCorrect": false
        },
        {
          "text": "display databases",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`show dbs` o `show databases` en el shell muestran **todas las bases de datos** existentes en la instancia. Es útil para ver rápidamente qué bases están creadas y cuánto espacio ocupa cada una."
    },
    {
      "question": "¿Qué comando selecciona una base de datos en MongoDB?",
      "options": [
        {
          "text": "select db nombre",
          "isCorrect": false
        },
        {
          "text": "use nombre",
          "isCorrect": true
        },
        {
          "text": "connect nombre",
          "isCorrect": false
        },
        {
          "text": "open nombre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El comando `use nombre` selecciona la base de datos con ese nombre y, si no existe todavía, se creará cuando insertes datos. A partir de ese momento, cualquier operación `db.coleccion...` se ejecuta sobre esa base."
    },
    {
      "question": "¿Qué comando muestra todas las colecciones?",
      "options": [
        {
          "text": "list collections",
          "isCorrect": false
        },
        {
          "text": "show collections",
          "isCorrect": true
        },
        {
          "text": "get collections",
          "isCorrect": false
        },
        {
          "text": "display collections",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`show collections` lista **todas las colecciones** de la base de datos actualmente seleccionada. Es similar a listar tablas en una base de datos relacional."
    },
    {
      "question": "¿Qué es un embedded document en MongoDB?",
      "options": [
        {
          "text": "Un documento embebido",
          "isCorrect": false
        },
        {
          "text": "Un documento anidado dentro de otro documento",
          "isCorrect": true
        },
        {
          "text": "Un documento cifrado",
          "isCorrect": false
        },
        {
          "text": "Un documento de configuración",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **embedded document** es un documento **anidado dentro de otro documento** como valor de un campo. Esto permite modelar relaciones \"contiene a\" (por ejemplo, dirección dentro de usuario) sin tener que hacer joins, aprovechando la naturaleza documental de MongoDB."
    },
    {
      "question": "¿Qué comando cuenta documentos en una colección?",
      "options": [
        {
          "text": "db.coleccion.total()",
          "isCorrect": false
        },
        {
          "text": "db.coleccion.countDocuments()",
          "isCorrect": true
        },
        {
          "text": "db.coleccion.number()",
          "isCorrect": false
        },
        {
          "text": "db.coleccion.size()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`db.coleccion.countDocuments()` devuelve el **número de documentos** que cumplen un filtro determinado (o todos, si no se pasa filtro). Es útil para estadísticas, paginación y validaciones (por ejemplo, saber cuántos registros existen de cierto tipo)."
    },
    {
      "question": "¿Qué operador de consulta busca valores dentro de un array?",
      "options": [
        {
          "text": "$contains",
          "isCorrect": false
        },
        {
          "text": "$in",
          "isCorrect": true
        },
        {
          "text": "$has",
          "isCorrect": false
        },
        {
          "text": "$includes",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El operador `$in` busca documentos donde un campo esté **contenido en una lista de valores**. Por ejemplo, `{ status: { $in: [\"active\", \"pending\"] } }` devuelve documentos cuyo `status` sea cualquiera de esos valores."
    },
    {
      "question": "¿Qué es MongoDB Atlas?",
      "options": [
        {
          "text": "Un libro sobre MongoDB",
          "isCorrect": false
        },
        {
          "text": "La plataforma cloud de MongoDB como servicio (DBaaS)",
          "isCorrect": true
        },
        {
          "text": "Un cliente de MongoDB",
          "isCorrect": false
        },
        {
          "text": "Una herramienta de backup",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**MongoDB Atlas** es el servicio de **MongoDB gestionado en la nube (DBaaS)**. Se encarga de provisionar clusters, backups, escalado, monitoreo y seguridad, para que vos solo te preocupes por usar la base de datos y no por administrarla."
    },
    {
      "question": "¿Qué garantiza MongoDB en términos de consistencia?",
      "options": [
        {
          "text": "ACID completo en todas las operaciones",
          "isCorrect": false
        },
        {
          "text": "Consistencia eventual por defecto, ACID en transacciones multi-documento",
          "isCorrect": true
        },
        {
          "text": "No garantiza consistencia",
          "isCorrect": false
        },
        {
          "text": "Solo garantiza disponibilidad",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Por defecto, MongoDB ofrece **consistencia eventual** en lecturas desde réplicas, pero puede garantizar **semánticas ACID** en transacciones multi-documento (en replica sets y clusters sharded). Con read/write concern adecuados podés ajustar el equilibrio entre rendimiento y consistencia."
    },
    {
      "question": "¿Qué es Mongoose?",
      "options": [
        {
          "text": "Un animal",
          "isCorrect": false
        },
        {
          "text": "Un ODM (Object Document Mapper) para MongoDB en Node.js",
          "isCorrect": true
        },
        {
          "text": "Un cliente gráfico de MongoDB",
          "isCorrect": false
        },
        {
          "text": "Una base de datos alternativa",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Mongoose** es un **ODM (Object Document Mapper)** para Node.js que agrega una capa de modelos, esquemas, validación y hooks sobre MongoDB. Ayuda a definir estructuras de datos más rígidas y a trabajar con documentos como objetos de JavaScript."
    },
    {
      "question": "¿Cuáles son operadores de consulta en MongoDB? (selección múltiple)",
      "options": [
        {
          "text": "$eq (equal)",
          "isCorrect": false
        },
        {
          "text": "$gt (greater than)",
          "isCorrect": true
        },
        {
          "text": "$lt (less than)",
          "isCorrect": true
        },
        {
          "text": "$ne (not equal)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Operadores como `$gt` (greater than) y `$lt` (less than) se usan para **comparaciones numéricas o de fechas**. Por ejemplo: `{ age: { $gt: 18, $lt: 65 } }` busca documentos donde `age` esté en ese rango."
    },
    {
      "question": "¿Qué es $and en MongoDB?",
      "options": [
        {
          "text": "Y lógico",
          "isCorrect": false
        },
        {
          "text": "Operador que combina múltiples condiciones (todas deben cumplirse)",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$and` permite combinar varias condiciones donde **todas deben cumplirse**. Aunque muchas veces se puede omitir (MongoDB aplica `AND` implícito entre campos), es útil cuando necesitás combinar expresiones más complejas."
    },
    {
      "question": "¿Qué es $or en MongoDB?",
      "options": [
        {
          "text": "O lógico",
          "isCorrect": false
        },
        {
          "text": "Operador donde al menos una condición debe cumplirse",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$or` combina condiciones donde **basta con que una de ellas sea verdadera**. Por ejemplo: `{ $or: [ { role: \"admin\" }, { isSuperUser: true } ] }` devuelve documentos que cumplan al menos una de esas reglas."
    },
    {
      "question": "¿Cuáles son operadores de array en MongoDB? (selección múltiple)",
      "options": [
        {
          "text": "$push",
          "isCorrect": false
        },
        {
          "text": "$pull",
          "isCorrect": true
        },
        {
          "text": "$addToSet",
          "isCorrect": true
        },
        {
          "text": "$pop",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Operadores de array como `$pull` y `$addToSet` permiten **modificar arrays dentro de documentos**. `$pull` elimina elementos que cumplan una condición, y `$addToSet` agrega un elemento solo si aún no existe, evitando duplicados."
    },
    {
      "question": "¿Qué hace $push en MongoDB?",
      "options": [
        {
          "text": "Empuja datos",
          "isCorrect": false
        },
        {
          "text": "Añade un elemento a un array",
          "isCorrect": true
        },
        {
          "text": "Elimina elementos",
          "isCorrect": false
        },
        {
          "text": "Ordena arrays",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$push` **agrega un elemento al final de un array**. Por ejemplo, `{ $push: { tags: \"nuevo\" } }` añade `\"nuevo\"` al array `tags`. Se puede combinar con modificadores como `$each`, `$position` y `$sort` para operaciones más avanzadas."
    },
    {
      "question": "¿Qué hace $pull en MongoDB?",
      "options": [
        {
          "text": "Jala datos",
          "isCorrect": false
        },
        {
          "text": "Elimina elementos de un array que cumplen condición",
          "isCorrect": true
        },
        {
          "text": "Añade elementos",
          "isCorrect": false
        },
        {
          "text": "Ordena arrays",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$pull` **elimina del array todos los elementos** que cumplan la condición dada. Es muy útil para quitar valores específicos o elementos que coincidan con un subdocumento sin tener que reconstruir el array completo."
    },
    {
      "question": "¿Qué hace $addToSet?",
      "options": [
        {
          "text": "Añade un conjunto",
          "isCorrect": false
        },
        {
          "text": "Añade elemento a array solo si no existe",
          "isCorrect": true
        },
        {
          "text": "Crea conjuntos",
          "isCorrect": false
        },
        {
          "text": "Elimina elementos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$addToSet` agrega un elemento a un array **solo si aún no está presente**, tratándolo como un conjunto (set). Esto evita duplicados de forma atómica, algo difícil de garantizar solo desde la lógica de aplicación."
    },
    {
      "question": "¿Qué es projection en MongoDB?",
      "options": [
        {
          "text": "Una proyección",
          "isCorrect": false
        },
        {
          "text": "Especifica qué campos incluir o excluir en resultados",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **projection** define **qué campos se devuelven** en los resultados de `find`. Podés incluir solo los campos necesarios o excluir los que no quieras, reduciendo el tamaño de respuesta y protegiendo información sensible."
    },
    {
      "question": "¿Cómo se excluye un campo en projection?",
      "options": [
        {
          "text": "field: 0",
          "isCorrect": false
        },
        {
          "text": "field: false",
          "isCorrect": true
        },
        {
          "text": "exclude: field",
          "isCorrect": false
        },
        {
          "text": "Tanto a como correcta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Para excluir un campo en la proyección se usa `{ campo: false }` o `{ campo: 0 }`. Por ejemplo: `db.users.find({}, { password: 0 })` devuelve todos los usuarios pero sin el campo `password`."
    },
    {
      "question": "¿Qué es $lookup en aggregation?",
      "options": [
        {
          "text": "Una búsqueda",
          "isCorrect": false
        },
        {
          "text": "Realiza un LEFT JOIN entre colecciones",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función simple",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En el aggregation pipeline, `$lookup` permite hacer una operación similar a un **LEFT JOIN entre colecciones**. Se usa para combinar datos relacionados que están en diferentes colecciones sin necesidad de hacerlo manualmente desde la aplicación."
    },
    {
      "question": "¿Qué es $unwind en aggregation?",
      "options": [
        {
          "text": "Desenrollar",
          "isCorrect": false
        },
        {
          "text": "Deconstruye un array en múltiples documentos",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$unwind` **deconstruye un array** en múltiples documentos, creando un documento por cada elemento del array. Es clave cuando querés tratar cada elemento de un array embebido como una fila independiente en el pipeline de agregación."
    },
    {
      "question": "¿Qué es $project en aggregation?",
      "options": [
        {
          "text": "Un proyecto",
          "isCorrect": false
        },
        {
          "text": "Remodela documentos (incluye, excluye o calcula campos)",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$project` sirve para **remodelar los documentos** dentro del pipeline: incluir/excluir campos, renombrarlos o crear campos calculados. Es el equivalente a elegir columnas y expresiones en un `SELECT` de SQL."
    },
    {
      "question": "¿Qué es $sort en aggregation?",
      "options": [
        {
          "text": "Ordenar",
          "isCorrect": false
        },
        {
          "text": "Ordena documentos por campos",
          "isCorrect": true
        },
        {
          "text": "Una función de búsqueda",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$sort` ordena los documentos del pipeline por uno o más campos, usando `1` para ascendente y `-1` para descendente. Es muy útil en reportes y listados donde necesitás un orden específico en la salida."
    },
    {
      "question": "¿Cuáles son etapas del aggregation pipeline? (selección múltiple)",
      "options": [
        {
          "text": "$match",
          "isCorrect": false
        },
        {
          "text": "$group",
          "isCorrect": true
        },
        {
          "text": "$project",
          "isCorrect": true
        },
        {
          "text": "$lookup",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Etapas como `$group` y `$project` son parte del **conjunto de stages del aggregation pipeline**. Combinándolas (junto a `$match`, `$sort`, `$unwind`, etc.) podés construir consultas analíticas muy potentes directamente en MongoDB."
    },
    {
      "question": "¿Qué es $limit en aggregation?",
      "options": [
        {
          "text": "Un límite",
          "isCorrect": false
        },
        {
          "text": "Limita el número de documentos",
          "isCorrect": true
        },
        {
          "text": "Una función de validación",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$limit` restringe la salida del pipeline a **un número máximo de documentos**. Es útil para paginación, muestreo de datos o para evitar procesar y devolver más registros de los necesarios."
    },
    {
      "question": "¿Qué es $skip en aggregation?",
      "options": [
        {
          "text": "Saltar",
          "isCorrect": false
        },
        {
          "text": "Salta un número de documentos",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$skip` **omite un número de documentos** al inicio del pipeline. Normalmente se usa junto con `$limit` para implementar paginación: por ejemplo, saltar los primeros 20 y devolver los siguientes 10."
    },
    {
      "question": "¿Qué es $count en aggregation?",
      "options": [
        {
          "text": "Contar",
          "isCorrect": false
        },
        {
          "text": "Cuenta el número de documentos",
          "isCorrect": true
        },
        {
          "text": "Una función simple",
          "isCorrect": false
        },
        {
          "text": "Un índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`$count` agrega al pipeline una etapa que **cuenta cuántos documentos** pasan hasta ese punto y devuelve un solo documento con ese valor. Es equivalente a un `COUNT(*)` filtrado con las stages anteriores."
    },
    {
      "question": "¿Qué es write concern en MongoDB?",
      "options": [
        {
          "text": "Una preocupación",
          "isCorrect": false
        },
        {
          "text": "Nivel de confirmación requerido para escrituras",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **write concern** define **qué nivel de confirmación** se requiere para considerar una escritura exitosa. Por ejemplo, esperar solo confirmación del primario o de la mayoría de los miembros del replica set, impactando en el balance entre seguridad y rendimiento."
    },
    {
      "question": "¿Cuáles son niveles de write concern? (selección múltiple)",
      "options": [
        {
          "text": "w: 0 (sin confirmación)",
          "isCorrect": false
        },
        {
          "text": "w: 1 (confirmado por primario)",
          "isCorrect": true
        },
        {
          "text": "w: \"majority\"",
          "isCorrect": true
        },
        {
          "text": "w: <número>",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Valores como `w: 1` (confirmado por el primario) o `w: \"majority\"` (confirmado por la mayoría de los nodos) son niveles de write concern. Cuanto más alto el nivel, más garantizada está la persistencia de la escritura, pero también mayor la latencia."
    },
    {
      "question": "¿Qué es read concern en MongoDB?",
      "options": [
        {
          "text": "Una preocupación de lectura",
          "isCorrect": false
        },
        {
          "text": "Nivel de consistencia de datos leídos",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **read concern** controla **qué tan \"frescos\" y consistentes** deben ser los datos leídos. Por ejemplo, podés permitir lecturas que aún no han sido replicadas completamente o exigir solo datos confirmados por la mayoría."
    },
    {
      "question": "¿Cuáles son niveles de read concern? (selección múltiple)",
      "options": [
        {
          "text": "local",
          "isCorrect": false
        },
        {
          "text": "majority",
          "isCorrect": true
        },
        {
          "text": "linearizable",
          "isCorrect": true
        },
        {
          "text": "available",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Niveles como `majority` o `linearizable` indican cuánta **consistencia** se exige al leer. `majority` asegura que los datos han sido confirmados por la mayoría del replica set, y `linearizable` garantiza la vista más fuerte y actual posible (a costa de rendimiento)."
    },
    {
      "question": "¿Qué es read preference en MongoDB?",
      "options": [
        {
          "text": "Una preferencia",
          "isCorrect": false
        },
        {
          "text": "Define de qué miembro del replica set leer",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **read preference** indica **de qué miembro del replica set** deben realizarse las lecturas: solo del primario, de secundarios, o estrategias mixtas. Esto permite balancear carga y decidir si priorizar consistencia o disponibilidad/rendimiento."
    },
    {
      "question": "¿Cuáles son opciones de read preference? (selección múltiple)",
      "options": [
        {
          "text": "primary",
          "isCorrect": false
        },
        {
          "text": "primaryPreferred",
          "isCorrect": true
        },
        {
          "text": "secondary",
          "isCorrect": true
        },
        {
          "text": "nearest",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Opciones como `primaryPreferred` y `secondary` son distintos modos de read preference. `primaryPreferred` lee del primario salvo que no esté disponible, y `secondary` envía lecturas a secundarios para aligerar al primario."
    },
    {
      "question": "¿Qué es un índice compuesto en MongoDB?",
      "options": [
        {
          "text": "Un índice complejo",
          "isCorrect": false
        },
        {
          "text": "Índice sobre múltiples campos",
          "isCorrect": true
        },
        {
          "text": "Un tipo especial",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **índice compuesto** incluye **más de un campo**, por ejemplo `{ lastName: 1, firstName: 1 }`. Es útil cuando las consultas filtran u ordenan por varias columnas en conjunto, mejorando el rendimiento de esas combinaciones."
    },
    {
      "question": "¿Qué es un índice de texto en MongoDB?",
      "options": [
        {
          "text": "Un índice textual",
          "isCorrect": false
        },
        {
          "text": "Índice especial para búsquedas de texto completo",
          "isCorrect": true
        },
        {
          "text": "Un índice normal",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **índice de texto** permite hacer **búsquedas de texto completo** sobre uno o varios campos de tipo string. Soporta búsqueda por palabras, lenguaje natural y relevancia, ideal para campos como títulos, descripciones, comentarios, etc."
    },
    {
      "question": "¿Cómo se crea un índice de texto?",
      "options": [
        {
          "text": "createIndex({ campo: \"text\" })",
          "isCorrect": false
        },
        {
          "text": "createIndex({ campo: 1 })",
          "isCorrect": true
        },
        {
          "text": "textIndex(campo)",
          "isCorrect": false
        },
        {
          "text": "index(campo, \"text\")",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Para crear un índice de texto se usa algo como:\n`db.coleccion.createIndex({ campo: \"text\" })`.\n\nLa idea es declarar qué campo(s) deben tratarse como texto indexado, para luego poder usar consultas con `$text` y `$search`."
    },
    {
      "question": "¿Qué es un índice geoespacial en MongoDB?",
      "options": [
        {
          "text": "Un índice espacial",
          "isCorrect": false
        },
        {
          "text": "Índice para consultas de ubicación geográfica",
          "isCorrect": true
        },
        {
          "text": "Un tipo normal",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **índice geoespacial** permite hacer **consultas basadas en ubicación** (puntos, polígonos, distancias). Se usa sobre campos que guardan coordenadas y habilita operaciones como \"lugares cerca de mí\" o \"dentro de un área\"."
    },
    {
      "question": "¿Cuáles son tipos de índices geoespaciales? (selección múltiple)",
      "options": [
        {
          "text": "2d",
          "isCorrect": false
        },
        {
          "text": "2dsphere",
          "isCorrect": true
        },
        {
          "text": "geoHaystack",
          "isCorrect": true
        },
        {
          "text": "3d",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Tipos como `2dsphere` y `geoHaystack` son índices geoespaciales:\n\n* `2dsphere` soporta coordenadas en la Tierra (lat/long, GeoJSON).\n* `geoHaystack` se pensó para búsquedas por cercanía en áreas pequeñas (aunque hoy se usa mucho más `2dsphere`)."
    },
    {
      "question": "¿Qué es TTL index en MongoDB?",
      "options": [
        {
          "text": "Time To Live",
          "isCorrect": false
        },
        {
          "text": "Índice que elimina documentos automáticamente después de un tiempo",
          "isCorrect": true
        },
        {
          "text": "Un índice temporal",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **TTL index (Time To Live)** hace que MongoDB **elimine documentos automáticamente** después de cierto tiempo, basándose en un campo de fecha. Es ideal para logs, sesiones, tokens y datos que caducan."
    },
    {
      "question": "¿Qué es un capped collection?",
      "options": [
        {
          "text": "Una colección limitada",
          "isCorrect": false
        },
        {
          "text": "Colección de tamaño fijo que sobrescribe documentos viejos",
          "isCorrect": true
        },
        {
          "text": "Una colección normal",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una **capped collection** es una colección de **tamaño fijo** que, al llenarse, empieza a **sobrescribir los documentos más antiguos**. Mantiene el orden de inserción y no permite borrar documentos individuales, por eso se usa para logs o buffers."
    },
    {
      "question": "¿Para qué se usa capped collection? (selección múltiple)",
      "options": [
        {
          "text": "Logs",
          "isCorrect": false
        },
        {
          "text": "Cache",
          "isCorrect": true
        },
        {
          "text": "Datos de alta inserción",
          "isCorrect": true
        },
        {
          "text": "Datos permanentes",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Las capped collections se usan para **caches y datos de alta inserción** donde solo importa mantener los registros más recientes. Son muy eficientes para escrituras secuenciales y para escenarios tipo \"stream de eventos\"."
    },
    {
      "question": "¿Qué es ObjectId en MongoDB?",
      "options": [
        {
          "text": "Un ID de objeto",
          "isCorrect": false
        },
        {
          "text": "Tipo de dato único de 12 bytes generado automáticamente",
          "isCorrect": true
        },
        {
          "text": "Un número entero",
          "isCorrect": false
        },
        {
          "text": "Un string",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ObjectId` es un tipo de dato especial de 12 bytes que MongoDB utiliza normalmente para el campo `_id`. Es único, compacto y se puede generar de forma distribuida sin colisiones, ideal como identificador de documentos."
    },
    {
      "question": "¿Qué información contiene ObjectId? (selección múltiple)",
      "options": [
        {
          "text": "Timestamp",
          "isCorrect": false
        },
        {
          "text": "ID de máquina",
          "isCorrect": true
        },
        {
          "text": "ID de proceso",
          "isCorrect": true
        },
        {
          "text": "Contador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Un `ObjectId` incluye, entre otras cosas, un **timestamp**, un identificador de **máquina** y de **proceso**, más un contador. Gracias a eso, es único e incremental en el tiempo, lo que facilita ordenar y generar IDs sin coordinar entre nodos."
    },
    {
      "question": "¿Qué es BSON vs JSON?",
      "options": [
        {
          "text": "Son iguales",
          "isCorrect": false
        },
        {
          "text": "BSON es binario y más eficiente, JSON es texto",
          "isCorrect": true
        },
        {
          "text": "JSON es más rápido",
          "isCorrect": false
        },
        {
          "text": "No hay diferencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**JSON** es un formato de texto legible por humanos, mientras que **BSON** es su versión **binaria y extendida**, más eficiente para almacenamiento y transmisión. BSON agrega tipos extra (como fechas y binarios) que JSON puro no define."
    },
    {
      "question": "¿Qué tipos adicionales tiene BSON? (selección múltiple)",
      "options": [
        {
          "text": "Date",
          "isCorrect": false
        },
        {
          "text": "Binary Data",
          "isCorrect": true
        },
        {
          "text": "ObjectId",
          "isCorrect": true
        },
        {
          "text": "Regular Expression",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "BSON soporta tipos adicionales como **Binary Data** y **ObjectId**, además de otros (Date, Decimal128, etc.). Esto le permite representar de forma nativa datos que en JSON tendrías que emular con strings o formatos custom."
    },
    {
      "question": "¿Qué es la opción upsert?",
      "options": [
        {
          "text": "Update e insert",
          "isCorrect": false
        },
        {
          "text": "Actualiza si existe, inserta si no existe",
          "isCorrect": true
        },
        {
          "text": "Solo actualiza",
          "isCorrect": false
        },
        {
          "text": "Solo inserta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La opción **upsert** en una operación de actualización hace que MongoDB **actualice el documento si existe o lo inserte si no existe**. Es decir, combina \"update\" y \"insert\" en una sola operación atómica basada en el filtro."
    },
    {
      "question": "¿Qué es bulkWrite en MongoDB?",
      "options": [
        {
          "text": "Escritura masiva",
          "isCorrect": false
        },
        {
          "text": "Ejecuta múltiples operaciones de escritura en lote",
          "isCorrect": true
        },
        {
          "text": "Una función simple",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`bulkWrite` ejecuta **múltiples operaciones de escritura en lote** (insert, update, delete) en una sola llamada. Eso reduce el round-trip con el servidor y puede mejorar mucho el rendimiento en cargas masivas de datos."
    },
    {
      "question": "¿Cuáles son operaciones de bulkWrite? (selección múltiple)",
      "options": [
        {
          "text": "insertOne",
          "isCorrect": false
        },
        {
          "text": "updateOne",
          "isCorrect": true
        },
        {
          "text": "deleteOne",
          "isCorrect": true
        },
        {
          "text": "replaceOne",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "En `bulkWrite` podés incluir operaciones como `updateOne`, `deleteOne`, `insertOne`, etc., en un array. Cada una se ejecuta siguiendo el orden definido, y al final recibís un resumen de cuántos documentos se modificaron, insertaron o borraron."
    },
    {
      "question": "¿Qué es change streams en MongoDB?",
      "options": [
        {
          "text": "Corrientes de cambio",
          "isCorrect": false
        },
        {
          "text": "Notificaciones en tiempo real de cambios en datos",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los **change streams** permiten **escuchar en tiempo real los cambios** que ocurren en una colección, base o cluster. Se basan en el oplog y son ideales para disparar procesos de auditoría, sincronización o notificaciones cuando se modifican datos."
    },
    {
      "question": "¿Para qué se usan change streams? (selección múltiple)",
      "options": [
        {
          "text": "Real-time updates",
          "isCorrect": false
        },
        {
          "text": "Auditoría",
          "isCorrect": true
        },
        {
          "text": "Sincronización",
          "isCorrect": true
        },
        {
          "text": "Cache invalidation",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Con change streams podés implementar fácilmente **auditoría** (registrar quién cambió qué) y **sincronización** (mantener caches, buscadores o otros sistemas actualizados). Evitan tener que hacer polling continuo sobre la base de datos."
    },
    {
      "question": "¿Qué es session en MongoDB?",
      "options": [
        {
          "text": "Una sesión",
          "isCorrect": false
        },
        {
          "text": "Contexto para transacciones multi-documento",
          "isCorrect": true
        },
        {
          "text": "Un tipo de conexión",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una **session** en MongoDB es un contexto que agrupa operaciones, especialmente útil para **transacciones multi-documento**. Todas las operaciones dentro de la sesión comparten ciertos metadatos y se pueden confirmar o deshacer juntas."
    },
    {
      "question": "¿Qué son las transacciones en MongoDB?",
      "options": [
        {
          "text": "Transacciones",
          "isCorrect": false
        },
        {
          "text": "Operaciones ACID multi-documento (desde 4.0)",
          "isCorrect": true
        },
        {
          "text": "No existen",
          "isCorrect": false
        },
        {
          "text": "Solo para un documento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las **transacciones** permiten ejecutar **múltiples operaciones (y documentos) con propiedades ACID**: o se aplican todas o ninguna. Desde MongoDB 4.0 esto es posible en replica sets, y desde 4.2 también en clusters sharded."
    },
    {
      "question": "¿Qué es el oplog en MongoDB?",
      "options": [
        {
          "text": "Operations log",
          "isCorrect": false
        },
        {
          "text": "Log especial que registra operaciones para replicación",
          "isCorrect": true
        },
        {
          "text": "Un log de errores",
          "isCorrect": false
        },
        {
          "text": "Un archivo de configuración",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **oplog** (operations log) es un log especial en los replica sets que **registra todas las operaciones de escritura** realizadas en el primario. Las secundarias lo leen y aplican para mantenerse sincronizadas con el primario."
    },
    {
      "question": "¿Qué es un secondary en replica set?",
      "options": [
        {
          "text": "Un secundario",
          "isCorrect": false
        },
        {
          "text": "Miembro que replica datos del primario",
          "isCorrect": true
        },
        {
          "text": "Un backup",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **secondary** es un miembro del replica set que **replica los datos del primario** leyendo del oplog. Puede servir para lecturas (según read preference) y entrar a ser primario si gana una elección tras la caída del actual primario."
    },
    {
      "question": "¿Qué es un arbiter en replica set?",
      "options": [
        {
          "text": "Un árbitro",
          "isCorrect": false
        },
        {
          "text": "Miembro que vota en elecciones pero no guarda datos",
          "isCorrect": true
        },
        {
          "text": "Un secundario",
          "isCorrect": false
        },
        {
          "text": "Un primario",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **arbiter** es un miembro del replica set que **solo participa en las votaciones**, pero no almacena datos. Se usa para mantener un número impar de votos y evitar empates sin necesidad de añadir más nodos con datos completos."
    },
    {
      "question": "¿Cuándo se usa un arbiter?",
      "options": [
        {
          "text": "Siempre",
          "isCorrect": false
        },
        {
          "text": "Para número impar de votos sin agregar almacenamiento",
          "isCorrect": true
        },
        {
          "text": "Nunca",
          "isCorrect": false
        },
        {
          "text": "Solo en producción",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Se utiliza un arbiter cuando necesitás **un número impar de votos** para elecciones de primario, pero no querés asumir el costo de almacenamiento de otro nodo completo. Aporta quorum sin aumentar capacidad de datos."
    },
    {
      "question": "¿Qué es priority en replica set?",
      "options": [
        {
          "text": "Una prioridad",
          "isCorrect": false
        },
        {
          "text": "Valor que influye en elecciones de primario",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La propiedad **priority** de un miembro del replica set indica **qué tan probable es que sea elegido primario**. Nodos con mayor priority serán preferidos como primarios, lo que permite controlar cuál nodo debería liderar normalmente."
    },
    {
      "question": "¿Qué es hidden member en replica set?",
      "options": [
        {
          "text": "Miembro oculto",
          "isCorrect": false
        },
        {
          "text": "Secondary que no es elegible como primario ni visible a clientes",
          "isCorrect": true
        },
        {
          "text": "Un error",
          "isCorrect": false
        },
        {
          "text": "Un tipo especial",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **hidden member** es un secondary que **no es visible para los clientes y no puede ser elegido primario**. Se suele usar para tareas especiales como reportes, backups o analytics, evitando impactar en el tráfico normal de la aplicación."
    },
    {
      "question": "¿Qué es delayed member en replica set?",
      "options": [
        {
          "text": "Miembro retrasado",
          "isCorrect": false
        },
        {
          "text": "Secondary con delay intencional para recuperación de errores",
          "isCorrect": true
        },
        {
          "text": "Un miembro lento",
          "isCorrect": false
        },
        {
          "text": "Un error",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **delayed member** es un secondary configurado con un **retraso intencional** en la replicación. Sirve como \"máquina del tiempo\" para recuperar el estado de la base antes de un error lógico (por ejemplo, un borrado masivo accidental)."
    },
    {
      "question": "¿Qué es shard key en MongoDB?",
      "options": [
        {
          "text": "Una clave de fragmento",
          "isCorrect": false
        },
        {
          "text": "Campo(s) usado para distribuir datos entre shards",
          "isCorrect": true
        },
        {
          "text": "Una clave primaria",
          "isCorrect": false
        },
        {
          "text": "Un índice normal",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **shard key** es el campo (o conjunto de campos) que se usa para **particionar los datos entre shards**. Una buena shard key es crítica para repartir la carga y evitar nodos sobrecargados."
    },
    {
      "question": "¿Cómo elegir una buena shard key? (selección múltiple)",
      "options": [
        {
          "text": "Alta cardinalidad",
          "isCorrect": false
        },
        {
          "text": "Buena distribución",
          "isCorrect": true
        },
        {
          "text": "Evitar hotspots",
          "isCorrect": true
        },
        {
          "text": "Considerar patrones de consulta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Elegir una buena shard key implica lograr **buena distribución de datos y carga** y **evitar hotspots** (todas las escrituras cayendo en el mismo shard). Por eso se recomiendan claves con alta cardinalidad y bien distribuidas."
    },
    {
      "question": "¿Qué es chunk en sharding?",
      "options": [
        {
          "text": "Un pedazo",
          "isCorrect": false
        },
        {
          "text": "Rango de datos basado en shard key",
          "isCorrect": true
        },
        {
          "text": "Un documento",
          "isCorrect": false
        },
        {
          "text": "Una colección",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **chunk** es un **rango de valores de shard key** que agrupa un subconjunto de documentos en un cluster sharded. MongoDB mueve estos chunks entre shards para balancear el almacenamiento y la carga."
    },
    {
      "question": "¿Qué es balancer en sharding?",
      "options": [
        {
          "text": "Un balanceador",
          "isCorrect": false
        },
        {
          "text": "Proceso que distribuye chunks entre shards",
          "isCorrect": true
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **balancer** es el proceso que **redistribuye automáticamente los chunks entre los shards** cuando detecta desequilibrios. Así busca que todos los nodos tengan una cantidad de datos y carga razonablemente similar."
    },
    {
      "question": "¿Qué es config server en sharding?",
      "options": [
        {
          "text": "Servidor de configuración",
          "isCorrect": false
        },
        {
          "text": "Almacena metadatos sobre el cluster",
          "isCorrect": true
        },
        {
          "text": "Un shard normal",
          "isCorrect": false
        },
        {
          "text": "Un servidor de backup",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **config server** almacena los **metadatos del cluster sharded**: qué colecciones están shardeadas, qué chunks existen y en qué shard está cada uno. Es la \"fuente de verdad\" de la topología del cluster."
    },
    {
      "question": "¿Qué es mongos en sharding?",
      "options": [
        {
          "text": "Un router",
          "isCorrect": false
        },
        {
          "text": "Proceso de enrutamiento que dirige consultas a shards correctos",
          "isCorrect": true
        },
        {
          "text": "Un servidor de datos",
          "isCorrect": false
        },
        {
          "text": "Un backup",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`mongos` es el **router de MongoDB** en entornos sharded. Recibe las consultas de los clientes, consulta a los config servers para saber dónde están los datos y las envía a los shards correctos, combinando las respuestas cuando es necesario."
    },
    {
      "question": "¿Qué es MongoDB Compass?",
      "options": [
        {
          "text": "Una brújula",
          "isCorrect": false
        },
        {
          "text": "GUI oficial de MongoDB para visualización y análisis",
          "isCorrect": true
        },
        {
          "text": "Una línea de comandos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**MongoDB Compass** es la **GUI oficial** de MongoDB. Permite conectarse a una base, explorar colecciones, ejecutar consultas, ver estadísticas, diseñar índices y analizar el rendimiento sin usar solo la línea de comandos."
    },
    {
      "question": "¿Qué es Studio 3T?",
      "options": [
        {
          "text": "Un estudio",
          "isCorrect": false
        },
        {
          "text": "IDE comercial potente para MongoDB",
          "isCorrect": true
        },
        {
          "text": "Una versión de MongoDB",
          "isCorrect": false
        },
        {
          "text": "Un tipo de índice",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Studio 3T** es un **IDE comercial** muy completo para MongoDB. Ofrece consultas visuales, migraciones, generación de código, comparación de datos, entre otras herramientas avanzadas para administradores y desarrolladores."
    },
    {
      "question": "¿Qué es Robo 3T (Robomongo)?",
      "options": [
        {
          "text": "Un robot",
          "isCorrect": false
        },
        {
          "text": "Cliente gráfico gratuito para MongoDB",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Robo 3T (Robomongo)** es un **cliente gráfico gratuito** para MongoDB. Permite explorar bases, ejecutar queries en una consola integrada y ver documentos de forma amigable, siendo una alternativa ligera a otras herramientas."
    },
    {
      "question": "¿Qué son los validators en MongoDB?",
      "options": [
        {
          "text": "Validadores",
          "isCorrect": false
        },
        {
          "text": "Reglas JSON Schema para validar documentos",
          "isCorrect": true
        },
        {
          "text": "Funciones de JavaScript",
          "isCorrect": false
        },
        {
          "text": "Índices especiales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los **validators** permiten definir **reglas de validación usando JSON Schema** u operadores de expresión para una colección. Así podés imponer ciertas restricciones de \"esquema\" (campos obligatorios, tipos, rangos) sin perder la flexibilidad general de MongoDB."
    }
  ],
  "poo": [
    {
      "question": "¿Qué es una clase?",
      "options": [
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        },
        {
          "text": "Una plantilla que define atributos y métodos para crear objetos",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un archivo de código",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una clase es el \"molde\" de los objetos: define qué datos (atributos) y qué operaciones (métodos) estarán disponibles en las instancias creadas a partir de ella."
    },
    {
      "question": "¿Qué es un objeto?",
      "options": [
        {
          "text": "Un archivo de datos",
          "isCorrect": false
        },
        {
          "text": "Una instancia de una clase con estado y comportamiento propios",
          "isCorrect": true
        },
        {
          "text": "Una función global",
          "isCorrect": false
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un objeto es una instancia concreta de una clase, con sus propios valores de atributos y la capacidad de ejecutar los métodos definidos por esa clase."
    },
    {
      "question": "¿Qué es encapsulación?",
      "options": [
        {
          "text": "Guardar archivos en carpetas",
          "isCorrect": false
        },
        {
          "text": "Ocultar los detalles internos de una clase y exponer solo lo necesario",
          "isCorrect": true
        },
        {
          "text": "Crear múltiples clases",
          "isCorrect": false
        },
        {
          "text": "Usar variables globales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La encapsulación consiste en ocultar los detalles internos de una clase y exponer solo una interfaz pública, normalmente usando modificadores de acceso (public, private, protected)."
    },
    {
      "question": "¿Qué es herencia?",
      "options": [
        {
          "text": "Compartir variables globales",
          "isCorrect": false
        },
        {
          "text": "Un mecanismo donde una clase hija obtiene atributos y métodos de una clase padre",
          "isCorrect": true
        },
        {
          "text": "Copiar código entre archivos",
          "isCorrect": false
        },
        {
          "text": "Un tipo de función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La herencia permite que una clase hija reutilice y extienda atributos y métodos de una clase padre, modelando relaciones del tipo \"es-un\"."
    },
    {
      "question": "¿Qué es polimorfismo?",
      "options": [
        {
          "text": "Tener muchas variables",
          "isCorrect": false
        },
        {
          "text": "Un mismo método con diferentes comportamientos según el tipo de objeto",
          "isCorrect": true
        },
        {
          "text": "Usar múltiples lenguajes",
          "isCorrect": false
        },
        {
          "text": "Una técnica de optimización",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El polimorfismo permite que el mismo método (mismo nombre) se comporte de manera diferente según el tipo concreto del objeto que lo ejecuta."
    },
    {
      "question": "¿Qué es abstracción?",
      "options": [
        {
          "text": "Hacer código complejo",
          "isCorrect": false
        },
        {
          "text": "Simplificar la realidad representando solo lo esencial y ocultando detalles",
          "isCorrect": true
        },
        {
          "text": "Usar variables abstractas",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La abstracción consiste en centrarse en los aspectos esenciales de un objeto y ocultar detalles innecesarios, por ejemplo mediante clases abstractas e interfaces."
    },
    {
      "question": "¿Diferencia entre herencia y composición?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Herencia reutiliza comportamiento (\"es-un\"), composición combina objetos (\"tiene-un\")",
          "isCorrect": true
        },
        {
          "text": "Herencia es mejor siempre",
          "isCorrect": false
        },
        {
          "text": "Composición es obsoleta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La herencia expresa relaciones \"es-un\" (un Perro es-un Animal), mientras que la composición expresa \"tiene-un\" (un Coche tiene-un Motor); la composición suele dar diseños más flexibles."
    },
    {
      "question": "¿Qué significa el principio SRP en SOLID?",
      "options": [
        {
          "text": "Super Rapid Programming",
          "isCorrect": false
        },
        {
          "text": "Single Responsibility Principle: cada clase debe tener una sola responsabilidad",
          "isCorrect": true
        },
        {
          "text": "Standard Reference Point",
          "isCorrect": false
        },
        {
          "text": "Simple Reusable Pattern",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "SRP indica que cada clase debe tener una única razón para cambiar, es decir, una sola responsabilidad bien definida."
    },
    {
      "question": "¿Qué significa el principio OCP en SOLID?",
      "options": [
        {
          "text": "Object Creation Pattern",
          "isCorrect": false
        },
        {
          "text": "Open/Closed Principle: abierto a extensión, cerrado a modificación",
          "isCorrect": true
        },
        {
          "text": "Optimized Code Performance",
          "isCorrect": false
        },
        {
          "text": "Original Class Properties",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "OCP dice que los módulos deben poder extenderse con nuevo comportamiento sin tener que modificar su código existente, por ejemplo mediante interfaces o herencia."
    },
    {
      "question": "¿Qué significa el principio LSP en SOLID?",
      "options": [
        {
          "text": "Low Security Protocol",
          "isCorrect": false
        },
        {
          "text": "Liskov Substitution Principle: subtipos deben poder sustituir a sus tipos base",
          "isCorrect": true
        },
        {
          "text": "Large Scale Programming",
          "isCorrect": false
        },
        {
          "text": "Limited Scope Pattern",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "LSP indica que cualquier instancia de una subclase debe poder usarse donde se espera la clase base sin romper el comportamiento esperado del sistema."
    },
    {
      "question": "¿Qué significa el principio ISP en SOLID?",
      "options": [
        {
          "text": "Internet Service Provider",
          "isCorrect": false
        },
        {
          "text": "Interface Segregation Principle: interfaces específicas mejor que una general",
          "isCorrect": true
        },
        {
          "text": "Integrated Security Protocol",
          "isCorrect": false
        },
        {
          "text": "Independent System Pattern",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ISP recomienda tener varias interfaces pequeñas y específicas en vez de una interfaz grande y genérica, para que las clases dependan solo de lo que realmente usan."
    },
    {
      "question": "¿Qué significa el principio DIP en SOLID?",
      "options": [
        {
          "text": "Encapsulación",
          "isCorrect": true
        },
        {
          "text": "Herencia",
          "isCorrect": false
        },
        {
          "text": "Polimorfismo",
          "isCorrect": false
        },
        {
          "text": "Abstracción",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "DIP propone que las clases dependan de abstracciones (interfaces) en lugar de implementaciones concretas, facilitando el cambio y las pruebas."
    },
    {
      "question": "¿Qué es un método?",
      "options": [
        {
          "text": "Una variable de clase",
          "isCorrect": false
        },
        {
          "text": "Una función definida dentro de una clase que define su comportamiento",
          "isCorrect": true
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        },
        {
          "text": "Un archivo de código",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un método es una función definida dentro de una clase que describe acciones o comportamientos que los objetos de esa clase pueden realizar."
    },
    {
      "question": "¿Qué es un atributo?",
      "options": [
        {
          "text": "Un método privado",
          "isCorrect": false
        },
        {
          "text": "Una variable que representa el estado de un objeto",
          "isCorrect": true
        },
        {
          "text": "Una función global",
          "isCorrect": false
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un atributo es una variable declarada dentro de una clase que almacena parte del estado del objeto (por ejemplo, nombre, edad, saldo)."
    },
    {
      "question": "¿Qué es un constructor?",
      "options": [
        {
          "text": "Objetos distintos pueden responder al mismo mensaje de forma diferente",
          "isCorrect": true
        },
        {
          "text": "Herencia múltiple",
          "isCorrect": false
        },
        {
          "text": "Ocultar datos",
          "isCorrect": false
        },
        {
          "text": "Crear clases abstractas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El constructor es un método especial que se ejecuta automáticamente al crear un objeto y suele inicializar sus atributos."
    },
    {
      "question": "¿Qué es un método estático?",
      "options": [
        {
          "text": "Un método que no cambia",
          "isCorrect": false
        },
        {
          "text": "Un método que pertenece a la clase, no a instancias individuales",
          "isCorrect": true
        },
        {
          "text": "Un método privado",
          "isCorrect": false
        },
        {
          "text": "Un método obsoleto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un método estático pertenece a la clase en sí y puede llamarse sin crear una instancia; normalmente se usa para utilidades o lógica que no depende del estado de un objeto concreto."
    },
    {
      "question": "¿Qué es una interfaz?",
      "options": [
        {
          "text": "Una UI gráfica",
          "isCorrect": false
        },
        {
          "text": "Un contrato que define métodos que una clase debe implementar",
          "isCorrect": true
        },
        {
          "text": "Una clase abstracta",
          "isCorrect": false
        },
        {
          "text": "Un tipo de variable",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una interfaz define un contrato de métodos (y a veces propiedades) que las clases que la implementan se comprometen a proporcionar."
    },
    {
      "question": "¿Qué es una clase abstracta?",
      "options": [
        {
          "text": "Una clase complicada",
          "isCorrect": false
        },
        {
          "text": "Una clase que no puede instanciarse y sirve como base para otras clases",
          "isCorrect": true
        },
        {
          "text": "Una clase sin métodos",
          "isCorrect": false
        },
        {
          "text": "Una clase privada",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una clase abstracta no puede instanciarse directamente, puede contener métodos abstractos y sirve como base común para que otras clases la extiendan."
    },
    {
      "question": "¿Qué es el modificador private?",
      "options": [
        {
          "text": "Un método público",
          "isCorrect": false
        },
        {
          "text": "Un modificador que restringe el acceso solo a la propia clase",
          "isCorrect": true
        },
        {
          "text": "Una variable global",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El modificador `private` restringe el acceso a un miembro para que solo pueda ser usado dentro de la misma clase, reforzando la encapsulación."
    },
    {
      "question": "¿Qué es el modificador protected?",
      "options": [
        {
          "text": "Un nivel de seguridad",
          "isCorrect": false
        },
        {
          "text": "Un modificador que permite acceso a la clase y sus subclases",
          "isCorrect": true
        },
        {
          "text": "Un método público",
          "isCorrect": false
        },
        {
          "text": "Una variable privada",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El modificador `protected` permite acceder a un miembro desde la propia clase y desde sus subclases, pero no desde código externo."
    },
    {
      "question": "¿Qué es el modificador public?",
      "options": [
        {
          "text": "Un objeto creado a partir de una clase",
          "isCorrect": true
        },
        {
          "text": "Una variable estática",
          "isCorrect": false
        },
        {
          "text": "Un método de clase",
          "isCorrect": false
        },
        {
          "text": "Una interfaz",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El modificador `public` hace que un miembro sea accesible desde cualquier parte del código que vea a la clase, componiendo la interfaz pública de esa clase."
    },
    {
      "question": "¿Qué es sobrecarga de métodos (overloading)?",
      "options": [
        {
          "text": "Usar demasiados métodos",
          "isCorrect": false
        },
        {
          "text": "Definir múltiples métodos con el mismo nombre pero diferentes parámetros",
          "isCorrect": true
        },
        {
          "text": "Un error de programación",
          "isCorrect": false
        },
        {
          "text": "Una técnica de optimización",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La sobrecarga (overloading) permite definir varios métodos con el mismo nombre pero diferentes firmas (parámetros), para manejar casos de uso similares."
    },
    {
      "question": "¿Qué es sobreescritura de métodos (overriding)?",
      "options": [
        {
          "text": "Borrar métodos",
          "isCorrect": false
        },
        {
          "text": "Redefinir un método heredado en una clase hija con diferente implementación",
          "isCorrect": true
        },
        {
          "text": "Copiar métodos",
          "isCorrect": false
        },
        {
          "text": "Un error de compilación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La sobreescritura (overriding) ocurre cuando una subclase redefine un método heredado para ajustar o extender su comportamiento."
    },
    {
      "question": "¿Qué significa DRY?",
      "options": [
        {
          "text": "Data Replication Yearly",
          "isCorrect": false
        },
        {
          "text": "Don't Repeat Yourself: evitar duplicar lógica o código",
          "isCorrect": true
        },
        {
          "text": "Dynamic Resource Yield",
          "isCorrect": false
        },
        {
          "text": "Direct Return Yes",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "DRY (\"Don't Repeat Yourself\") anima a extraer lógica repetida en un solo lugar reutilizable, reduciendo errores y facilitando los cambios."
    },
    {
      "question": "¿Qué es el acoplamiento en POO?",
      "options": [
        {
          "text": "Unir archivos",
          "isCorrect": false
        },
        {
          "text": "El grado de dependencia entre clases (menor acoplamiento = mejor)",
          "isCorrect": true
        },
        {
          "text": "Una técnica de optimización",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El acoplamiento mide cuán dependiente es una clase de otras; un diseño con bajo acoplamiento es más fácil de modificar y probar."
    },
    {
      "question": "¿Qué es la cohesión en POO?",
      "options": [
        {
          "text": "Pegamento de código",
          "isCorrect": false
        },
        {
          "text": "Grado en que elementos de una clase están relacionados (mayor cohesión = mejor)",
          "isCorrect": true
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La cohesión mide cuán relacionadas están las responsabilidades de una clase; alta cohesión implica que la clase hace pocas cosas pero muy relacionadas entre sí."
    },
    {
      "question": "¿Cuáles son beneficios de la POO? (selección múltiple)",
      "options": [
        {
          "text": "Reutilización de código",
          "isCorrect": false
        },
        {
          "text": "Mantenibilidad",
          "isCorrect": true
        },
        {
          "text": "Escalabilidad",
          "isCorrect": true
        },
        {
          "text": "Abstracción de complejidad",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Mantenibilidad y escalabilidad son beneficios clave de POO: el código orientado a objetos suele ser más fácil de modificar, ampliar y entender con el tiempo."
    },
    {
      "question": "¿Qué es el principio de responsabilidad única (SRP)?",
      "options": [
        {
          "text": "Una responsabilidad",
          "isCorrect": false
        },
        {
          "text": "Cada clase debe tener una sola razón para cambiar",
          "isCorrect": true
        },
        {
          "text": "Puede hacer muchas cosas",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El principio de responsabilidad única dice que una clase debe tener una sola razón para cambiar, es decir, un único objetivo claro dentro del sistema."
    },
    {
      "question": "¿Qué es el principio Open/Closed?",
      "options": [
        {
          "text": "Abrir y cerrar",
          "isCorrect": false
        },
        {
          "text": "Abierto a extensión, cerrado a modificación",
          "isCorrect": true
        },
        {
          "text": "Siempre cerrado",
          "isCorrect": false
        },
        {
          "text": "Siempre abierto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El principio Open/Closed indica que debemos poder añadir nuevas funcionalidades extendiendo clases existentes (o añadiendo nuevas), sin tener que cambiar su código."
    },
    {
      "question": "¿Qué es el principio de Sustitución de Liskov (LSP)?",
      "options": [
        {
          "text": "Un nombre",
          "isCorrect": false
        },
        {
          "text": "Los subtipos deben poder sustituir a sus tipos base",
          "isCorrect": true
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "LSP dice que las subclases deben respetar las expectativas de la clase base; si reemplazas el tipo base por un subtipo, el código cliente debe seguir funcionando correctamente."
    },
    {
      "question": "¿Qué es el principio de Segregación de Interfaces (ISP)?",
      "options": [
        {
          "text": "Segregación",
          "isCorrect": false
        },
        {
          "text": "Muchas interfaces específicas mejor que una general",
          "isCorrect": true
        },
        {
          "text": "Una sola interfaz grande",
          "isCorrect": false
        },
        {
          "text": "No usar interfaces",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ISP sugiere dividir interfaces grandes en varias interfaces pequeñas para que las clases implementen solo lo que realmente necesitan."
    },
    {
      "question": "¿Qué es el principio de Inversión de Dependencias (DIP)?",
      "options": [
        {
          "text": "Una inversión",
          "isCorrect": false
        },
        {
          "text": "Depender de abstracciones, no de implementaciones concretas",
          "isCorrect": true
        },
        {
          "text": "Depender de todo",
          "isCorrect": false
        },
        {
          "text": "No tener dependencias",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "DIP anima a que los módulos de alto nivel dependan de interfaces o abstracciones, no de detalles concretos, lo que facilita intercambiar implementaciones."
    },
    {
      "question": "¿Cuáles son los 5 principios SOLID? (selección múltiple)",
      "options": [
        {
          "text": "Single Responsibility",
          "isCorrect": false
        },
        {
          "text": "Open/Closed",
          "isCorrect": true
        },
        {
          "text": "Liskov Substitution",
          "isCorrect": true
        },
        {
          "text": "Interface Segregation y Dependency Inversion",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Dentro de SOLID, OCP y LSP son dos de los cinco principios que ayudan a que el diseño sea extensible y los tipos derivados sean seguros de usar."
    },
    {
      "question": "¿Qué es un patrón de diseño?",
      "options": [
        {
          "text": "Un diseño gráfico",
          "isCorrect": false
        },
        {
          "text": "Solución reutilizable a problemas comunes en diseño de software",
          "isCorrect": true
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un patrón de diseño es una solución probada y reutilizable a un problema de diseño recurrente, descrita de forma genérica para poder aplicarla en distintos contextos."
    },
    {
      "question": "¿Cuáles son categorías de patrones de diseño? (selección múltiple)",
      "options": [
        {
          "text": "Métodos estáticos o de clase, definidos con self",
          "isCorrect": true
        },
        {
          "text": "Métodos privados",
          "isCorrect": false
        },
        {
          "text": "Métodos heredados",
          "isCorrect": false
        },
        {
          "text": "Métodos abstractos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los patrones estructurales se centran en cómo se relacionan y componen las clases; los de comportamiento se centran en cómo se comunican y colaboran los objetos."
    },
    {
      "question": "¿Qué es el patrón Singleton?",
      "options": [
        {
          "text": "Un soltero",
          "isCorrect": false
        },
        {
          "text": "Asegura que una clase tenga solo una instancia",
          "isCorrect": true
        },
        {
          "text": "Múltiples instancias",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Singleton garantiza que exista una única instancia de una clase y proporciona un punto global de acceso a ella."
    },
    {
      "question": "¿Qué es el patrón Factory?",
      "options": [
        {
          "text": "Una fábrica",
          "isCorrect": false
        },
        {
          "text": "Crea objetos sin especificar la clase exacta",
          "isCorrect": true
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Factory encapsula la lógica de creación de objetos, permitiendo crear instancias sin acoplar el código cliente a clases concretas."
    },
    {
      "question": "¿Qué es el patrón Builder?",
      "options": [
        {
          "text": "Un constructor",
          "isCorrect": false
        },
        {
          "text": "Construye objetos complejos paso a paso",
          "isCorrect": true
        },
        {
          "text": "Una función simple",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Builder separa la construcción de un objeto complejo de su representación final, permitiendo crear variaciones paso a paso con el mismo proceso."
    },
    {
      "question": "¿Qué es el patrón Prototype?",
      "options": [
        {
          "text": "Un prototipo",
          "isCorrect": false
        },
        {
          "text": "Crea objetos clonando un prototipo existente",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Prototype crea nuevos objetos clonando un objeto prototipo existente, útil cuando la creación directa es costosa o compleja."
    },
    {
      "question": "¿Qué es el patrón Adapter?",
      "options": [
        {
          "text": "Un adaptador",
          "isCorrect": false
        },
        {
          "text": "Permite que interfaces incompatibles trabajen juntas",
          "isCorrect": true
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Adapter actúa como un traductor entre dos interfaces incompatibles, permitiendo reutilizar código sin modificarlo."
    },
    {
      "question": "¿Qué es el patrón Decorator?",
      "options": [
        {
          "text": "Un decorador",
          "isCorrect": false
        },
        {
          "text": "Añade funcionalidad a objetos dinámicamente",
          "isCorrect": true
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        },
        {
          "text": "Una función simple",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Decorator envuelve un objeto para añadirle responsabilidades adicionales en tiempo de ejecución sin modificar su clase."
    },
    {
      "question": "¿Qué es el patrón Facade?",
      "options": [
        {
          "text": "Una fachada",
          "isCorrect": false
        },
        {
          "text": "Proporciona una interfaz simplificada a un sistema complejo",
          "isCorrect": true
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Facade ofrece una interfaz simple y unificada a un subsistema complejo, reduciendo el acoplamiento con sus detalles internos."
    },
    {
      "question": "¿Qué es el patrón Proxy?",
      "options": [
        {
          "text": "Un intermediario",
          "isCorrect": false
        },
        {
          "text": "Proporciona un sustituto o placeholder para otro objeto",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Proxy proporciona un objeto sustituto que controla el acceso a otro objeto, por ejemplo para aplicar caché, lazy loading o control de acceso."
    },
    {
      "question": "¿Qué es el patrón Observer?",
      "options": [
        {
          "text": "Un observador",
          "isCorrect": false
        },
        {
          "text": "Define dependencia uno-a-muchos para notificar cambios",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Observer define una relación uno-a-muchos: cuando el objeto observado cambia, notifica automáticamente a todos sus observadores."
    },
    {
      "question": "¿Qué es el patrón Strategy?",
      "options": [
        {
          "text": "Una estrategia",
          "isCorrect": false
        },
        {
          "text": "Define familia de algoritmos intercambiables",
          "isCorrect": true
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Strategy encapsula algoritmos intercambiables detrás de una misma interfaz, permitiendo cambiar el comportamiento en tiempo de ejecución."
    },
    {
      "question": "¿Qué es el patrón Template Method?",
      "options": [
        {
          "text": "Una plantilla",
          "isCorrect": false
        },
        {
          "text": "Define esqueleto de algoritmo, subclases implementan pasos",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Template Method define el esqueleto de un algoritmo en una clase base y permite que las subclases personalicen pasos específicos."
    },
    {
      "question": "¿Qué es el patrón Command?",
      "options": [
        {
          "text": "Un comando",
          "isCorrect": false
        },
        {
          "text": "Encapsula una petición como objeto",
          "isCorrect": true
        },
        {
          "text": "Una función simple",
          "isCorrect": false
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El patrón Command encapsula una petición como un objeto, permitiendo parametrizar acciones, hacer colas de comandos o deshacer (undo) operaciones."
    },
    {
      "question": "¿Qué es composición sobre herencia?",
      "options": [
        {
          "text": "Una regla",
          "isCorrect": false
        },
        {
          "text": "Principio que favorece composición de objetos sobre herencia de clases",
          "isCorrect": true
        },
        {
          "text": "Siempre usar herencia",
          "isCorrect": false
        },
        {
          "text": "No usar composición",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "\"Composición sobre herencia\" recomienda preferir construir objetos a partir de otros (delegando responsabilidades) antes que crear jerarquías profundas de herencia."
    },
    {
      "question": "¿Por qué favorecer composición sobre herencia? (selección múltiple)",
      "options": [
        {
          "text": "Mayor flexibilidad",
          "isCorrect": false
        },
        {
          "text": "Menor acoplamiento",
          "isCorrect": true
        },
        {
          "text": "Evita jerarquías complejas",
          "isCorrect": true
        },
        {
          "text": "Más fácil de testear",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "La composición reduce el acoplamiento y ayuda a evitar jerarquías rígidas y difíciles de mantener, por eso se suele preferir frente a herencia en muchos casos."
    },
    {
      "question": "¿Qué es una clase final o sealed?",
      "options": [
        {
          "text": "Una clase terminada",
          "isCorrect": false
        },
        {
          "text": "Una clase que no puede ser heredada",
          "isCorrect": true
        },
        {
          "text": "Una clase sin métodos",
          "isCorrect": false
        },
        {
          "text": "Una clase abstracta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una clase final o sealed es una clase que no puede ser extendida, lo que puede usarse para evitar herencias indebidas o por motivos de seguridad/diseño."
    },
    {
      "question": "¿Qué es un método final?",
      "options": [
        {
          "text": "El último método",
          "isCorrect": false
        },
        {
          "text": "Un método que no puede ser sobrescrito",
          "isCorrect": true
        },
        {
          "text": "Un método sin parámetros",
          "isCorrect": false
        },
        {
          "text": "Un método abstracto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un método final no puede ser sobrescrito en las subclases, garantizando que su comportamiento permanezca inalterado."
    },
    {
      "question": "¿Qué es la inyección de dependencias?",
      "options": [
        {
          "text": "Una inyección",
          "isCorrect": false
        },
        {
          "text": "Técnica donde las dependencias se proveen externamente",
          "isCorrect": true
        },
        {
          "text": "Crear dependencias dentro",
          "isCorrect": false
        },
        {
          "text": "No tener dependencias",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La inyección de dependencias consiste en que las dependencias se pasen \"desde fuera\" (por constructor, setter, etc.) en lugar de que la propia clase las cree."
    },
    {
      "question": "¿Cuáles son tipos de inyección de dependencias? (selección múltiple)",
      "options": [
        {
          "text": "Constructor injection",
          "isCorrect": false
        },
        {
          "text": "Setter injection",
          "isCorrect": true
        },
        {
          "text": "Interface injection",
          "isCorrect": true
        },
        {
          "text": "Field injection",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "En setter injection la dependencia se pasa mediante un método setter; en interface injection, la clase expone métodos definidos en una interfaz para recibir sus dependencias."
    },
    {
      "question": "¿Qué es inversión de control (IoC)?",
      "options": [
        {
          "text": "Control invertido",
          "isCorrect": false
        },
        {
          "text": "Framework controla flujo, no el código del usuario",
          "isCorrect": true
        },
        {
          "text": "Usuario controla todo",
          "isCorrect": false
        },
        {
          "text": "No hay control",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La inversión de control significa que el flujo principal de la aplicación está controlado por un framework o contenedor, no por el código de usuario."
    },
    {
      "question": "¿Qué es un contenedor de IoC?",
      "options": [
        {
          "text": "Un contenedor",
          "isCorrect": false
        },
        {
          "text": "Framework que gestiona creación y dependencias de objetos",
          "isCorrect": true
        },
        {
          "text": "Una clase normal",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un contenedor de IoC es una herramienta que crea objetos, resuelve sus dependencias e inyecta las instancias adecuadas según una configuración."
    },
    {
      "question": "¿Qué es GRASP?",
      "options": [
        {
          "text": "Agarrar",
          "isCorrect": false
        },
        {
          "text": "General Responsibility Assignment Software Patterns",
          "isCorrect": true
        },
        {
          "text": "Un lenguaje",
          "isCorrect": false
        },
        {
          "text": "Un framework",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "GRASP (\"General Responsibility Assignment Software Patterns\") es un conjunto de patrones que ayudan a decidir cómo asignar responsabilidades a clases y objetos."
    },
    {
      "question": "¿Cuáles son principios GRASP? (selección múltiple)",
      "options": [
        {
          "text": "Creator",
          "isCorrect": false
        },
        {
          "text": "Information Expert",
          "isCorrect": true
        },
        {
          "text": "Low Coupling",
          "isCorrect": true
        },
        {
          "text": "High Cohesion",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Information Expert sugiere asignar una responsabilidad a la clase que tiene la información necesaria, y Low Coupling recomienda minimizar las dependencias entre clases."
    },
    {
      "question": "¿Qué es el principio Information Expert?",
      "options": [
        {
          "text": "Un experto",
          "isCorrect": false
        },
        {
          "text": "Asignar responsabilidad a la clase con información necesaria",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Information Expert indica que la clase que posee los datos relevantes debe ser la que implemente la lógica relacionada con esos datos."
    },
    {
      "question": "¿Qué es el principio Creator?",
      "options": [
        {
          "text": "Un creador",
          "isCorrect": false
        },
        {
          "text": "Define quién debe crear instancias de una clase",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El principio Creator orienta sobre qué clase debe crear instancias de otra: típicamente aquella que las contiene, las usa intensivamente o tiene los datos necesarios para inicializarlas."
    },
    {
      "question": "¿Qué es el principio Controller en GRASP?",
      "options": [
        {
          "text": "Un controlador",
          "isCorrect": false
        },
        {
          "text": "Asignar responsabilidad de manejar eventos del sistema",
          "isCorrect": true
        },
        {
          "text": "Una vista",
          "isCorrect": false
        },
        {
          "text": "Un modelo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Controller en GRASP propone usar un objeto controlador para recibir y coordinar las peticiones del sistema, separando la lógica de flujo de los objetos de dominio."
    },
    {
      "question": "¿Qué es Pure Fabrication?",
      "options": [
        {
          "text": "Fabricación pura",
          "isCorrect": false
        },
        {
          "text": "Clase que no representa concepto del dominio, solo solución técnica",
          "isCorrect": true
        },
        {
          "text": "Una clase real",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Pure Fabrication es una clase creada por motivos puramente técnicos (no de dominio) para mejorar la cohesión o reducir el acoplamiento, por ejemplo un repositorio."
    },
    {
      "question": "¿Qué es Indirection en GRASP?",
      "options": [
        {
          "text": "Indirección",
          "isCorrect": false
        },
        {
          "text": "Asignar responsabilidad a objeto intermediario para reducir acoplamiento",
          "isCorrect": true
        },
        {
          "text": "Conexión directa",
          "isCorrect": false
        },
        {
          "text": "Un tipo de herencia",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Indirection introduce un objeto intermediario entre dos componentes para reducir su acoplamiento directo y facilitar cambios futuros."
    },
    {
      "question": "¿Qué es Protected Variations?",
      "options": [
        {
          "text": "Variaciones protegidas",
          "isCorrect": false
        },
        {
          "text": "Proteger elementos de variaciones mediante interfaces estables",
          "isCorrect": true
        },
        {
          "text": "No proteger nada",
          "isCorrect": false
        },
        {
          "text": "Un tipo de clase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Protected Variations sugiere aislar los elementos del sistema frente a cambios probables, usando interfaces estables o puntos de extensión bien definidos."
    },
    {
      "question": "¿Qué es Tell, Don't Ask?",
      "options": [
        {
          "text": "Decir, no preguntar",
          "isCorrect": false
        },
        {
          "text": "Principio donde objetos hacen cosas en vez de exponer estado",
          "isCorrect": true
        },
        {
          "text": "Siempre preguntar",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "\"Tell, Don't Ask\" recomienda decirle al objeto qué debe hacer en vez de pedirle datos para que otro objeto lo haga, favoreciendo el encapsulamiento."
    },
    {
      "question": "¿Qué es Law of Demeter?",
      "options": [
        {
          "text": "Una ley",
          "isCorrect": false
        },
        {
          "text": "Un objeto solo debe hablar con sus vecinos inmediatos",
          "isCorrect": true
        },
        {
          "text": "Hablar con todos",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La Ley de Demeter dice que un objeto debe comunicarse solo con sus \"vecinos\" inmediatos, evitando cadenas largas de llamadas como `obj.a().b().c()`."
    },
    {
      "question": "¿Qué significa \"hablar solo con vecinos\" en LoD? (selección múltiple)",
      "options": [
        {
          "text": "Objeto mismo",
          "isCorrect": false
        },
        {
          "text": "Parámetros del método",
          "isCorrect": true
        },
        {
          "text": "Objetos que crea",
          "isCorrect": true
        },
        {
          "text": "Cualquier objeto global",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "En LoD, es válido hablar con los parámetros del método y con los objetos que la clase crea directamente, porque se consideran sus colaboradores inmediatos."
    },
    {
      "question": "¿Qué es YAGNI?",
      "options": [
        {
          "text": "Un acrónimo",
          "isCorrect": false
        },
        {
          "text": "You Aren't Gonna Need It - no implementar hasta que sea necesario",
          "isCorrect": true
        },
        {
          "text": "Implementar todo",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "YAGNI (\"You Aren't Gonna Need It\") recuerda que no deberías implementar funcionalidad hasta que realmente sea necesaria, evitando complejidad anticipada."
    },
    {
      "question": "¿Qué es KISS?",
      "options": [
        {
          "text": "Un beso",
          "isCorrect": false
        },
        {
          "text": "Keep It Simple, Stupid - mantener soluciones simples",
          "isCorrect": true
        },
        {
          "text": "Hacer todo complejo",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "KISS (\"Keep It Simple, Stupid\") anima a elegir la solución más simple que funcione, en lugar de diseños demasiado sofisticados sin necesidad."
    },
    {
      "question": "¿Qué es el antipatrón God Object?",
      "options": [
        {
          "text": "Un objeto dios",
          "isCorrect": false
        },
        {
          "text": "Objeto que sabe o hace demasiado",
          "isCorrect": true
        },
        {
          "text": "Un patrón bueno",
          "isCorrect": false
        },
        {
          "text": "Una clase normal",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un God Object es una clase que concentra demasiadas responsabilidades o conocimiento, violando SRP y haciendo el sistema difícil de mantener."
    },
    {
      "question": "¿Qué es el antipatrón Spaghetti Code?",
      "options": [
        {
          "text": "Código espagueti",
          "isCorrect": false
        },
        {
          "text": "Código enredado sin estructura clara",
          "isCorrect": true
        },
        {
          "text": "Código organizado",
          "isCorrect": false
        },
        {
          "text": "Un patrón bueno",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Spaghetti Code es un código desordenado con dependencias enredadas y flujo poco claro, lo que dificulta entenderlo, probarlo y modificarlo."
    },
    {
      "question": "¿Qué es Code Smell?",
      "options": [
        {
          "text": "Olor a código",
          "isCorrect": false
        },
        {
          "text": "Indicador de posibles problemas en el código",
          "isCorrect": true
        },
        {
          "text": "Código perfecto",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un code smell es una señal de que puede haber un problema de diseño o calidad en el código, aunque aún funcione correctamente."
    },
    {
      "question": "¿Cuáles son ejemplos de Code Smells? (selección múltiple)",
      "options": [
        {
          "text": "Métodos muy largos",
          "isCorrect": false
        },
        {
          "text": "Clases muy grandes",
          "isCorrect": true
        },
        {
          "text": "Código duplicado",
          "isCorrect": true
        },
        {
          "text": "Nombres poco claros",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Clases muy grandes y código duplicado son ejemplos típicos de code smells que señalan oportunidades de refactorización."
    },
    {
      "question": "¿Qué es refactoring?",
      "options": [
        {
          "text": "Una factoría",
          "isCorrect": false
        },
        {
          "text": "Reestructurar código sin cambiar comportamiento externo",
          "isCorrect": true
        },
        {
          "text": "Reescribir todo",
          "isCorrect": false
        },
        {
          "text": "Añadir features",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Refactoring es modificar la estructura interna del código para mejorar su diseño, sin cambiar su comportamiento observado desde fuera."
    },
    {
      "question": "¿Cuándo hacer refactoring? (selección múltiple)",
      "options": [
        {
          "text": "Cuando encuentras code smells",
          "isCorrect": false
        },
        {
          "text": "Antes de añadir nuevas features",
          "isCorrect": true
        },
        {
          "text": "Durante code review",
          "isCorrect": true
        },
        {
          "text": "Nunca",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Es habitual refactorizar antes de añadir nuevas funcionalidades o durante las code reviews, para mantener el diseño limpio a medida que el sistema crece."
    },
    {
      "question": "¿Qué es Test-Driven Development (TDD)?",
      "options": [
        {
          "text": "Desarrollo conducido",
          "isCorrect": false
        },
        {
          "text": "Escribir tests antes que el código",
          "isCorrect": true
        },
        {
          "text": "No escribir tests",
          "isCorrect": false
        },
        {
          "text": "Tests después del código",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En TDD primero se escribe un test que falla, luego el código mínimo para hacerlo pasar y después se mejora el diseño mediante refactorización."
    },
    {
      "question": "¿Cuál es el ciclo de TDD? (selección múltiple)",
      "options": [
        {
          "text": "Red - escribir test que falla",
          "isCorrect": false
        },
        {
          "text": "Green - hacer que pase",
          "isCorrect": true
        },
        {
          "text": "Refactor - mejorar código",
          "isCorrect": true
        },
        {
          "text": "Deploy - desplegar",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "En el ciclo TDD: \"Green\" es la fase donde haces que el test pase, y \"Refactor\" es donde mejoras el código manteniendo todos los tests en verde."
    },
    {
      "question": "¿Qué es Behavior-Driven Development (BDD)?",
      "options": [
        {
          "text": "Desarrollo de comportamiento",
          "isCorrect": false
        },
        {
          "text": "Enfoque que describe comportamiento en lenguaje natural",
          "isCorrect": true
        },
        {
          "text": "Lo mismo que TDD",
          "isCorrect": false
        },
        {
          "text": "No usar tests",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "BDD se centra en describir el comportamiento esperado del sistema en lenguaje cercano al negocio, alineando código, tests y requisitos."
    },
    {
      "question": "¿Qué es un mock en testing?",
      "options": [
        {
          "text": "Una burla",
          "isCorrect": false
        },
        {
          "text": "Objeto simulado para reemplazar dependencias en tests",
          "isCorrect": true
        },
        {
          "text": "Un objeto real",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un mock es un objeto simulado que reemplaza a una dependencia real en un test y permite verificar si se llamaron ciertos métodos o interacciones."
    },
    {
      "question": "¿Qué es un stub en testing?",
      "options": [
        {
          "text": "Un tronco",
          "isCorrect": false
        },
        {
          "text": "Implementación simple que retorna valores predefinidos",
          "isCorrect": true
        },
        {
          "text": "Un mock complejo",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un stub es una implementación muy simple que devuelve datos predefinidos, usada para aislar el código bajo prueba de dependencias externas."
    },
    {
      "question": "¿Qué es un spy en testing?",
      "options": [
        {
          "text": "Un espía",
          "isCorrect": false
        },
        {
          "text": "Registra información sobre llamadas a métodos",
          "isCorrect": true
        },
        {
          "text": "Un mock",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un spy registra información sobre cómo se llamaron los métodos (parámetros, número de llamadas, etc.), útil para verificar comportamientos en tests."
    },
    {
      "question": "¿Diferencia entre mock y stub?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Mock verifica comportamiento, stub solo provee datos",
          "isCorrect": true
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        },
        {
          "text": "Stub es más complejo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un stub solo provee datos de prueba, mientras que un mock además permite verificar las interacciones (por ejemplo, que un método se llamara X veces)."
    },
    {
      "question": "¿Qué es cobertura de código?",
      "options": [
        {
          "text": "Una cobertura",
          "isCorrect": false
        },
        {
          "text": "Porcentaje de código ejecutado por los tests",
          "isCorrect": true
        },
        {
          "text": "Número de tests",
          "isCorrect": false
        },
        {
          "text": "Una métrica de calidad",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La cobertura de código mide qué porcentaje de líneas, ramas o métodos se ejecutan durante los tests, ayudando a detectar partes no probadas."
    },
    {
      "question": "¿Es 100% de cobertura suficiente?",
      "options": [
        {
          "text": "Sí, es perfecto",
          "isCorrect": false
        },
        {
          "text": "No, cobertura no garantiza calidad de tests",
          "isCorrect": true
        },
        {
          "text": "No importa",
          "isCorrect": false
        },
        {
          "text": "Es imposible",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Tener 100% de cobertura no garantiza buenos tests: pueden existir tests poco significativos o que no validen correctamente los casos importantes."
    },
    {
      "question": "¿Qué es integration testing?",
      "options": [
        {
          "text": "Testing de integración",
          "isCorrect": false
        },
        {
          "text": "Tests que verifican interacción entre componentes",
          "isCorrect": true
        },
        {
          "text": "Tests unitarios",
          "isCorrect": false
        },
        {
          "text": "No hacer tests",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El integration testing comprueba que varios componentes o módulos funcionan correctamente juntos, incluyendo su interacción con recursos externos."
    },
    {
      "question": "¿Qué es end-to-end testing?",
      "options": [
        {
          "text": "De extremo a extremo",
          "isCorrect": false
        },
        {
          "text": "Tests que verifican flujos completos desde perspectiva del usuario",
          "isCorrect": true
        },
        {
          "text": "Tests unitarios",
          "isCorrect": false
        },
        {
          "text": "Tests de performance",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El end-to-end testing valida flujos completos de la aplicación desde el punto de vista del usuario, atravesando todas las capas implicadas."
    },
    {
      "question": "¿Qué es continuous integration (CI)?",
      "options": [
        {
          "text": "Integración continua",
          "isCorrect": false
        },
        {
          "text": "Práctica de integrar código frecuentemente con tests automáticos",
          "isCorrect": true
        },
        {
          "text": "Integrar una vez al mes",
          "isCorrect": false
        },
        {
          "text": "No integrar",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "CI consiste en integrar cambios en el repositorio principal con frecuencia y ejecutar automáticamente los tests para detectar problemas pronto."
    },
    {
      "question": "¿Qué es continuous deployment (CD)?",
      "options": [
        {
          "text": "Despliegue continuo",
          "isCorrect": false
        },
        {
          "text": "Desplegar automáticamente código que pasa los tests",
          "isCorrect": true
        },
        {
          "text": "Desplegar manualmente",
          "isCorrect": false
        },
        {
          "text": "No desplegar",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "CD busca que el código que pasa los pipelines de CI pueda desplegarse automáticamente (o casi) a entornos superiores con mínima intervención manual."
    },
    {
      "question": "¿Cuáles son herramientas de CI/CD? (selección múltiple)",
      "options": [
        {
          "text": "Jenkins",
          "isCorrect": false
        },
        {
          "text": "GitHub Actions",
          "isCorrect": true
        },
        {
          "text": "GitLab CI",
          "isCorrect": true
        },
        {
          "text": "CircleCI",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "GitHub Actions y GitLab CI son plataformas que permiten definir pipelines automatizados de construcción, test y despliegue de aplicaciones."
    },
    {
      "question": "¿Qué es pair programming?",
      "options": [
        {
          "text": "Programación en pareja",
          "isCorrect": false
        },
        {
          "text": "Dos programadores trabajan juntos en el mismo código",
          "isCorrect": true
        },
        {
          "text": "Programar solo",
          "isCorrect": false
        },
        {
          "text": "Revisar código después",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En pair programming dos desarrolladores trabajan sobre el mismo código, normalmente uno \"escribe\" y el otro revisa y piensa en el diseño."
    },
    {
      "question": "¿Qué es code review?",
      "options": [
        {
          "text": "Revisión de código",
          "isCorrect": false
        },
        {
          "text": "Proceso donde otros revisan cambios antes de fusionarlos",
          "isCorrect": true
        },
        {
          "text": "No revisar código",
          "isCorrect": false
        },
        {
          "text": "Revisar solo en producción",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En un code review otros desarrolladores revisan los cambios antes de integrarlos, detectando errores, mejorando el diseño y compartiendo conocimiento."
    },
    {
      "question": "¿Qué es clean code?",
      "options": [
        {
          "text": "Código limpio",
          "isCorrect": false
        },
        {
          "text": "Código legible, simple y fácil de mantener",
          "isCorrect": true
        },
        {
          "text": "Código complejo",
          "isCorrect": false
        },
        {
          "text": "Código sin comentarios",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Clean code es código fácil de leer, entender y modificar, con nombres claros, responsabilidades bien separadas y pocas sorpresas."
    },
    {
      "question": "¿Cuáles son características de clean code? (selección múltiple)",
      "options": [
        {
          "text": "Nombres descriptivos",
          "isCorrect": false
        },
        {
          "text": "Funciones pequeñas",
          "isCorrect": true
        },
        {
          "text": "Sin duplicación",
          "isCorrect": true
        },
        {
          "text": "Bien testeado",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Funciones pequeñas y ausencia de duplicación son características clave de clean code, porque simplifican la lectura y reducen el riesgo de errores al cambiar el sistema."
    }
  ],
  "docker": [
    {
      "question": "¿Qué es Docker?",
      "options": [
        {
          "text": "Un lenguaje de programación",
          "isCorrect": false
        },
        {
          "text": "Una plataforma para crear, ejecutar y gestionar contenedores",
          "isCorrect": true
        },
        {
          "text": "Un sistema operativo",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Docker es una plataforma que te permite **empaquetar una aplicación y sus dependencias en contenedores**. Con eso podés correr la misma app de forma consistente en distintos entornos (tu máquina, un server, CI/CD). La idea central es: *\"empaqueto una vez, corro igual en todos lados\"*."
    },
    {
      "question": "¿Qué es un contenedor en Docker?",
      "options": [
        {
          "text": "Un archivo comprimido",
          "isCorrect": false
        },
        {
          "text": "Una instancia ejecutable de una imagen con su propio sistema de archivos",
          "isCorrect": true
        },
        {
          "text": "Una máquina virtual",
          "isCorrect": false
        },
        {
          "text": "Un servidor web",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un contenedor es **una instancia en ejecución de una imagen**. Tiene su propio sistema de archivos aislado, procesos, configuración y red lógica, pero comparte el kernel del sistema operativo del host. Es como un \"mini-entorno\" donde vive tu aplicación, liviano y fácil de crear/destruir."
    },
    {
      "question": "¿Qué es una imagen Docker?",
      "options": [
        {
          "text": "Una foto",
          "isCorrect": false
        },
        {
          "text": "Una plantilla de solo lectura para crear contenedores",
          "isCorrect": true
        },
        {
          "text": "Un archivo de logs",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una imagen Docker es una **plantilla de solo lectura** que contiene todo lo necesario para correr una app: código, runtime, librerías y configuración base. De esa imagen se crean contenedores. Se compone de **capas**, lo que permite cache, versionado y reutilización (por ejemplo: `nginx:1.21`)."
    },
    {
      "question": "¿Diferencia entre contenedor y máquina virtual?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Contenedores comparten el kernel del host, VMs tienen SO completo",
          "isCorrect": true
        },
        {
          "text": "VMs son más ligeras",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia clave es que la **máquina virtual tiene un sistema operativo completo**, mientras que el contenedor comparte el kernel del host. Por eso, los contenedores son más livianos, se inician más rápido y consumen menos recursos que una VM, pero siguen ofreciendo aislamiento a nivel de proceso y sistema de archivos."
    },
    {
      "question": "¿Qué comando crea un contenedor desde una imagen?",
      "options": [
        {
          "text": "docker create",
          "isCorrect": false
        },
        {
          "text": "docker run",
          "isCorrect": true
        },
        {
          "text": "docker start",
          "isCorrect": false
        },
        {
          "text": "docker build",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El comando `docker run` **crea y arranca un contenedor a partir de una imagen**. Podés pasarle parámetros como puertos (`-p`), volúmenes (`-v`), nombre (`--name`) o entorno (`-e`). En una sola línea, definís cómo se va a ejecutar tu aplicación dentro del contenedor."
    },
    {
      "question": "¿Qué es un Dockerfile?",
      "options": [
        {
          "text": "Un archivo de texto",
          "isCorrect": false
        },
        {
          "text": "Script con instrucciones para construir una imagen Docker",
          "isCorrect": true
        },
        {
          "text": "Una imagen Docker",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **Dockerfile** es un archivo de texto con **instrucciones paso a paso para construir una imagen**. Ahí definís la imagen base (`FROM`), copiás archivos (`COPY`), instalás dependencias (`RUN`) y configurás el comando por defecto (`CMD` o `ENTRYPOINT`). Es la receta que Docker usa para \"hornear\" la imagen."
    },
    {
      "question": "¿Qué instrucción define la imagen base en Dockerfile?",
      "options": [
        {
          "text": "BASE",
          "isCorrect": false
        },
        {
          "text": "FROM",
          "isCorrect": true
        },
        {
          "text": "IMAGE",
          "isCorrect": false
        },
        {
          "text": "START",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La instrucción `FROM` indica **qué imagen base** se va a usar para construir la nueva imagen. Es siempre la primera línea del Dockerfile (salvo comentarios) y define el punto de partida, por ejemplo: `FROM node:20-alpine` o `FROM ubuntu:22.04`."
    },
    {
      "question": "¿Qué hace RUN en Dockerfile?",
      "options": [
        {
          "text": "docker-compose.yml",
          "isCorrect": true
        },
        {
          "text": "docker.yaml",
          "isCorrect": false
        },
        {
          "text": "compose.json",
          "isCorrect": false
        },
        {
          "text": "services.yml",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`RUN` ejecuta **comandos en el momento de construir la imagen** (build time). Lo típico es usarlo para instalar paquetes, compilar o configurar el entorno: por ejemplo `RUN apt-get update && apt-get install -y curl`. Cada `RUN` crea una nueva capa en la imagen."
    },
    {
      "question": "¿Qué hace CMD en Dockerfile?",
      "options": [
        {
          "text": "Comando de construcción",
          "isCorrect": false
        },
        {
          "text": "Define el comando por defecto al iniciar el contenedor",
          "isCorrect": true
        },
        {
          "text": "Copia archivos",
          "isCorrect": false
        },
        {
          "text": "Instala paquetes",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CMD` define **el comando por defecto que se ejecutará cuando arranque el contenedor** si no se especifica otro en `docker run`. Por ejemplo, `CMD [\"npm\", \"start\"]`. Solo puede haber un `CMD` efectivo (el último definido) y es fácilmente sobrescribible desde la línea de comandos."
    },
    {
      "question": "¿Diferencia entre CMD y ENTRYPOINT?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "ENTRYPOINT no se puede sobrescribir fácilmente, CMD sí",
          "isCorrect": true
        },
        {
          "text": "CMD es más importante",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Tanto `CMD` como `ENTRYPOINT` definen qué se ejecuta al iniciar el contenedor, pero:\n\n* `ENTRYPOINT` fija el **programa principal** (más difícil de cambiar)\n* `CMD` suele usarse como **argumentos por defecto** de ese programa.\n\nEn la práctica, se sobrescribe `CMD` con parámetros en `docker run`, mientras que `ENTRYPOINT` se puede cambiar pero requiere la opción `--entrypoint`."
    },
    {
      "question": "¿Qué hace COPY en Dockerfile?",
      "options": [
        {
          "text": "Copia contenedores",
          "isCorrect": false
        },
        {
          "text": "Copia archivos del host a la imagen",
          "isCorrect": true
        },
        {
          "text": "Duplica imágenes",
          "isCorrect": false
        },
        {
          "text": "Clona repositorios",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`COPY` se usa para **copiar archivos o directorios desde el host (contexto de build) hacia la imagen**. Es directo y predecible: `COPY . /app` copia el contenido actual del proyecto en el directorio `/app` del contenedor. Es la opción recomendada para la mayoría de los casos."
    },
    {
      "question": "¿Qué hace ADD en Dockerfile?",
      "options": [
        {
          "text": "Suma números",
          "isCorrect": false
        },
        {
          "text": "Como COPY pero también extrae archivos comprimidos y soporta URLs",
          "isCorrect": true
        },
        {
          "text": "Añade usuarios",
          "isCorrect": false
        },
        {
          "text": "Instala paquetes",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ADD` funciona parecido a `COPY`, pero con extras: puede **extraer archivos comprimidos** (como `.tar`) directamente en la imagen y también admite **URLs remotas**. Justamente por esas \"magias\" implícitas, se recomienda usar `COPY` para casos normales y `ADD` solo cuando necesitás esos comportamientos."
    },
    {
      "question": "¿Qué hace WORKDIR en Dockerfile?",
      "options": [
        {
          "text": "Trabaja en directorios",
          "isCorrect": false
        },
        {
          "text": "Define el directorio de trabajo para instrucciones siguientes",
          "isCorrect": true
        },
        {
          "text": "Crea carpetas",
          "isCorrect": false
        },
        {
          "text": "Lista directorios",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`WORKDIR` establece el **directorio de trabajo por defecto** dentro de la imagen para las instrucciones siguientes (`RUN`, `CMD`, `ENTRYPOINT`, etc.). Es equivalente a hacer un `cd` permanente dentro del contenedor. Por ejemplo: `WORKDIR /app` y luego `RUN npm install` se ejecuta dentro de `/app`."
    },
    {
      "question": "¿Qué hace EXPOSE en Dockerfile?",
      "options": [
        {
          "text": "Expone secretos",
          "isCorrect": false
        },
        {
          "text": "Documenta qué puertos usa el contenedor",
          "isCorrect": true
        },
        {
          "text": "Abre puertos automáticamente",
          "isCorrect": false
        },
        {
          "text": "Publica la imagen",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`EXPOSE` sirve para **documentar qué puertos escucha el contenedor**. No publica el puerto hacia el host por sí mismo, pero indica la intención (por ejemplo `EXPOSE 3000`). Para exponerlo externamente tenés que usar `-p host:container` en `docker run` o la sección `ports:` en Docker Compose."
    },
    {
      "question": "¿Qué hace ENV en Dockerfile?",
      "options": [
        {
          "text": "Crea entornos",
          "isCorrect": false
        },
        {
          "text": "Define variables de entorno",
          "isCorrect": true
        },
        {
          "text": "Configura el sistema",
          "isCorrect": false
        },
        {
          "text": "Instala dependencias",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ENV` define **variables de entorno** dentro de la imagen/contendor. Estas variables se usarán en tiempo de ejecución, por ejemplo: `ENV NODE_ENV=production`. Son útiles para configurar la app sin cambiar el código (credenciales, modos de ejecución, flags, etc.)."
    },
    {
      "question": "¿Cuáles son capas en Docker? (selección múltiple)",
      "options": [
        {
          "text": "docker system prune",
          "isCorrect": true
        },
        {
          "text": "docker prune",
          "isCorrect": false
        },
        {
          "text": "docker clean",
          "isCorrect": false
        },
        {
          "text": "docker remove unused",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Las imágenes Docker se construyen por **capas inmutables**, y esas capas se **cachean**. Inmutable significa que una vez creada la capa, no se modifica; si cambiás algo, se genera otra capa nueva. El cache permite que, si una instrucción no cambió, Docker reutilice la capa anterior, acelerando muchísimo los builds."
    },
    {
      "question": "¿Qué comando lista las imágenes Docker?",
      "options": [
        {
          "text": "docker images o docker image ls",
          "isCorrect": false
        },
        {
          "text": "docker list images",
          "isCorrect": true
        },
        {
          "text": "docker show images",
          "isCorrect": false
        },
        {
          "text": "docker get images",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La idea de esta pregunta es listar imágenes locales. En Docker, el comando real para eso es `docker images` (o `docker image ls`) y muestra nombre, tag, ID y tamaño de cada imagen. Lo importante es entender que **imágenes = plantillas** a partir de las cuales crear contenedores."
    },
    {
      "question": "¿Qué comando lista contenedores en ejecución?",
      "options": [
        {
          "text": "docker list",
          "isCorrect": false
        },
        {
          "text": "docker ps",
          "isCorrect": true
        },
        {
          "text": "docker containers",
          "isCorrect": false
        },
        {
          "text": "docker show",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker ps` lista **los contenedores que están en ejecución**. Muestra su ID, imagen de origen, comando, estado, puertos expuestos y nombre. Es uno de los comandos básicos para ver qué se está ejecutando en tu entorno Docker en ese momento."
    },
    {
      "question": "¿Cómo ver todos los contenedores (incluso detenidos)?",
      "options": [
        {
          "text": "docker ps --all o docker ps -a",
          "isCorrect": false
        },
        {
          "text": "docker list all",
          "isCorrect": true
        },
        {
          "text": "docker show all",
          "isCorrect": false
        },
        {
          "text": "docker containers all",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La idea de la pregunta es ver **todos los contenedores, incluidos los detenidos**. En la práctica, el comando real es `docker ps -a`. Esto te permite revisar contenedores que ya terminaron, ver sus estados y decidir si querés borrarlos, reiniciarlos o inspeccionarlos."
    },
    {
      "question": "¿Qué comando detiene un contenedor?",
      "options": [
        {
          "text": "docker end",
          "isCorrect": false
        },
        {
          "text": "docker stop <container_id>",
          "isCorrect": true
        },
        {
          "text": "docker kill",
          "isCorrect": false
        },
        {
          "text": "docker terminate",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker stop <container_id>` envía una señal al proceso principal del contenedor para que **se detenga de forma ordenada** (graceful shutdown). Podés usar el ID o el nombre del contenedor. Si el proceso no termina a tiempo, Docker puede forzar el apagado con `docker kill`."
    },
    {
      "question": "¿Qué comando elimina un contenedor?",
      "options": [
        {
          "text": "docker delete",
          "isCorrect": false
        },
        {
          "text": "docker rm <container_id>",
          "isCorrect": true
        },
        {
          "text": "docker remove",
          "isCorrect": false
        },
        {
          "text": "docker erase",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker rm <container_id>` **elimina un contenedor** que ya no necesitás. Normalmente el contenedor debe estar detenido antes de borrarlo, así evitás errores. Es útil para limpiar el entorno y no acumular contenedores viejos que ocupan espacio y ensucian tus listados."
    },
    {
      "question": "¿Qué comando elimina una imagen?",
      "options": [
        {
          "text": "docker delete image",
          "isCorrect": false
        },
        {
          "text": "docker rmi <image_id> o docker image rm",
          "isCorrect": true
        },
        {
          "text": "docker remove image",
          "isCorrect": false
        },
        {
          "text": "docker erase image",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker rmi <image_id>` o `docker image rm` **eliminan una imagen** del sistema. Solo se puede borrar si no está siendo usada por ningún contenedor. Esto ayuda a recuperar espacio en disco y a mantener tu máquina limpia de imágenes antiguas o de pruebas."
    },
    {
      "question": "¿Qué es Docker Hub?",
      "options": [
        {
          "text": "Un centro comercial",
          "isCorrect": false
        },
        {
          "text": "Registro público de imágenes Docker",
          "isCorrect": true
        },
        {
          "text": "Una herramienta de Docker",
          "isCorrect": false
        },
        {
          "text": "Un contenedor especial",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Docker Hub** es un **registro público de imágenes Docker**. Ahí podés buscar imágenes oficiales (nginx, postgres, node, etc.) o subir tus propias imágenes para compartirlas con tu equipo o con la comunidad. Es como el \"GitHub de las imágenes de contenedores\"."
    },
    {
      "question": "¿Cómo descargar una imagen de Docker Hub?",
      "options": [
        {
          "text": "docker download",
          "isCorrect": false
        },
        {
          "text": "docker pull <image_name>",
          "isCorrect": true
        },
        {
          "text": "docker get",
          "isCorrect": false
        },
        {
          "text": "docker fetch",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker pull <image_name>` **descarga una imagen** desde un registro (por defecto, Docker Hub) a tu máquina local. Por ejemplo, `docker pull redis:7` trae la imagen de Redis lista para crear contenedores a partir de ella."
    },
    {
      "question": "¿Cómo subir una imagen a Docker Hub?",
      "options": [
        {
          "text": "docker upload",
          "isCorrect": false
        },
        {
          "text": "docker push <image_name>",
          "isCorrect": true
        },
        {
          "text": "docker send",
          "isCorrect": false
        },
        {
          "text": "docker publish",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker push <image_name>` **sube una imagen** desde tu máquina a un registro como Docker Hub o un registry privado. Es el paso final típico después de hacer `docker build` y `docker tag`, para que otros puedan usar tu imagen."
    },
    {
      "question": "¿Qué es un Docker volume?",
      "options": [
        {
          "text": "Un volumen de sonido",
          "isCorrect": false
        },
        {
          "text": "Mecanismo para persistir datos fuera del contenedor",
          "isCorrect": true
        },
        {
          "text": "Un tipo de imagen",
          "isCorrect": false
        },
        {
          "text": "Un comando",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **Docker volume** es un mecanismo para **persistir datos fuera del ciclo de vida del contenedor**. Aunque el contenedor se elimine, los datos en el volumen permanecen. Esto es clave para bases de datos o cualquier aplicación que no pueda perder información al recrear contenedores."
    },
    {
      "question": "¿Cuáles son tipos de volumes en Docker? (selección múltiple)",
      "options": [
        {
          "text": "Named volumes",
          "isCorrect": false
        },
        {
          "text": "Bind mounts",
          "isCorrect": true
        },
        {
          "text": "tmpfs mounts",
          "isCorrect": true
        },
        {
          "text": "Network volumes",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Docker soporta varios tipos de montajes:\n\n* **Volumes** (gestionados por Docker)\n* **Bind mounts** (carpetas del host montadas en el contenedor)\n* **tmpfs mounts** (en memoria, no en disco)\n\nEn la pregunta se destacan **bind mounts** y **tmpfs**, que son formas muy comunes de compartir datos entre host y contenedor."
    },
    {
      "question": "¿Qué es un bind mount?",
      "options": [
        {
          "text": "Un montaje vinculado",
          "isCorrect": false
        },
        {
          "text": "Monta un directorio del host en el contenedor",
          "isCorrect": true
        },
        {
          "text": "Un tipo de red",
          "isCorrect": false
        },
        {
          "text": "Un comando",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **bind mount** monta **una ruta concreta del host dentro del contenedor**. Los cambios se ven en ambos lados: lo que editás en tu carpeta local se ve dentro del contenedor y viceversa. Es muy útil para desarrollo, porque podés editar código en tu editor y que el contenedor lo use al instante."
    },
    {
      "question": "¿Diferencia entre volume y bind mount?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Volumes son gestionados por Docker, bind mounts apuntan a rutas del host",
          "isCorrect": true
        },
        {
          "text": "Bind mounts son mejores",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia clave:\n\n* Un **volume** es gestionado por Docker y se guarda en rutas internas controladas por Docker.\n* Un **bind mount** apunta a una ruta específica del host que vos elegís.\n\nEn general, para producción se recomiendan **volumes**; para desarrollo, spesso son muy prácticos los **bind mounts**."
    },
    {
      "question": "¿Qué es Docker Compose?",
      "options": [
        {
          "text": "Compositor musical",
          "isCorrect": false
        },
        {
          "text": "Herramienta para definir y ejecutar aplicaciones multi-contenedor",
          "isCorrect": true
        },
        {
          "text": "Un tipo de imagen",
          "isCorrect": false
        },
        {
          "text": "Un comando de Docker",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Docker Compose** es una herramienta para **definir y ejecutar aplicaciones multi-contenedor** usando un archivo YAML. En vez de lanzar cada contenedor a mano, describís servicios, redes y volúmenes en un solo archivo y levantás todo con un comando (`docker-compose up`)."
    },
    {
      "question": "¿Qué archivo usa Docker Compose?",
      "options": [
        {
          "text": "compose.json",
          "isCorrect": false
        },
        {
          "text": "docker-compose.yml o compose.yaml",
          "isCorrect": true
        },
        {
          "text": "docker.config",
          "isCorrect": false
        },
        {
          "text": "compose.xml",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Docker Compose usa archivos como `docker-compose.yml` o `compose.yaml` para describir la aplicación: servicios, imágenes, puertos, volúmenes, redes, variables de entorno, etc. Ese archivo se convierte en la \"fuente de verdad\" de cómo debe correr tu stack."
    },
    {
      "question": "¿Qué comando inicia servicios con Docker Compose?",
      "options": [
        {
          "text": "docker-compose start",
          "isCorrect": false
        },
        {
          "text": "docker-compose up",
          "isCorrect": true
        },
        {
          "text": "docker-compose run",
          "isCorrect": false
        },
        {
          "text": "docker-compose begin",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker-compose up` **inicia todos los servicios definidos** en el archivo de Compose. Puede construir imágenes si hacen falta (`build:`), crear redes, volúmenes y arrancar contenedores en el orden apropiado. Con una sola instrucción levantás todo el entorno."
    },
    {
      "question": "¿Qué comando detiene servicios de Docker Compose?",
      "options": [
        {
          "text": "docker-compose stop",
          "isCorrect": false
        },
        {
          "text": "docker-compose down",
          "isCorrect": true
        },
        {
          "text": "docker-compose end",
          "isCorrect": false
        },
        {
          "text": "Tanto a como b",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker-compose down` **detiene y elimina los contenedores, redes y por defecto las cosas asociadas al stack** (salvo volúmenes persistentes, según flags). Es el complemento de `up`: te permite bajar el entorno completo de forma ordenada y dejar limpio tu sistema."
    },
    {
      "question": "¿Qué es un servicio en Docker Compose?",
      "options": [
        {
          "text": "Un servicio web",
          "isCorrect": false
        },
        {
          "text": "Definición de un contenedor y su configuración",
          "isCorrect": true
        },
        {
          "text": "Un comando",
          "isCorrect": false
        },
        {
          "text": "Un volumen",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En Docker Compose, un **servicio** es la **definición de un contenedor (o conjunto de contenedores) y su configuración**: qué imagen usa, puertos, volúmenes, variables, redes, etc. Por ejemplo, un servicio `db` puede representar una base de datos Postgres dentro de tu stack."
    },
    {
      "question": "¿Qué es depends_on en Docker Compose?",
      "options": [
        {
          "text": "Dependencias de paquetes",
          "isCorrect": false
        },
        {
          "text": "Define orden de inicio de servicios",
          "isCorrect": true
        },
        {
          "text": "Una red",
          "isCorrect": false
        },
        {
          "text": "Un volumen",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`depends_on` en Docker Compose **indica dependencias entre servicios**, es decir, el orden de inicio. Por ejemplo, `web` puede depender de `db` para que primero se levante la base de datos. No garantiza que la app esté \"lista\", solo que el contenedor se inicie antes."
    },
    {
      "question": "¿Qué es una red Docker?",
      "options": [
        {
          "text": "Internet",
          "isCorrect": false
        },
        {
          "text": "Permite comunicación entre contenedores",
          "isCorrect": true
        },
        {
          "text": "Un tipo de imagen",
          "isCorrect": false
        },
        {
          "text": "Un comando",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una **red Docker** permite **que los contenedores se comuniquen entre sí** de forma aislada. Dentro de una red, los contenedores se resuelven por nombre de servicio (DNS interno), lo que simplifica conectar `web`, `db`, `redis`, etc., sin exponerlos necesariamente al host."
    },
    {
      "question": "¿Cuáles son tipos de redes en Docker? (selección múltiple)",
      "options": [
        {
          "text": "bridge (por defecto)",
          "isCorrect": false
        },
        {
          "text": "host",
          "isCorrect": true
        },
        {
          "text": "none",
          "isCorrect": true
        },
        {
          "text": "overlay",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Docker trae varios drivers de red, entre ellos:\n\n* **bridge** (por defecto)\n* **host**\n* **none**\n\nEn la pregunta se resaltan **host** (el contenedor usa directamente la red del host) y **none** (sin red), que son opciones útiles para casos específicos de rendimiento o aislamiento extremo."
    },
    {
      "question": "¿Qué es bridge network?",
      "options": [
        {
          "text": "Un puente",
          "isCorrect": false
        },
        {
          "text": "Red privada donde contenedores pueden comunicarse",
          "isCorrect": true
        },
        {
          "text": "Una conexión externa",
          "isCorrect": false
        },
        {
          "text": "Un volumen",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una **bridge network** es una **red privada creada por Docker** donde los contenedores pueden comunicarse entre ellos usando nombres. Es el modo por defecto: tus contenedores \"ven\" a otros contenedores de la misma red, pero no están expuestos directamente hacia afuera salvo que mapees puertos."
    },
    {
      "question": "¿Qué es host network?",
      "options": [
        {
          "text": "Red del anfitrión",
          "isCorrect": false
        },
        {
          "text": "El contenedor usa directamente la red del host",
          "isCorrect": true
        },
        {
          "text": "Una red privada",
          "isCorrect": false
        },
        {
          "text": "Una red externa",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En **host network**, el contenedor **usa directamente la red del host**, sin NAT ni red virtual intermedia. Esto significa que el contenedor comparte la IP del host y expone sus puertos directamente. Puede mejorar rendimiento de red, pero pierde parte del aislamiento."
    },
    {
      "question": "¿Qué comando crea una red Docker?",
      "options": [
        {
          "text": "docker network new",
          "isCorrect": false
        },
        {
          "text": "docker network create <name>",
          "isCorrect": true
        },
        {
          "text": "docker create network",
          "isCorrect": false
        },
        {
          "text": "docker new network",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker network create <name>` **crea una nueva red Docker**. Luego podés conectar contenedores a esa red (`--network <name>` o vía Docker Compose). Esto te permite separar entornos lógicos (por ejemplo, una red para servicios internos y otra para pruebas) y organizar mejor tu arquitectura."
    },
    {
      "question": "¿Qué comando lista redes Docker?",
      "options": [
        {
          "text": "docker networks",
          "isCorrect": false
        },
        {
          "text": "docker network ls",
          "isCorrect": true
        },
        {
          "text": "docker list networks",
          "isCorrect": false
        },
        {
          "text": "docker show networks",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker network ls` muestra **todas las redes Docker disponibles** en tu sistema. Cada red puede tener contenedores conectados, y Docker las crea automáticamente (por ejemplo `bridge`, `host`, `none`). Es útil para verificar qué redes existen o si tus contenedores están correctamente conectados."
    },
    {
      "question": "¿Qué es un multi-stage build?",
      "options": [
        {
          "text": "Múltiples etapas",
          "isCorrect": false
        },
        {
          "text": "Dockerfile con múltiples FROM para optimizar tamaño final",
          "isCorrect": true
        },
        {
          "text": "Un tipo de red",
          "isCorrect": false
        },
        {
          "text": "Un comando",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **multi-stage build** usa **varios `FROM` dentro de un mismo Dockerfile**. Esto permite separar la etapa de compilación (más pesada) de la etapa final (más liviana). Así, solo copiás lo necesario al contenedor final, reduciendo tamaño y mejorando seguridad."
    },
    {
      "question": "¿Por qué usar multi-stage builds?",
      "options": [
        {
          "text": "Para hacer más grande la imagen",
          "isCorrect": false
        },
        {
          "text": "Para reducir el tamaño eliminando dependencias de construcción",
          "isCorrect": true
        },
        {
          "text": "No tiene sentido",
          "isCorrect": false
        },
        {
          "text": "Para añadir más capas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los **multi-stage builds** reducen el tamaño de las imágenes al **eliminar dependencias de compilación o herramientas temporales**. Por ejemplo, podés compilar una app con Node o Go en una etapa y copiar solo el binario al stage final basado en `alpine`. Resultado: una imagen mucho más chica."
    },
    {
      "question": "¿Qué es .dockerignore?",
      "options": [
        {
          "text": "Un archivo ignorado",
          "isCorrect": false
        },
        {
          "text": "Define archivos que Docker ignora al construir la imagen",
          "isCorrect": true
        },
        {
          "text": "Un comando",
          "isCorrect": false
        },
        {
          "text": "Una configuración",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El archivo `.dockerignore` **excluye archivos y carpetas** del contexto de construcción. Funciona igual que `.gitignore`: evita enviar al build cosas innecesarias como logs, `node_modules` o archivos temporales. Esto acelera la construcción y mantiene las imágenes más limpias."
    },
    {
      "question": "¿Qué hace docker exec?",
      "options": [
        {
          "text": "Ejecuta Docker",
          "isCorrect": false
        },
        {
          "text": "Ejecuta un comando en un contenedor en ejecución",
          "isCorrect": true
        },
        {
          "text": "Ejecuta una imagen",
          "isCorrect": false
        },
        {
          "text": "Crea un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker exec` permite **ejecutar comandos dentro de un contenedor ya en ejecución**. Es útil para inspeccionar procesos o correr tareas puntuales. Por ejemplo: `docker exec -it web bash` abre una terminal interactiva en el contenedor `web`."
    },
    {
      "question": "¿Cómo entrar a un contenedor en ejecución?",
      "options": [
        {
          "text": "docker enter",
          "isCorrect": false
        },
        {
          "text": "docker exec -it <container> /bin/bash",
          "isCorrect": true
        },
        {
          "text": "docker access",
          "isCorrect": false
        },
        {
          "text": "docker login",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker exec -it <container> /bin/bash` abre **una sesión interactiva dentro del contenedor**. Es como \"entrar\" al entorno del contenedor para explorar archivos o probar comandos. Si la imagen no tiene `bash`, podés usar `sh` como alternativa."
    },
    {
      "question": "¿Qué hace docker logs?",
      "options": [
        {
          "text": "Crea logs",
          "isCorrect": false
        },
        {
          "text": "Muestra los logs de un contenedor",
          "isCorrect": true
        },
        {
          "text": "Elimina logs",
          "isCorrect": false
        },
        {
          "text": "Configura logging",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker logs <container>` muestra **los logs de salida estándar (stdout/stderr)** del contenedor. Es esencial para depurar errores, revisar qué está haciendo tu aplicación o integrar con herramientas de monitoreo. Se puede combinar con `-f` para seguir logs en tiempo real."
    },
    {
      "question": "¿Qué es --rm en docker run?",
      "options": [
        {
          "text": "Remove",
          "isCorrect": false
        },
        {
          "text": "Elimina el contenedor automáticamente cuando se detiene",
          "isCorrect": true
        },
        {
          "text": "Reinicia el contenedor",
          "isCorrect": false
        },
        {
          "text": "Renombra el contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La opción `--rm` en `docker run` indica que el contenedor debe **borrarse automáticamente al detenerse**. Es muy práctica para tareas temporales o pruebas, ya que evita acumular contenedores inactivos en tu sistema."
    },
    {
      "question": "¿Qué hace -d en docker run?",
      "options": [
        {
          "text": "Delete",
          "isCorrect": false
        },
        {
          "text": "Ejecuta el contenedor en modo detached (background)",
          "isCorrect": true
        },
        {
          "text": "Debug mode",
          "isCorrect": false
        },
        {
          "text": "Development mode",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El flag `-d` (detached mode) ejecuta el contenedor **en segundo plano**, liberando la terminal. Es ideal para servicios que deben mantenerse corriendo (por ejemplo, un servidor web). Luego podés verlos con `docker ps` o detenerlos con `docker stop`."
    },
    {
      "question": "¿Qué hace -p en docker run?",
      "options": [
        {
          "text": "Password",
          "isCorrect": false
        },
        {
          "text": "Mapea puertos del host al contenedor (host:container)",
          "isCorrect": true
        },
        {
          "text": "Process",
          "isCorrect": false
        },
        {
          "text": "Path",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El flag `-p` mapea **puertos del host al contenedor**, con formato `-p host_port:container_port`. Por ejemplo, `-p 8080:80` expone el puerto 80 del contenedor en el puerto 8080 del host, permitiendo acceder a la app desde el navegador en `localhost:8080`."
    },
    {
      "question": "¿Qué hace -v en docker run?",
      "options": [
        {
          "text": "Version",
          "isCorrect": false
        },
        {
          "text": "Monta un volumen (host:container)",
          "isCorrect": true
        },
        {
          "text": "Verbose",
          "isCorrect": false
        },
        {
          "text": "Virtual",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`-v host_path:container_path` monta un **volumen o carpeta del host** dentro del contenedor. Es esencial para persistir datos o compartir archivos. Por ejemplo, `-v ./data:/var/lib/mysql` mantiene los datos de MySQL aunque se borre el contenedor."
    },
    {
      "question": "¿Qué hace --name en docker run?",
      "options": [
        {
          "text": "Nombra al contenedor",
          "isCorrect": false
        },
        {
          "text": "Asigna un nombre personalizado al contenedor",
          "isCorrect": true
        },
        {
          "text": "Cambia el nombre de la imagen",
          "isCorrect": false
        },
        {
          "text": "Define variables",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`--name` le asigna **un nombre legible al contenedor**, en lugar del ID aleatorio que genera Docker. Esto facilita el manejo diario: podés hacer `docker stop web` en lugar de escribir un hash largo. También ayuda en scripts o cuando varios servicios interactúan."
    },
    {
      "question": "¿Qué hace -e en docker run?",
      "options": [
        {
          "text": "Edit",
          "isCorrect": false
        },
        {
          "text": "Define variables de entorno",
          "isCorrect": true
        },
        {
          "text": "Execute",
          "isCorrect": false
        },
        {
          "text": "Enable",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El flag `-e` permite **definir variables de entorno al ejecutar el contenedor**. Por ejemplo:\n`docker run -e NODE_ENV=production myapp`\n\nEsto configura comportamientos del runtime sin modificar la imagen, ideal para parametrizar entornos (producción, staging, etc.)."
    },
    {
      "question": "¿Qué es Docker Swarm?",
      "options": [
        {
          "text": "Un enjambre",
          "isCorrect": false
        },
        {
          "text": "Orquestador nativo de Docker para clusters",
          "isCorrect": true
        },
        {
          "text": "Un tipo de imagen",
          "isCorrect": false
        },
        {
          "text": "Un comando",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Docker Swarm** es el **orquestador nativo de Docker** que permite administrar clusters de múltiples hosts. Te deja desplegar servicios distribuidos, escalar contenedores y balancear carga sin herramientas externas. Es más simple que Kubernetes, aunque con menos funcionalidades avanzadas."
    },
    {
      "question": "¿Diferencia entre Docker Swarm y Kubernetes?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Swarm es más simple, Kubernetes más complejo y potente",
          "isCorrect": true
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        },
        {
          "text": "Swarm es obsoleto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Docker Swarm** es más simple y directo, ideal para pequeñas infraestructuras; **Kubernetes** es más complejo y potente, pensado para clusters grandes y automatización completa. Ambos gestionan contenedores, pero Kubernetes ofrece más control, plugins y ecosistema."
    },
    {
      "question": "¿Qué es un registry privado de Docker?",
      "options": [
        {
          "text": "Un registro público",
          "isCorrect": false
        },
        {
          "text": "Servidor propio para almacenar imágenes Docker",
          "isCorrect": true
        },
        {
          "text": "Docker Hub",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **registry privado Docker** es un **servidor propio donde almacenás tus imágenes** en lugar de publicarlas en Docker Hub. Permite mantener código interno seguro y controlar acceso. Ejemplo: `harbor`, `GitLab Container Registry` o `AWS ECR`."
    },
    {
      "question": "¿Cuáles son registries populares? (selección múltiple)",
      "options": [
        {
          "text": "Docker Hub",
          "isCorrect": false
        },
        {
          "text": "Amazon ECR",
          "isCorrect": true
        },
        {
          "text": "Google Container Registry",
          "isCorrect": true
        },
        {
          "text": "Azure Container Registry",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los **registries populares** incluyen **Amazon ECR (Elastic Container Registry)**, **Google Container Registry (GCR)** y **GitHub Container Registry**. Todos permiten subir, versionar y controlar acceso a tus imágenes Docker para entornos empresariales o CI/CD."
    },
    {
      "question": "¿Qué es Docker Desktop?",
      "options": [
        {
          "text": "Un escritorio",
          "isCorrect": false
        },
        {
          "text": "Aplicación para usar Docker en Windows/Mac",
          "isCorrect": true
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        },
        {
          "text": "Una imagen",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Docker Desktop** es una aplicación gráfica para **usar Docker en Windows y macOS**. Incluye el motor Docker, una interfaz visual, herramientas CLI y soporte para Kubernetes local. Es la forma más sencilla de empezar con Docker en entornos no Linux."
    },
    {
      "question": "¿Qué es containerd?",
      "options": [
        {
          "text": "Contenedor personalizado",
          "isCorrect": false
        },
        {
          "text": "Runtime de contenedores usado por Docker",
          "isCorrect": true
        },
        {
          "text": "Un comando",
          "isCorrect": false
        },
        {
          "text": "Una imagen",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**containerd** es el **runtime de contenedores** que ejecuta realmente los contenedores debajo de Docker. Es el componente que se encarga de crear, iniciar, detener y administrar contenedores. Kubernetes también puede usar `containerd` directamente sin Docker."
    },
    {
      "question": "¿Qué es OCI?",
      "options": [
        {
          "text": "Una organización",
          "isCorrect": false
        },
        {
          "text": "Open Container Initiative - estándar para contenedores",
          "isCorrect": true
        },
        {
          "text": "Un tipo de imagen",
          "isCorrect": false
        },
        {
          "text": "Un comando",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**OCI (Open Container Initiative)** es un **estándar abierto** que define cómo deben formarse las imágenes y los runtimes de contenedores. Gracias a OCI, cualquier contenedor compatible puede correr en distintas plataformas (Docker, Podman, containerd) sin problemas de compatibilidad."
    },
    {
      "question": "¿Qué comando inspecciona un contenedor?",
      "options": [
        {
          "text": "docker check",
          "isCorrect": false
        },
        {
          "text": "docker inspect <container>",
          "isCorrect": true
        },
        {
          "text": "docker info",
          "isCorrect": false
        },
        {
          "text": "docker details",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker inspect` devuelve **información detallada en formato JSON** sobre un contenedor, imagen, red o volumen. Muestra configuración completa, estado, puertos, variables, montajes, IPs y metadatos. Es útil para debugging y scripts que necesitan información precisa del entorno."
    },
    {
      "question": "¿Qué comando muestra uso de recursos?",
      "options": [
        {
          "text": "docker resources",
          "isCorrect": false
        },
        {
          "text": "docker stats",
          "isCorrect": true
        },
        {
          "text": "docker usage",
          "isCorrect": false
        },
        {
          "text": "docker metrics",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker stats` muestra **estadísticas de uso de recursos en tiempo real** para los contenedores en ejecución: CPU, memoria, I/O de red y disco. Es como un `top` para contenedores, ideal para monitorear rendimiento y detectar cuellos de botella."
    },
    {
      "question": "¿Qué es health check en Docker?",
      "options": [
        {
          "text": "Un chequeo médico",
          "isCorrect": false
        },
        {
          "text": "Verifica el estado de salud de un contenedor",
          "isCorrect": true
        },
        {
          "text": "Un comando",
          "isCorrect": false
        },
        {
          "text": "Un volumen",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **HEALTHCHECK** es una instrucción del Dockerfile que **define cómo verificar que el contenedor funciona correctamente**. Por ejemplo:\n\n```dockerfile\nHEALTHCHECK CMD curl -f http://localhost/ || exit 1\n```\n\nDocker ejecuta este comando periódicamente y marca el contenedor como \"healthy\" o \"unhealthy\"."
    },
    {
      "question": "¿Cómo definir health check en Dockerfile?",
      "options": [
        {
          "text": "HEALTH",
          "isCorrect": false
        },
        {
          "text": "HEALTHCHECK CMD <command>",
          "isCorrect": true
        },
        {
          "text": "CHECK",
          "isCorrect": false
        },
        {
          "text": "STATUS",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker system prune` **limpia recursos no usados**: contenedores detenidos, redes sin usar, imágenes huérfanas y cache de build. Con `-a` elimina también imágenes sin contenedores asociados. Es útil para recuperar espacio en disco rápidamente."
    },
    {
      "question": "¿Qué es docker system prune?",
      "options": [
        {
          "text": "Podar el sistema",
          "isCorrect": false
        },
        {
          "text": "Limpia recursos no usados (contenedores, imágenes, redes)",
          "isCorrect": true
        },
        {
          "text": "Reinicia Docker",
          "isCorrect": false
        },
        {
          "text": "Actualiza Docker",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **build cache** guarda capas de imagen ya construidas para reutilizarlas en builds futuros. Si una instrucción del Dockerfile no cambió, Docker usa la capa cacheada en lugar de reconstruirla. Esto acelera muchísimo el proceso de build."
    },
    {
      "question": "¿Qué hace --no-cache en docker build?",
      "options": [
        {
          "text": "No usa caché",
          "isCorrect": false
        },
        {
          "text": "Construye la imagen sin usar caché de capas",
          "isCorrect": true
        },
        {
          "text": "Elimina caché",
          "isCorrect": false
        },
        {
          "text": "Crea caché",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Tagear una imagen** significa asignarle un nombre y versión legibles usando `docker tag`. Por ejemplo:\n\n```bash\ndocker tag myapp:latest myrepo/myapp:v1.0\n```\n\nEsto facilita identificar versiones y publicar en registries con nombres organizados."
    },
    {
      "question": "¿Qué es una tagged image?",
      "options": [
        {
          "text": "Una imagen etiquetada",
          "isCorrect": false
        },
        {
          "text": "Una imagen con etiqueta de versión (e.g., nginx:1.21)",
          "isCorrect": true
        },
        {
          "text": "Una imagen marcada",
          "isCorrect": false
        },
        {
          "text": "Una imagen especial",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las **imágenes Alpine** son versiones minimalistas de Linux basadas en Alpine Linux (5-10 MB). Son ideales para contenedores porque reducen tamaño, superficie de ataque y tiempo de descarga. Ejemplo: `node:20-alpine` vs `node:20` (diferencia de cientos de MB)."
    },
    {
      "question": "¿Cómo tagear una imagen?",
      "options": [
        {
          "text": "docker tag <image> <name:tag>",
          "isCorrect": false
        },
        {
          "text": "docker label",
          "isCorrect": true
        },
        {
          "text": "docker mark",
          "isCorrect": false
        },
        {
          "text": "docker version",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las **imágenes distroless** no incluyen shell, gestores de paquetes ni utilidades de sistema: solo el runtime necesario. Son más seguras porque reducen drásticamente la superficie de ataque. Google las popularizó para producción con alta seguridad."
    },
    {
      "question": "¿Qué es :latest en Docker?",
      "options": [
        {
          "text": "Lo más reciente",
          "isCorrect": false
        },
        {
          "text": "Tag por defecto que apunta a la última versión",
          "isCorrect": true
        },
        {
          "text": "Una versión específica",
          "isCorrect": false
        },
        {
          "text": "Un comando",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las **dangling images** son **imágenes sin tag** (aparecen como `<none>`). Se generan cuando construís una nueva versión con el mismo nombre, dejando la vieja sin referencia. Se pueden limpiar con `docker image prune`."
    },
    {
      "question": "¿Es recomendable usar :latest en producción?",
      "options": [
        {
          "text": "Sí, siempre",
          "isCorrect": false
        },
        {
          "text": "No, mejor usar tags específicos para reproducibilidad",
          "isCorrect": true
        },
        {
          "text": "Da igual",
          "isCorrect": false
        },
        {
          "text": "Solo en desarrollo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker save` **exporta una imagen completa a un archivo tar**, incluyendo todas sus capas:\n\n```bash\ndocker save myapp > myapp.tar\n```\n\nPodés compartir ese archivo o cargarlo en otro sistema con `docker load`. Es útil para entornos sin acceso a registries."
    },
    {
      "question": "¿Qué es un distroless image?",
      "options": [
        {
          "text": "Sin distribución",
          "isCorrect": false
        },
        {
          "text": "Imagen mínima sin distribución de Linux, solo runtime",
          "isCorrect": true
        },
        {
          "text": "Una imagen completa",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker load` **importa una imagen desde un archivo tar** creado con `docker save`:\n\n```bash\ndocker load < myapp.tar\n```\n\nRestaurea la imagen con todas sus capas y tags, lista para usar."
    },
    {
      "question": "¿Por qué usar imágenes pequeñas? (selección múltiple)",
      "options": [
        {
          "text": "Menor superficie de ataque",
          "isCorrect": false
        },
        {
          "text": "Despliegues más rápidos",
          "isCorrect": true
        },
        {
          "text": "Menos vulnerabilidades",
          "isCorrect": true
        },
        {
          "text": "Ahorro de espacio",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "`docker export` guarda el **filesystem de un contenedor** (no la imagen) en un tar. A diferencia de `save`, no incluye capas ni historial. Se importa con `docker import`. Útil para crear imágenes planas desde contenedores modificados."
    },
    {
      "question": "¿Qué es Alpine Linux en Docker?",
      "options": [
        {
          "text": "Linux de montaña",
          "isCorrect": false
        },
        {
          "text": "Distribución Linux muy ligera popular para imágenes Docker",
          "isCorrect": true
        },
        {
          "text": "Una imagen grande",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker import` crea una **imagen nueva desde un filesystem exportado** con `docker export`. La imagen resultante es \"plana\" (una sola capa) sin historial. Ejemplo:\n\n```bash\ncat container.tar | docker import - myimage:v1\n```"
    },
    {
      "question": "¿Qué es un dangling image?",
      "options": [
        {
          "text": "Imagen colgante",
          "isCorrect": false
        },
        {
          "text": "Imagen sin tag ni referencia de contenedor",
          "isCorrect": true
        },
        {
          "text": "Una imagen en uso",
          "isCorrect": false
        },
        {
          "text": "Una imagen especial",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**ARG** define variables **solo para el build** del Dockerfile (no en runtime). Ejemplo:\n\n```dockerfile\nARG NODE_VERSION=20\nFROM node:$NODE_VERSION\n```\n\n**ENV** define variables que **persisten en el contenedor** en ejecución. ARG para build, ENV para runtime."
    },
    {
      "question": "¿Cómo eliminar dangling images?",
      "options": [
        {
          "text": "docker rmi $(docker images -f \"dangling=true\" -q)",
          "isCorrect": false
        },
        {
          "text": "docker clean",
          "isCorrect": true
        },
        {
          "text": "docker remove all",
          "isCorrect": false
        },
        {
          "text": "No se puede",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **Docker context** permite **cambiar entre distintos entornos Docker** (local, remoto, cloud) sin reconfigurar. Por ejemplo, podés tener un context para tu máquina local y otro para un servidor remoto, y cambiar con `docker context use`."
    },
    {
      "question": "¿Qué es docker commit?",
      "options": [
        {
          "text": "Confirmar cambios",
          "isCorrect": false
        },
        {
          "text": "Crea una nueva imagen desde cambios en un contenedor",
          "isCorrect": true
        },
        {
          "text": "Guarda logs",
          "isCorrect": false
        },
        {
          "text": "Actualiza imagen",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**BuildKit** es el **motor de build moderno de Docker** (activado por defecto desde Docker 23+). Ofrece builds más rápidos, mejor cache, paralelización automática y nuevas features como secretos seguros y multi-plataforma. Es más eficiente que el builder clásico."
    },
    {
      "question": "¿Es recomendable usar docker commit?",
      "options": [
        {
          "text": "Sí, siempre",
          "isCorrect": false
        },
        {
          "text": "No, mejor usar Dockerfile para reproducibilidad",
          "isCorrect": true
        },
        {
          "text": "Solo en producción",
          "isCorrect": false
        },
        {
          "text": "Es obligatorio",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker build` **construye una imagen a partir de un Dockerfile**:\n\n```bash\ndocker build -t myapp:v1 .\n```\n\nEl `.` indica el contexto (carpeta con archivos a enviar al build). `-t` asigna nombre y tag a la imagen resultante."
    },
    {
      "question": "¿Qué hace docker save?",
      "options": [
        {
          "text": "Guarda configuración",
          "isCorrect": false
        },
        {
          "text": "Exporta imagen(es) a un archivo tar",
          "isCorrect": true
        },
        {
          "text": "Guarda logs",
          "isCorrect": false
        },
        {
          "text": "Hace backup",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker commit` **crea una imagen nueva desde un contenedor modificado**, guardando todos los cambios realizados. Ejemplo:\n\n```bash\ndocker commit mycontainer mynewimage:v1\n```\n\nNo es recomendable para producción (mejor usar Dockerfile), pero es útil para experimentación."
    },
    {
      "question": "¿Qué hace docker load?",
      "options": [
        {
          "text": "Carga el sistema",
          "isCorrect": false
        },
        {
          "text": "Importa imagen desde un archivo tar",
          "isCorrect": true
        },
        {
          "text": "Carga configuración",
          "isCorrect": false
        },
        {
          "text": "Inicia Docker",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker diff` muestra **qué archivos cambiaron en un contenedor** respecto a su imagen base. Lista archivos añadidos (A), modificados (C) o eliminados (D). Es útil para debugging o entender qué modificó un proceso dentro del contenedor."
    },
    {
      "question": "¿Qué hace docker export?",
      "options": [
        {
          "text": "Exporta todo",
          "isCorrect": false
        },
        {
          "text": "Exporta el filesystem de un contenedor a tar",
          "isCorrect": true
        },
        {
          "text": "Exporta imágenes",
          "isCorrect": false
        },
        {
          "text": "Exporta logs",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker cp` **copia archivos entre el host y un contenedor**:\n\n```bash\ndocker cp mycontainer:/app/log.txt ./log.txt\ndocker cp ./config.json mycontainer:/app/\n```\n\nÚtil para extraer logs, subir configuración o rescatar datos sin montar volúmenes."
    },
    {
      "question": "¿Qué hace docker import?",
      "options": [
        {
          "text": "Importa todo",
          "isCorrect": false
        },
        {
          "text": "Crea imagen desde un tarball exportado",
          "isCorrect": true
        },
        {
          "text": "Importa contenedores",
          "isCorrect": false
        },
        {
          "text": "Importa configuración",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker pause` **congela todos los procesos de un contenedor** usando cgroups, sin detenerlo completamente. El contenedor sigue existiendo pero no consume CPU. Se reactiva con `docker unpause`. Útil para liberar recursos temporalmente."
    },
    {
      "question": "¿Diferencia entre save/load y export/import?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "save/load preservan capas e historial, export/import no",
          "isCorrect": true
        },
        {
          "text": "export/import son mejores",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker unpause` **reactiva un contenedor pausado**, reanudando todos sus procesos desde donde quedaron. Es el complemento de `docker pause` y permite \"descongelar\" contenedores sin reiniciarlos."
    },
    {
      "question": "¿Qué son build arguments (ARG)?",
      "options": [
        {
          "text": "Argumentos de construcción",
          "isCorrect": false
        },
        {
          "text": "Variables disponibles solo durante la construcción de la imagen",
          "isCorrect": true
        },
        {
          "text": "Variables de entorno",
          "isCorrect": false
        },
        {
          "text": "Parámetros de ejecución",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker rename` **cambia el nombre de un contenedor**:\n\n```bash\ndocker rename oldname newname\n```\n\nNo afecta la ejecución ni los datos, solo actualiza el identificador legible. Útil para organizar mejor los nombres después de crear contenedores."
    },
    {
      "question": "¿Diferencia entre ARG y ENV?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "ARG solo en build time, ENV disponible en runtime",
          "isCorrect": true
        },
        {
          "text": "ENV es mejor",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker top` muestra los **procesos corriendo dentro de un contenedor**:\n\n```bash\ndocker top mycontainer\n```\n\nEs equivalente a ejecutar `ps` dentro del contenedor, pero sin necesidad de abrir una shell. Útil para inspección rápida."
    },
    {
      "question": "¿Qué es docker context?",
      "options": [
        {
          "text": "Contexto de código",
          "isCorrect": false
        },
        {
          "text": "Configuración para conectarse a diferentes demonios Docker",
          "isCorrect": true
        },
        {
          "text": "Un directorio",
          "isCorrect": false
        },
        {
          "text": "Un comando",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker wait` **bloquea hasta que un contenedor se detenga** y luego retorna su exit code:\n\n```bash\ndocker wait mycontainer\n```\n\nÚtil en scripts cuando necesitás esperar que un contenedor termine antes de continuar."
    },
    {
      "question": "¿Qué es BuildKit?",
      "options": [
        {
          "text": "Un kit de construcción",
          "isCorrect": false
        },
        {
          "text": "Motor mejorado de construcción de Docker con mejor cache y paralelización",
          "isCorrect": true
        },
        {
          "text": "Una herramienta externa",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker attach` **conecta tu terminal a un contenedor en ejecución**, mostrando su stdout/stderr y permitiendo enviar input. A diferencia de `exec`, no crea un nuevo proceso: te conectás al proceso principal (PID 1). Salir con Ctrl+C puede detener el contenedor."
    },
    {
      "question": "¿Cómo habilitar BuildKit?",
      "options": [
        {
          "text": "DOCKER_BUILDKIT=1",
          "isCorrect": false
        },
        {
          "text": "--buildkit",
          "isCorrect": true
        },
        {
          "text": "buildkit enable",
          "isCorrect": false
        },
        {
          "text": "No se puede",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker events` muestra **eventos en tiempo real del daemon Docker**: contenedores iniciando/deteniéndose, imágenes descargadas, redes creadas, etc. Es útil para monitoreo, debugging o integración con herramientas de auditoría:\n\n```bash\ndocker events --filter type=container\n```"
    },
    {
      "question": "¿Cuáles son beneficios de BuildKit? (selección múltiple)",
      "options": [
        {
          "text": "Builds paralelos",
          "isCorrect": false
        },
        {
          "text": "Mejor caché",
          "isCorrect": true
        },
        {
          "text": "Build secrets",
          "isCorrect": true
        },
        {
          "text": "Más lento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "`docker history` muestra el **historial de capas de una imagen**, con el comando que generó cada capa y su tamaño:\n\n```bash\ndocker history myimage:v1\n```\n\nEs útil para entender cómo se construyó una imagen, optimizar tamaños o auditar el proceso de build."
    }
  ],
  "aws": [
    {
      "question": "¿Qué es AWS?",
      "options": [
        {
          "text": "Un software",
          "isCorrect": false
        },
        {
          "text": "Plataforma de servicios en la nube de Amazon",
          "isCorrect": true
        },
        {
          "text": "Un lenguaje de programación",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "AWS (Amazon Web Services) es la plataforma de servicios en la nube más completa y utilizada del mundo, lanzada en 2006. Ofrece más de 200 servicios que incluyen cómputo (EC2), almacenamiento (S3), bases de datos (RDS, DynamoDB), redes (VPC), machine learning (SageMaker), y muchos más. AWS permite escalar aplicaciones globalmente, pagar solo por lo que usas y eliminar la necesidad de mantener infraestructura física propia."
    },
    {
      "question": "¿Qué es EC2?",
      "options": [
        {
          "text": "Un protocolo",
          "isCorrect": false
        },
        {
          "text": "Elastic Compute Cloud - servicio de máquinas virtuales",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "EC2 (Elastic Compute Cloud) es el servicio de máquinas virtuales de AWS. Permite crear y gestionar servidores virtuales (instancias) con diferentes capacidades de CPU, memoria y almacenamiento. Puedes elegir entre cientos de tipos de instancia optimizados para diferentes casos de uso: cómputo general (t3), procesamiento intensivo (c5), memoria (r5), GPU (p3), etc. Pagas solo por el tiempo de uso y puedes escalar vertical u horizontalmente según la demanda."
    },
    {
      "question": "¿Qué es S3?",
      "options": [
        {
          "text": "Amazon EC2 (Elastic Compute Cloud)",
          "isCorrect": true
        },
        {
          "text": "Elastic Beanstalk",
          "isCorrect": false
        },
        {
          "text": "Lambda",
          "isCorrect": false
        },
        {
          "text": "S3",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "S3 (Simple Storage Service) es el servicio de almacenamiento de objetos de AWS. Permite guardar cualquier tipo de archivo (imágenes, videos, backups, logs, data lakes) con durabilidad del 99.999999999% (11 nueves). Los datos se organizan en 'buckets' y se acceden mediante URLs o APIs. S3 ofrece diferentes clases de almacenamiento según frecuencia de acceso (Standard, Infrequent Access, Glacier) para optimizar costos. Es la base de muchas arquitecturas cloud."
    },
    {
      "question": "¿Qué es RDS?",
      "options": [
        {
          "text": "Un protocolo",
          "isCorrect": false
        },
        {
          "text": "Relational Database Service - bases de datos relacionales gestionadas",
          "isCorrect": true
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "RDS (Relational Database Service) gestiona bases de datos relacionales en la nube de forma automática. Soporta múltiples motores: MySQL, PostgreSQL, MariaDB, Oracle, SQL Server y Aurora (versión optimizada de AWS). RDS automatiza tareas operativas como backups diarios, parches de seguridad, replicación multi-AZ para alta disponibilidad, y escalado de recursos. Elimina la necesidad de administrar servidores de base de datos manualmente."
    },
    {
      "question": "¿Qué es Lambda?",
      "options": [
        {
          "text": "Una función matemática",
          "isCorrect": false
        },
        {
          "text": "Servicio de computación serverless que ejecuta código sin servidores",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "AWS Lambda es el servicio de computación serverless que ejecuta código sin necesidad de gestionar servidores. Subes tu código (Node.js, Python, Java, Go, etc.) y Lambda lo ejecuta en respuesta a eventos: solicitudes HTTP (API Gateway), cambios en S3, mensajes en SQS, etc. Escala automáticamente de 0 a miles de ejecuciones concurrentes y solo pagas por el tiempo de ejecución (milisegundos). Es ideal para microservicios, procesamiento de eventos y automatizaciones."
    },
    {
      "question": "¿Cuáles son características de Lambda? (selección múltiple)",
      "options": [
        {
          "text": "S3 (Simple Storage Service)",
          "isCorrect": true
        },
        {
          "text": "EC2",
          "isCorrect": false
        },
        {
          "text": "RDS",
          "isCorrect": false
        },
        {
          "text": "EBS",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Las principales características de Lambda son: 1) Auto-escalable: maneja automáticamente desde 1 hasta miles de solicitudes concurrentes. 2) Sin gestión de servidores: no configuras ni mantienes instancias, AWS gestiona toda la infraestructura. 3) Pago por uso: solo se cobra por el tiempo de ejecución real. 4) Event-driven: se activa automáticamente por eventos de otros servicios AWS. Es la base de arquitecturas serverless modernas."
    },
    {
      "question": "¿Qué es VPC?",
      "options": [
        {
          "text": "Un protocolo",
          "isCorrect": false
        },
        {
          "text": "Virtual Private Cloud - red virtual aislada",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "VPC (Virtual Private Cloud) es una red virtual privada y aislada dentro de AWS donde lanzas recursos. Funciona como tu propia red en la nube con control total sobre IPs, subredes, tablas de rutas y gateways. Puedes crear subredes públicas (con acceso a internet) y privadas (sin acceso directo), configurar security groups y NACLs para controlar tráfico, y conectar la VPC a tu red on-premise mediante VPN o Direct Connect."
    },
    {
      "question": "¿Qué es IAM?",
      "options": [
        {
          "text": "Un protocolo",
          "isCorrect": false
        },
        {
          "text": "Identity and Access Management - gestión de permisos y usuarios",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "IAM (Identity and Access Management) gestiona la autenticación y autorización en AWS. Permite crear usuarios, grupos, roles y políticas para controlar quién puede acceder a qué recursos. IAM sigue el principio de mínimo privilegio: otorgar solo los permisos necesarios. Es fundamental para seguridad: permite MFA, rotación de credenciales, auditoría de accesos y federación con sistemas externos (SAML, OIDC)."
    },
    {
      "question": "¿Qué son las políticas (policies) en IAM?",
      "options": [
        {
          "text": "Reglas de negocio",
          "isCorrect": false
        },
        {
          "text": "Documentos JSON que definen permisos",
          "isCorrect": true
        },
        {
          "text": "Archivos de configuración",
          "isCorrect": false
        },
        {
          "text": "Scripts",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las políticas (policies) en IAM son documentos JSON que definen permisos específicos. Especifican qué acciones (Effect: Allow/Deny) se permiten sobre qué recursos (Resource) y bajo qué condiciones (Condition). Ejemplo: permitir s3:GetObject solo en un bucket específico. Las políticas se pueden adjuntar a usuarios, grupos o roles. AWS también ofrece políticas predefinidas (managed policies) para casos comunes."
    },
    {
      "question": "¿Qué es un rol de IAM?",
      "options": [
        {
          "text": "Un servicio de computación serverless que ejecuta código sin aprovisionar servidores",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servicio de contenedores",
          "isCorrect": false
        },
        {
          "text": "Un balanceador de carga",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un rol de IAM es una identidad con permisos específicos que puede ser asumida temporalmente por servicios o usuarios. A diferencia de usuarios (credenciales permanentes), los roles generan credenciales temporales y rotativas. Se usan principalmente para: 1) Dar permisos a servicios AWS (ej: Lambda accediendo a S3). 2) Acceso cross-account entre cuentas AWS. 3) Federación con proveedores externos (Google, Facebook). Los roles son más seguros que credenciales estáticas."
    },
    {
      "question": "¿Diferencia entre usuario y rol IAM?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Usuarios son permanentes, roles son asumidos temporalmente",
          "isCorrect": true
        },
        {
          "text": "Roles son mejores",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia clave es: Usuarios IAM tienen credenciales permanentes (access key/secret key) y representan identidades de larga duración (personas o aplicaciones). Roles IAM se asumen temporalmente y generan credenciales que expiran automáticamente. Los roles son más seguros porque las credenciales rotan, no se almacenan en el código y permiten delegar acceso sin compartir claves. Siempre que sea posible, usa roles en lugar de usuarios."
    },
    {
      "question": "¿Qué es CloudWatch?",
      "options": [
        {
          "text": "Un reloj",
          "isCorrect": false
        },
        {
          "text": "Servicio de monitoreo y observabilidad",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "CloudWatch es el servicio de monitoreo y observabilidad de AWS. Recopila y visualiza métricas (CPU, memoria, tráfico de red), logs de aplicaciones y eventos de servicios AWS. Permite crear dashboards personalizados, configurar alarmas que ejecuten acciones automáticas (como escalar instancias) y analizar logs con CloudWatch Logs Insights. Es esencial para mantener visibilidad sobre la salud y rendimiento de infraestructura cloud."
    },
    {
      "question": "¿Qué métricas puede monitorear CloudWatch? (selección múltiple)",
      "options": [
        {
          "text": "CPU usage",
          "isCorrect": false
        },
        {
          "text": "Memoria",
          "isCorrect": true
        },
        {
          "text": "Logs de aplicación",
          "isCorrect": true
        },
        {
          "text": "Tráfico de red",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "CloudWatch puede monitorear: 1) Métricas de sistema: CPU, disco, red (por defecto en EC2). 2) Memoria y procesos: mediante CloudWatch Agent instalado en instancias. 3) Logs de aplicación: captura logs de apps, Lambda, containers, etc. 4) Métricas personalizadas: puedes enviar tus propias métricas desde código. 5) Eventos y alarmas: detecta cambios en recursos y dispara notificaciones o automatizaciones."
    },
    {
      "question": "¿Qué es CloudFormation?",
      "options": [
        {
          "text": "Formación de nubes",
          "isCorrect": false
        },
        {
          "text": "Servicio de infraestructura como código (IaC)",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "CloudFormation es el servicio de infraestructura como código (IaC) de AWS. Permite definir recursos AWS (EC2, S3, RDS, etc.) en plantillas declarativas (YAML o JSON) y desplegar toda la infraestructura de forma automática, repetible y versionable. CloudFormation gestiona dependencias, orden de creación y rollbacks en caso de error. Es fundamental para automatizar despliegues, mantener entornos consistentes y aplicar DevOps/GitOps."
    },
    {
      "question": "¿Qué formato usa CloudFormation?",
      "options": [
        {
          "text": "JSON o YAML",
          "isCorrect": false
        },
        {
          "text": "XML",
          "isCorrect": true
        },
        {
          "text": "INI",
          "isCorrect": false
        },
        {
          "text": "TXT",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "CloudFormation usa formatos YAML o JSON (no XML) para definir plantillas. YAML es más legible y popular. Las plantillas describen recursos, sus propiedades, dependencias y outputs. Ejemplo: definir una instancia EC2, su security group, VPC y RDS en un solo archivo que se despliega con un comando. Esto garantiza infraestructura reproducible y elimina configuraciones manuales propensas a errores."
    },
    {
      "question": "¿Qué es un stack en CloudFormation?",
      "options": [
        {
          "text": "Una pila de archivos",
          "isCorrect": false
        },
        {
          "text": "Colección de recursos AWS gestionados como unidad",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Una función",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un stack en CloudFormation es una colección de recursos AWS gestionados como una unidad. Cuando creas un stack desde una plantilla, CloudFormation provisiona todos los recursos definidos: instancias, redes, bases de datos, etc. Puedes actualizar el stack modificando la plantilla, y CloudFormation aplicará solo los cambios necesarios. Si eliminas el stack, todos sus recursos se borran automáticamente. Los stacks facilitan gestionar entornos completos (dev, staging, prod)."
    },
    {
      "question": "¿Qué es EBS?",
      "options": [
        {
          "text": "Un protocolo",
          "isCorrect": false
        },
        {
          "text": "Elastic Block Store - almacenamiento de bloques para EC2",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servicio web",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "EBS (Elastic Block Store) proporciona almacenamiento de bloques persistente para instancias EC2. Funciona como un disco duro virtual que se conecta a una instancia y persiste independientemente de su ciclo de vida. Ofrece diferentes tipos según rendimiento: gp3 (uso general), io2 (alto IOPS para bases de datos), st1 (throughput para Big Data). Los volúmenes EBS se pueden hacer snapshots para backups, cambiar de tamaño en caliente y migrar entre availability zones."
    },
    {
      "question": "¿Diferencia entre EBS y S3?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "EBS es almacenamiento de bloques (para EC2), S3 es almacenamiento de objetos",
          "isCorrect": true
        },
        {
          "text": "S3 es más rápido",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "EBS y S3 son tipos de almacenamiento diferentes: EBS es almacenamiento de bloques para EC2, funciona como un disco conectado a una instancia, ideal para sistemas operativos y bases de datos (acceso rápido, archivos estructurados). S3 es almacenamiento de objetos accesible vía HTTP/API, ideal para archivos estáticos, backups y data lakes (alta durabilidad, acceso desde cualquier lugar). EBS se vincula a una AZ, S3 es global y multi-AZ automáticamente."
    },
    {
      "question": "¿Qué es EFS?",
      "options": [
        {
          "text": "Un protocolo",
          "isCorrect": false
        },
        {
          "text": "Elastic File System - sistema de archivos compartido",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "EFS (Elastic File System) es un sistema de archivos compartido y elástico compatible con NFS. Permite que múltiples instancias EC2 accedan simultáneamente a los mismos datos, como un disco de red compartido. EFS escala automáticamente (crece y decrece según uso) y ofrece almacenamiento persistente multi-AZ por defecto. Es ideal para aplicaciones que requieren almacenamiento compartido: servidores web, content management, data science, o contenedores que comparten datos."
    },
    {
      "question": "¿Qué es Elastic Load Balancer (ELB)?",
      "options": [
        {
          "text": "Un balanceador",
          "isCorrect": false
        },
        {
          "text": "Distribuye tráfico automáticamente entre múltiples destinos",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Elastic Load Balancer (ELB) distribuye automáticamente el tráfico entrante entre múltiples destinos (EC2, containers, IPs, Lambda). Mejora la disponibilidad y tolerancia a fallos: si un servidor falla, ELB redirige el tráfico a servidores sanos. También escala automáticamente según la carga. Monitorea la salud de los destinos mediante health checks y solo envía tráfico a los que responden correctamente."
    },
    {
      "question": "¿Cuáles son tipos de ELB? (selección múltiple)",
      "options": [
        {
          "text": "Application Load Balancer (ALB)",
          "isCorrect": false
        },
        {
          "text": "Network Load Balancer (NLB)",
          "isCorrect": true
        },
        {
          "text": "Classic Load Balancer (CLB)",
          "isCorrect": true
        },
        {
          "text": "Gateway Load Balancer",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "AWS ofrece tres tipos de ELB: 1) Application Load Balancer (ALB): capa 7 (HTTP/HTTPS), enruta por path, host o headers. Ideal para microservicios y contenedores. 2) Network Load Balancer (NLB): capa 4 (TCP/UDP), ultra baja latencia y alto throughput. Ideal para aplicaciones de alto rendimiento. 3) Classic Load Balancer (CLB): versión anterior, balanceo básico de capa 4 y 7 (legacy). ALB y NLB son las opciones modernas recomendadas."
    },
    {
      "question": "¿Qué es Auto Scaling?",
      "options": [
        {
          "text": "Escala automática",
          "isCorrect": false
        },
        {
          "text": "Ajusta automáticamente la capacidad de recursos",
          "isCorrect": true
        },
        {
          "text": "Un servicio de base de datos",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Auto Scaling ajusta automáticamente la cantidad de recursos (instancias EC2, contenedores) según la demanda. Define políticas basadas en métricas (CPU, tráfico, custom) que aumentan o disminuyen la capacidad. Por ejemplo: si CPU > 70%, agregar 2 instancias; si CPU < 30%, quitar 1. Auto Scaling garantiza rendimiento durante picos de tráfico y reduce costos durante períodos de baja demanda. Funciona integrado con ELB y CloudWatch."
    },
    {
      "question": "¿Qué es Route 53?",
      "options": [
        {
          "text": "Una ruta",
          "isCorrect": false
        },
        {
          "text": "Servicio de DNS gestionado",
          "isCorrect": true
        },
        {
          "text": "Un balanceador",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Route 53 es el servicio de DNS gestionado de AWS. Traduce nombres de dominio (ejemplo.com) a direcciones IP de recursos AWS o externos. Ofrece: 1) Registro de dominios. 2) Routing policies: simple, weighted, latency-based, geolocation, failover. 3) Health checks y failover automático. 4) Alta disponibilidad (100% SLA). 5) Integración con otros servicios AWS. Es fundamental para arquitecturas globales y multi-región."
    },
    {
      "question": "¿Qué es DynamoDB?",
      "options": [
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Base de datos NoSQL de clave-valor totalmente gestionada",
          "isCorrect": true
        },
        {
          "text": "Una base de datos SQL",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "DynamoDB es una base de datos NoSQL de clave-valor y documentos, totalmente gestionada y serverless. Ofrece latencia de milisegundos a cualquier escala, escalado automático, replicación multi-región y backup continuo. Se usa con un modelo de datos flexible (sin esquema fijo) ideal para aplicaciones móviles, gaming, IoT y microservicios que requieren alto rendimiento y baja latencia. Soporta transacciones ACID y streaming de cambios con DynamoDB Streams."
    },
    {
      "question": "¿Qué es ElastiCache?",
      "options": [
        {
          "text": "Una caché",
          "isCorrect": false
        },
        {
          "text": "Servicio de caché en memoria (Redis/Memcached)",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ElastiCache es un servicio de caché en memoria totalmente gestionado que soporta Redis y Memcached. Acelera aplicaciones almacenando datos frecuentemente accedidos en memoria (latencia de microsegundos). Casos de uso: cache de sesiones de usuario, resultados de consultas SQL, páginas web renderizadas, leaderboards en gaming. ElastiCache automatiza tareas operativas: parches, backups, replicación y failover, eliminando la complejidad de gestionar clusters de cache manualmente."
    },
    {
      "question": "¿Qué es SNS?",
      "options": [
        {
          "text": "Una red social",
          "isCorrect": false
        },
        {
          "text": "Simple Notification Service - servicio de mensajería pub/sub",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "SNS (Simple Notification Service) es un servicio de mensajería pub/sub (publicar/suscribir) completamente gestionado. Los publishers envían mensajes a topics, y múltiples subscribers reciben esos mensajes simultáneamente. Los subscribers pueden ser: email, SMS, HTTP endpoints, funciones Lambda, colas SQS, notificaciones móviles push. SNS es ideal para notificaciones, alertas y fan-out (enviar el mismo mensaje a múltiples destinos). Es push: SNS envía activamente a los subscribers."
    },
    {
      "question": "¿Qué es SQS?",
      "options": [
        {
          "text": "Una consulta SQL",
          "isCorrect": false
        },
        {
          "text": "Simple Queue Service - servicio de colas de mensajes",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "SQS (Simple Queue Service) es un servicio de colas de mensajes totalmente gestionado. Funciona como buffer entre productores y consumidores de mensajes, desacoplando componentes de aplicaciones distribuidas. Los mensajes se almacenan en la cola hasta que un consumidor los procesa y elimina. SQS garantiza entrega de mensajes, soporta procesamiento en paralelo y tiene dos tipos: Standard (mejor rendimiento, orden no garantizado) y FIFO (orden estricto, exactamente una vez)."
    },
    {
      "question": "¿Diferencia entre SNS y SQS?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "SNS es pub/sub push, SQS es cola pull",
          "isCorrect": true
        },
        {
          "text": "SQS es mejor",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia principal es el modelo de comunicación: SNS es pub/sub push (un mensaje se envía a múltiples subscribers simultáneamente, SNS los empuja activamente). SQS es cola pull (mensajes esperan en la cola, los consumidores los extraen cuando están listos). Usa SNS para notificaciones y fan-out. Usa SQS para desacoplar componentes, procesar trabajos en background y garantizar entrega confiable. A menudo se combinan: SNS envía a múltiples colas SQS."
    },
    {
      "question": "¿Qué es CloudFront?",
      "options": [
        {
          "text": "Un frente de nubes",
          "isCorrect": false
        },
        {
          "text": "Content Delivery Network (CDN) global",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "CloudFront es la CDN (Content Delivery Network) global de AWS con más de 400 edge locations. Distribuye contenido (imágenes, videos, APIs, aplicaciones web) desde ubicaciones cercanas al usuario final, reduciendo latencia. CloudFront cachea contenido en edge locations y lo sirve rápidamente. Se integra con S3, EC2, Lambda@Edge (ejecutar código en el edge) y ofrece protección DDoS integrada. Es esencial para aplicaciones globales de alto rendimiento."
    },
    {
      "question": "¿Qué es API Gateway?",
      "options": [
        {
          "text": "Una puerta",
          "isCorrect": false
        },
        {
          "text": "Servicio para crear, publicar y gestionar APIs",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor web",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "API Gateway es un servicio para crear, publicar y gestionar APIs RESTful, HTTP y WebSocket a cualquier escala. Actúa como puerta de entrada para aplicaciones: recibe requests, los valida, aplica autenticación/autorización, transforma datos y los enruta a backends (Lambda, EC2, servicios externos). Ofrece features como throttling, caching, logging, CORS, stages (dev/prod) y generación automática de documentación. Es la capa frontal estándar para APIs serverless."
    },
    {
      "question": "¿Qué protocolos soporta API Gateway? (selección múltiple)",
      "options": [
        {
          "text": "REST",
          "isCorrect": false
        },
        {
          "text": "HTTP",
          "isCorrect": true
        },
        {
          "text": "WebSocket",
          "isCorrect": true
        },
        {
          "text": "FTP",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "API Gateway soporta múltiples protocolos: 1) REST API: APIs RESTful completas con recursos, métodos y caching. 2) HTTP API: versión simplificada y más económica, ideal para proxies simples a Lambda. 3) WebSocket API: comunicación bidireccional en tiempo real, ideal para chats, gaming, dashboards en vivo. Cada tipo se optimiza para diferentes casos de uso y modelos de pricing."
    },
    {
      "question": "¿Qué es Cognito?",
      "options": [
        {
          "text": "Cognición",
          "isCorrect": false
        },
        {
          "text": "Servicio de autenticación y autorización de usuarios",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Cognito es el servicio de autenticación y autorización de usuarios para aplicaciones web y móviles. Ofrece: 1) User Pools: directorio de usuarios con registro, login, MFA, recuperación de contraseña. 2) Identity Pools: proporciona credenciales AWS temporales para acceder a recursos. 3) Federación: login con proveedores externos (Google, Facebook, SAML). Cognito elimina la necesidad de construir sistemas de auth propios y se integra perfectamente con APIs y Lambda."
    },
    {
      "question": "¿Qué es ECS?",
      "options": [
        {
          "text": "Un contenedor",
          "isCorrect": false
        },
        {
          "text": "Elastic Container Service - orquestador de contenedores Docker",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ECS (Elastic Container Service) es el orquestador de contenedores Docker nativo de AWS. Permite ejecutar y escalar aplicaciones en contenedores sin gestionar la infraestructura de orquestación. Soporta dos modos de lanzamiento: EC2 (gestionas las instancias) y Fargate (serverless, AWS gestiona todo). ECS se integra con ALB, CloudWatch, IAM y otros servicios AWS. Define servicios, tasks y task definitions para especificar cómo ejecutar containers."
    },
    {
      "question": "¿Qué es EKS?",
      "options": [
        {
          "text": "Un servicio",
          "isCorrect": false
        },
        {
          "text": "Elastic Kubernetes Service - Kubernetes gestionado",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "EKS (Elastic Kubernetes Service) es Kubernetes gestionado por AWS. Ejecuta clústeres Kubernetes sin necesidad de instalar, operar o mantener el control plane. EKS es certificado Kubernetes estándar, por lo que funciona con herramientas y plugins del ecosistema (kubectl, Helm, Operators). Ofrece alta disponibilidad multi-AZ, integración con servicios AWS (IAM, VPC, ELB) y opciones de cómputo (EC2, Fargate). Ideal para organizaciones ya usando Kubernetes."
    },
    {
      "question": "¿Qué es Fargate?",
      "options": [
        {
          "text": "Una puerta",
          "isCorrect": false
        },
        {
          "text": "Motor serverless para ECS/EKS sin gestionar servidores",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Fargate es un motor de cómputo serverless para contenedores que funciona con ECS y EKS. Elimina la necesidad de gestionar instancias EC2: solo defines los recursos (CPU, memoria) que necesita cada contenedor y Fargate los ejecuta automáticamente. Pagas solo por los recursos consumidos. Fargate maneja escalado, patching y disponibilidad. Es ideal para microservicios, jobs batch y cualquier workload en contenedores sin gestionar servidores."
    },
    {
      "question": "¿Diferencia entre ECS y EKS?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "ECS usa API propia de AWS, EKS usa Kubernetes estándar",
          "isCorrect": true
        },
        {
          "text": "EKS es mejor siempre",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia principal es la API de orquestación: ECS usa una API propietaria de AWS (más simple e integrada con servicios AWS). EKS usa Kubernetes estándar (portátil, compatible con ecosistema K8s). Elige ECS si estás completamente en AWS y quieres simplicidad. Elige EKS si necesitas portabilidad, ya usas Kubernetes, o quieres aprovechar herramientas K8s. Ambos pueden usar Fargate como motor serverless."
    },
    {
      "question": "¿Qué es ECR?",
      "options": [
        {
          "text": "Un registro",
          "isCorrect": false
        },
        {
          "text": "Elastic Container Registry - registro privado de imágenes Docker",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "ECR (Elastic Container Registry) es un registro privado de imágenes Docker totalmente gestionado. Permite almacenar, gestionar y desplegar imágenes de contenedores de forma segura. ECR se integra con ECS, EKS y servicios CI/CD. Ofrece encriptación en reposo, escaneo de vulnerabilidades, control de acceso con IAM y replicación entre regiones. Funciona como Docker Hub pero privado y optimizado para AWS."
    },
    {
      "question": "¿Qué es Elastic Beanstalk?",
      "options": [
        {
          "text": "Un tallo elástico",
          "isCorrect": false
        },
        {
          "text": "PaaS para desplegar aplicaciones sin gestionar infraestructura",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Elastic Beanstalk es una plataforma PaaS (Platform as a Service) que simplifica el despliegue de aplicaciones web. Subes tu código (Node.js, Python, Java, Go, PHP, Ruby, .NET) y Beanstalk aprovisiona automáticamente la infraestructura: EC2, ELB, Auto Scaling, RDS, etc. Gestiona capacidad, balanceo de carga, monitoreo y actualizaciones. Mantienes control total sobre recursos subyacentes pero sin complejidad operativa. Ideal para equipos que quieren enfocarse en código."
    },
    {
      "question": "¿Qué lenguajes soporta Elastic Beanstalk? (selección múltiple)",
      "options": [
        {
          "text": "Java, .NET",
          "isCorrect": false
        },
        {
          "text": "Node.js, Python",
          "isCorrect": true
        },
        {
          "text": "Ruby, PHP",
          "isCorrect": true
        },
        {
          "text": "Go, Docker",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Elastic Beanstalk soporta múltiples lenguajes y plataformas: Node.js, Python, Java, Go, PHP, Ruby, .NET Core, y Docker (cualquier lenguaje en container). También soporta aplicaciones multi-container y configuraciones personalizadas. Esto permite a equipos usar su stack preferido sin gestionar infraestructura."
    },
    {
      "question": "¿Qué es Secrets Manager?",
      "options": [
        {
          "text": "Un gestor de secretos",
          "isCorrect": false
        },
        {
          "text": "Servicio para rotar, gestionar y recuperar credenciales",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Secrets Manager es un servicio para almacenar, rotar y gestionar credenciales de forma segura: contraseñas de bases de datos, API keys, tokens, certificados. La diferencia clave vs Parameter Store es la rotación automática: Secrets Manager puede rotar credenciales automáticamente mediante funciones Lambda integradas (RDS, Redshift, DocumentDB). Ofrece encriptación, auditoría de accesos con CloudTrail y versionado de secretos. Ideal para gestionar secretos críticos con rotación."
    },
    {
      "question": "¿Qué es Systems Manager (SSM)?",
      "options": [
        {
          "text": "Un gestor de sistemas",
          "isCorrect": false
        },
        {
          "text": "Suite de herramientas para gestionar recursos AWS",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Systems Manager (SSM) es una suite de herramientas para gestionar y operar recursos AWS a escala. Incluye: 1) Session Manager: acceso seguro a instancias sin SSH. 2) Parameter Store: almacenar configuraciones. 3) Patch Manager: automatizar parches. 4) Run Command: ejecutar scripts en múltiples instancias. 5) State Manager: mantener configuraciones deseadas. 6) Inventory: descubrir software instalado. SSM centraliza operaciones y mejora seguridad y compliance."
    },
    {
      "question": "¿Qué es Parameter Store?",
      "options": [
        {
          "text": "Una tienda de parámetros",
          "isCorrect": false
        },
        {
          "text": "Almacenamiento seguro de configuraciones y secretos (parte de SSM)",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento de objetos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Parameter Store (parte de SSM) es un almacenamiento jerárquico para configuraciones y secretos. Permite guardar strings, listas o valores encriptados con KMS. Es más simple y económico que Secrets Manager pero sin rotación automática. Se usa para: configuraciones de apps, connection strings, feature flags, API keys no críticos. Los parámetros se organizan en paths jerárquicos (/app/db/password) y se acceden desde código, CloudFormation o Lambda."
    },
    {
      "question": "¿Diferencia entre Secrets Manager y Parameter Store?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Secrets Manager tiene rotación automática, Parameter Store es más simple",
          "isCorrect": true
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        },
        {
          "text": "Parameter Store es mejor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia principal es rotación: Secrets Manager tiene rotación automática integrada con Lambda para rotar credenciales sin tiempo de inactividad. Parameter Store es más simple, económico y sin rotación automática. Usa Secrets Manager para credenciales críticas de bases de datos que requieren rotación. Usa Parameter Store para configuraciones generales, feature flags o secretos que rotas manualmente. Secrets Manager cuesta más pero ofrece más features de seguridad."
    },
    {
      "question": "¿Qué es CloudTrail?",
      "options": [
        {
          "text": "Un rastro de nubes",
          "isCorrect": false
        },
        {
          "text": "Servicio de auditoría que registra llamadas API",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un monitor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "CloudTrail es el servicio de auditoría que registra todas las llamadas API en tu cuenta AWS. Captura quién hizo qué, cuándo y desde dónde: creación de instancias, cambios en S3, modificaciones IAM, etc. Los logs se almacenan en S3 y se pueden analizar con Athena. CloudTrail es esencial para seguridad, compliance, troubleshooting y detección de anomalías. Permite responder preguntas como '¿quién eliminó esta instancia?' o '¿qué cambió antes del incidente?'."
    },
    {
      "question": "¿Qué es Config?",
      "options": [
        {
          "text": "Configuración",
          "isCorrect": false
        },
        {
          "text": "Servicio que evalúa configuraciones y conformidad de recursos",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "AWS Config evalúa continuamente la configuración de recursos AWS y su conformidad con reglas deseadas. Responde preguntas como: ¿qué recursos existen? ¿cuál es su configuración actual? ¿cómo ha cambiado con el tiempo? ¿cumplen las políticas de seguridad? Config puede enviar notificaciones o ejecutar remediaciones automáticas cuando detecta configuraciones no conformes. Es fundamental para compliance, auditorías y governance en entornos regulados."
    },
    {
      "question": "¿Qué es X-Ray?",
      "options": [
        {
          "text": "Rayos X",
          "isCorrect": false
        },
        {
          "text": "Servicio de tracing distribuido para depurar aplicaciones",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un monitor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "X-Ray es un servicio de tracing distribuido para depurar y analizar aplicaciones distribuidas (microservicios). Captura información sobre requests que atraviesan múltiples servicios: latencias, errores, dependencias. Genera mapas de servicios visuales que muestran cómo interactúan componentes y dónde ocurren cuellos de botella. X-Ray se integra con Lambda, ECS, API Gateway, EC2 y frameworks como Express, Django, Spring. Es esencial para entender el comportamiento de arquitecturas complejas."
    },
    {
      "question": "¿Qué es Step Functions?",
      "options": [
        {
          "text": "Funciones paso a paso",
          "isCorrect": false
        },
        {
          "text": "Servicio para orquestar funciones Lambda en workflows",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un contenedor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Step Functions es un servicio para orquestar funciones Lambda y otros servicios AWS en workflows visuales. Define máquinas de estado (state machines) que coordinan pasos secuenciales, paralelos, condicionales, con manejo de errores y reintentos. Casos de uso: pipelines de procesamiento de datos, procesos de aprobación, automatizaciones complejas, orchestración de microservicios. Step Functions gestiona el estado y la lógica de negocio, mientras Lambda ejecuta el código."
    },
    {
      "question": "¿Qué es EventBridge?",
      "options": [
        {
          "text": "Un puente de eventos",
          "isCorrect": false
        },
        {
          "text": "Bus de eventos serverless para conectar aplicaciones",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "EventBridge es un bus de eventos serverless que conecta aplicaciones mediante eventos. Permite que servicios AWS (S3, DynamoDB, EC2), aplicaciones SaaS (Salesforce, Shopify) y aplicaciones propias se comuniquen enviando eventos. EventBridge enruta eventos a destinos según reglas: Lambda, SQS, SNS, Step Functions, etc. Es la evolución de CloudWatch Events, ideal para arquitecturas event-driven donde componentes reaccionan a cambios sin acoplamiento directo."
    },
    {
      "question": "¿Qué es Kinesis?",
      "options": [
        {
          "text": "Un río",
          "isCorrect": false
        },
        {
          "text": "Plataforma de streaming de datos en tiempo real",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Kinesis es una plataforma para procesar streaming de datos en tiempo real a escala masiva. Permite ingerir, almacenar y analizar datos continuos: logs, métricas, eventos de aplicaciones, clickstreams, IoT. Kinesis es ideal para casos de uso que requieren procesamiento inmediato: dashboards en vivo, detección de anomalías, analytics en tiempo real. Es la alternativa de AWS a Apache Kafka, completamente gestionada."
    },
    {
      "question": "¿Cuáles son servicios de Kinesis? (selección múltiple)",
      "options": [
        {
          "text": "Kinesis Data Streams",
          "isCorrect": false
        },
        {
          "text": "Kinesis Data Firehose",
          "isCorrect": true
        },
        {
          "text": "Kinesis Data Analytics",
          "isCorrect": true
        },
        {
          "text": "Kinesis Video Streams",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Kinesis tiene múltiples servicios: 1) Kinesis Data Streams: captura y almacena streams de datos. 2) Kinesis Data Firehose: carga streams directamente a S3, Redshift, Elasticsearch sin escribir código. 3) Kinesis Data Analytics: analiza streams con SQL en tiempo real. 4) Kinesis Video Streams: procesa video en tiempo real. Cada uno resuelve diferentes aspectos del procesamiento de datos streaming."
    },
    {
      "question": "¿Qué es Glue?",
      "options": [
        {
          "text": "Pegamento",
          "isCorrect": false
        },
        {
          "text": "Servicio ETL serverless para preparar datos",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Glue es un servicio ETL (Extract, Transform, Load) serverless para preparar datos. Descubre automáticamente esquemas con Glue Crawlers, genera código ETL en Python/Scala, ejecuta jobs a escala y cataloga datos en el Glue Data Catalog. Glue se integra con S3, RDS, Redshift y Athena. Es ideal para pipelines de datos, data lakes, migraciones y transformaciones complejas sin gestionar servidores Spark."
    },
    {
      "question": "¿Qué es Athena?",
      "options": [
        {
          "text": "Una diosa griega",
          "isCorrect": false
        },
        {
          "text": "Servicio de consultas SQL sobre datos en S3",
          "isCorrect": true
        },
        {
          "text": "Una base de datos tradicional",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Athena es un servicio de consultas SQL interactivo y serverless sobre datos almacenados en S3. No requiere infraestructura: defines tablas que apuntan a archivos en S3 (CSV, JSON, Parquet) y ejecutas queries SQL estándar. Athena usa Presto bajo el capó y cobra solo por datos escaneados. Es ideal para análisis ad-hoc, exploración de data lakes, logs, y generación de reportes sin necesidad de cargar datos en una base de datos."
    },
    {
      "question": "¿Qué es Redshift?",
      "options": [
        {
          "text": "Un desplazamiento al rojo",
          "isCorrect": false
        },
        {
          "text": "Data warehouse para análisis de big data",
          "isCorrect": true
        },
        {
          "text": "Una base de datos pequeña",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Redshift es un data warehouse columnar optimizado para análisis de big data. Permite ejecutar queries SQL sobre petabytes de datos estructurados con alto rendimiento (paralelismo masivo). Redshift escala de gigabytes a petabytes, soporta compresión, distribución de datos y consultas federadas a S3. Es ideal para business intelligence, reportes complejos y análisis históricos que requieren joins sobre grandes volúmenes. Se integra con herramientas BI como Tableau, QuickSight."
    },
    {
      "question": "¿Qué es EMR?",
      "options": [
        {
          "text": "Un récord",
          "isCorrect": false
        },
        {
          "text": "Elastic MapReduce - procesamiento de big data con Hadoop/Spark",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "EMR (Elastic MapReduce) es un servicio para ejecutar frameworks de big data: Hadoop, Spark, Hive, Presto, HBase, Flink. Aprovisiona clusters de instancias EC2, instala software y escala automáticamente. EMR se usa para procesamiento batch masivo: transformación de datos, machine learning a gran escala, análisis genomic, log processing. Pagas solo por instancias y tiempo de uso. Es la forma más económica de ejecutar Spark/Hadoop en AWS."
    },
    {
      "question": "¿Qué es SageMaker?",
      "options": [
        {
          "text": "Un creador de sabios",
          "isCorrect": false
        },
        {
          "text": "Plataforma para construir, entrenar y desplegar modelos ML",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "SageMaker es la plataforma completa de Machine Learning de AWS. Cubre todo el ciclo de vida: preparación de datos, entrenamiento de modelos (con Jupyter notebooks y GPUs), optimización de hiperparámetros, despliegue a producción con endpoints escalables, y monitoreo. SageMaker incluye algoritmos pre-construidos, frameworks populares (TensorFlow, PyTorch), AutoML (Autopilot), y herramientas para MLOps. Elimina la complejidad de infraestructura ML."
    },
    {
      "question": "¿Qué es Rekognition?",
      "options": [
        {
          "text": "Reconocimiento",
          "isCorrect": false
        },
        {
          "text": "Servicio de análisis de imágenes y videos con ML",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Rekognition es un servicio de análisis de imágenes y videos usando machine learning. Detecta objetos, escenas, texto, actividades, contenido inapropiado, reconocimiento facial y análisis de emociones. Casos de uso: moderación de contenido, identificación de celebridades, análisis de sentimientos, búsqueda visual, autenticación biométrica, video surveillance. Rekognition es completamente gestionado: envías imágenes/videos y recibes resultados en JSON sin entrenar modelos."
    },
    {
      "question": "¿Qué es Comprehend?",
      "options": [
        {
          "text": "Comprender",
          "isCorrect": false
        },
        {
          "text": "Servicio de procesamiento de lenguaje natural (NLP)",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Comprehend es un servicio de procesamiento de lenguaje natural (NLP) que analiza texto para extraer insights. Identifica: entidades (personas, lugares, organizaciones), sentimiento (positivo/negativo/neutral), idioma, frases clave, sintaxis y topics. Casos de uso: análisis de reviews de clientes, clasificación de documentos, extracción de información, moderación de contenido textual. Comprehend elimina la complejidad de NLP y ofrece APIs simples para integrar."
    },
    {
      "question": "¿Qué es Transcribe?",
      "options": [
        {
          "text": "Transcribir",
          "isCorrect": false
        },
        {
          "text": "Servicio de conversión de voz a texto",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un editor de texto",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Transcribe es un servicio de conversión de voz a texto (speech-to-text) con ML. Transcribe audio grabado o en tiempo real a texto, soporta múltiples idiomas y dialectos, identifica speakers diferentes, filtra contenido inapropiado y puede ser entrenado con vocabulario personalizado. Casos de uso: subtítulos automáticos, transcripción de llamadas, análisis de reuniones, accesibilidad, asistentes virtuales. Funciona con archivos en S3 o streaming."
    },
    {
      "question": "¿Qué es Polly?",
      "options": [
        {
          "text": "Un loro",
          "isCorrect": false
        },
        {
          "text": "Servicio de conversión de texto a voz",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un almacenamiento",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Polly es un servicio de conversión de texto a voz (text-to-speech) con voces neurales realistas. Soporta docenas de idiomas y voces con diferentes acentos y estilos. Polly genera audio en formatos mp3, ogg, pcm y puede enfatizar palabras, controlar velocidad y pronunciación con SSML. Casos de uso: aplicaciones de lectura, asistentes virtuales, e-learning, accesibilidad, IVR (sistemas telefónicos). Pagas solo por caracteres convertidos."
    },
    {
      "question": "¿Qué es Translate?",
      "options": [
        {
          "text": "Traducir",
          "isCorrect": false
        },
        {
          "text": "Servicio de traducción automática de textos",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un compilador",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Translate es un servicio de traducción automática de textos con redes neuronales. Traduce entre 75+ idiomas automáticamente detectando el idioma fuente. Soporta traducción en batch y en tiempo real, y puede entrenarse con terminología personalizada para dominios específicos (médico, legal). Casos de uso: localización de aplicaciones, traducción de contenido web, atención al cliente multilenguaje, análisis de documentos internacionales. Pricing por caracteres traducidos."
    },
    {
      "question": "¿Qué son las regiones AWS?",
      "options": [
        {
          "text": "Regiones geográficas",
          "isCorrect": false
        },
        {
          "text": "Ubicaciones físicas con múltiples zonas de disponibilidad",
          "isCorrect": true
        },
        {
          "text": "Grupos de servidores",
          "isCorrect": false
        },
        {
          "text": "Data centers únicos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las regiones AWS son ubicaciones geográficas (como us-east-1 o sa-east-1) que contienen varios data centers. Cada región es independiente y está diseñada para ofrecer baja latencia y cumplimiento local. Elegir la región correcta afecta el rendimiento, los costos y la normativa aplicable (por ejemplo, RGPD en la UE)."
    },
    {
      "question": "¿Qué son las zonas de disponibilidad (AZ)?",
      "options": [
        {
          "text": "Zonas de tiempo",
          "isCorrect": false
        },
        {
          "text": "Data centers separados dentro de una región",
          "isCorrect": true
        },
        {
          "text": "Regiones completas",
          "isCorrect": false
        },
        {
          "text": "Grupos de usuarios",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las zonas de disponibilidad (AZ) son data centers físicos separados dentro de una región. Se conectan mediante redes privadas de alta velocidad. Si una AZ falla, las demás siguen operando, garantizando alta disponibilidad y tolerancia a desastres."
    },
    {
      "question": "¿Por qué usar múltiples AZ? (selección múltiple)",
      "options": [
        {
          "text": "Alta disponibilidad",
          "isCorrect": false
        },
        {
          "text": "Tolerancia a fallos",
          "isCorrect": true
        },
        {
          "text": "Mejor rendimiento",
          "isCorrect": true
        },
        {
          "text": "Cumplimiento geográfico",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Usar múltiples AZ mejora la resiliencia y el rendimiento. Tolerancia a fallos: si una zona se cae, otra sigue activa. Baja latencia: se puede balancear carga entre AZs cercanas. Es una práctica clave para arquitecturas de alta disponibilidad (HA)."
    },
    {
      "question": "¿Qué son los edge locations?",
      "options": [
        {
          "text": "Ubicaciones de borde",
          "isCorrect": false
        },
        {
          "text": "Puntos de presencia para CloudFront y Route 53",
          "isCorrect": true
        },
        {
          "text": "Data centers principales",
          "isCorrect": false
        },
        {
          "text": "Oficinas de AWS",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las edge locations son puntos de presencia globales donde AWS almacena contenido en caché o enruta tráfico DNS. Se usan en servicios como CloudFront (CDN) y Route 53, acercando los datos al usuario final para reducir la latencia y acelerar la entrega de contenido."
    },
    {
      "question": "¿Qué es el modelo de responsabilidad compartida?",
      "options": [
        {
          "text": "Un contrato",
          "isCorrect": false
        },
        {
          "text": "AWS gestiona la seguridad DE la nube, cliente gestiona seguridad EN la nube",
          "isCorrect": true
        },
        {
          "text": "AWS gestiona todo",
          "isCorrect": false
        },
        {
          "text": "Cliente gestiona todo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El modelo de responsabilidad compartida define qué seguridad maneja AWS y cuál el cliente. AWS asegura la infraestructura (hardware, red, centros de datos). El cliente protege lo que implementa dentro de la nube (datos, acceso, configuración). Este modelo evita confusiones sobre quién es responsable de cada capa."
    },
    {
      "question": "¿Qué gestiona AWS en el modelo compartido? (selección múltiple)",
      "options": [
        {
          "text": "Hardware físico",
          "isCorrect": false
        },
        {
          "text": "Red global",
          "isCorrect": true
        },
        {
          "text": "Software de virtualización",
          "isCorrect": true
        },
        {
          "text": "Datos del cliente",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "AWS gestiona la seguridad de la nube, que incluye la infraestructura física, red global, hipervisores y servicios base. Esto garantiza que los entornos virtuales estén aislados, monitoreados y protegidos frente a vulnerabilidades a nivel de hardware o red."
    },
    {
      "question": "¿Qué gestiona el cliente? (selección múltiple)",
      "options": [
        {
          "text": "Datos",
          "isCorrect": false
        },
        {
          "text": "Configuración de aplicaciones",
          "isCorrect": true
        },
        {
          "text": "Gestión de accesos IAM",
          "isCorrect": true
        },
        {
          "text": "Actualizaciones del sistema operativo (en EC2)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "El cliente gestiona la seguridad dentro de la nube: configuración de servicios, permisos IAM, cifrado de datos, parches de sistemas y control de acceso. AWS provee las herramientas, pero el usuario define cómo se usan correctamente."
    },
    {
      "question": "¿Qué es el Free Tier?",
      "options": [
        {
          "text": "Un nivel gratis",
          "isCorrect": false
        },
        {
          "text": "Servicios gratuitos con límites para nuevos usuarios",
          "isCorrect": true
        },
        {
          "text": "Todo gratis siempre",
          "isCorrect": false
        },
        {
          "text": "Un plan de pago",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El Free Tier permite usar muchos servicios AWS de forma gratuita por 12 meses o con ciertos límites permanentes. Es ideal para aprender o probar sin costo. Ejemplo: 750 horas/mes en EC2 t2.micro o 5 GB en S3 durante el primer año."
    },
    {
      "question": "¿Cuánto dura el Free Tier de EC2?",
      "options": [
        {
          "text": "1 mes",
          "isCorrect": false
        },
        {
          "text": "12 meses (750 horas/mes de t2.micro)",
          "isCorrect": true
        },
        {
          "text": "Para siempre",
          "isCorrect": false
        },
        {
          "text": "6 meses",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El Free Tier de EC2 ofrece 750 horas al mes durante 12 meses para una instancia t2.micro o t3.micro. Es suficiente para tener un servidor en línea todo el mes, ideal para prácticas o entornos de desarrollo sin costo."
    },
    {
      "question": "¿Qué es el pricing modelo Pay-as-you-go?",
      "options": [
        {
          "text": "Pago anticipado",
          "isCorrect": false
        },
        {
          "text": "Paga solo por lo que usas sin contratos largos",
          "isCorrect": true
        },
        {
          "text": "Pago mensual fijo",
          "isCorrect": false
        },
        {
          "text": "Pago anual",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El modelo Pay-as-you-go significa que solo pagás por lo que usás. No hay contratos ni costos fijos: si una instancia EC2 corre 10 horas, solo se cobra ese tiempo. Este enfoque da flexibilidad y control sobre el presupuesto en función del consumo real."
    },
    {
      "question": "¿Cuáles son modelos de pricing para EC2? (selección múltiple)",
      "options": [
        {
          "text": "On-Demand",
          "isCorrect": false
        },
        {
          "text": "Reserved Instances",
          "isCorrect": true
        },
        {
          "text": "Spot Instances",
          "isCorrect": true
        },
        {
          "text": "Savings Plans",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "EC2 ofrece varios modelos de pricing: On-Demand (pago por hora/segundo de uso), Reserved Instances (contrato de 1–3 años con descuento), Spot Instances (capacidad no usada con hasta 90% de descuento). Cada uno se adapta a distintos tipos de carga (temporal, estable o flexible)."
    },
    {
      "question": "¿Qué son Reserved Instances?",
      "options": [
        {
          "text": "Instancias reservadas",
          "isCorrect": false
        },
        {
          "text": "Compromiso de 1-3 años con descuento significativo",
          "isCorrect": true
        },
        {
          "text": "Instancias temporales",
          "isCorrect": false
        },
        {
          "text": "Instancias caras",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las Reserved Instances (RI) ofrecen descuentos de hasta 70% a cambio de un compromiso de uso de 1 o 3 años. Son ideales para cargas constantes como bases de datos o servidores de aplicaciones de producción."
    },
    {
      "question": "¿Qué son Spot Instances?",
      "options": [
        {
          "text": "Instancias manchadas",
          "isCorrect": false
        },
        {
          "text": "Capacidad no utilizada de AWS con hasta 90% descuento",
          "isCorrect": true
        },
        {
          "text": "Instancias premium",
          "isCorrect": false
        },
        {
          "text": "Instancias garantizadas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las Spot Instances aprovechan capacidad ociosa de AWS a precios muy bajos (hasta 90% de descuento). Son interrumpibles cuando AWS necesita los recursos, por lo que se usan para tareas no críticas como procesamiento batch, Big Data o renderizados."
    },
    {
      "question": "¿Cuándo usar Spot Instances?",
      "options": [
        {
          "text": "Aplicaciones críticas",
          "isCorrect": false
        },
        {
          "text": "Workloads tolerantes a interrupciones (batch, big data)",
          "isCorrect": true
        },
        {
          "text": "Bases de datos principales",
          "isCorrect": false
        },
        {
          "text": "Siempre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Usá Spot Instances para cargas tolerantes a interrupciones, como análisis por lotes, simulaciones o pipelines de datos. Son una excelente opción para reducir costos sin afectar la producción crítica."
    },
    {
      "question": "¿Qué es Cost Explorer?",
      "options": [
        {
          "text": "Un explorador",
          "isCorrect": false
        },
        {
          "text": "Herramienta para visualizar y analizar costos de AWS",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servicio de facturación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Cost Explorer permite analizar y visualizar los gastos de tu cuenta AWS. Muestra gráficos de consumo por servicio, etiqueta o región. Es útil para detectar aumentos inesperados, planificar presupuestos y optimizar costos en entornos grandes."
    },
    {
      "question": "¿Qué es Budgets?",
      "options": [
        {
          "text": "Presupuestos",
          "isCorrect": false
        },
        {
          "text": "Herramienta para crear alertas de costos y uso",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un plan de pago",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Budgets permite crear presupuestos personalizados y alertas automáticas. Podés definir límites de gasto o uso, y recibir notificaciones por correo o SNS si los superás. Es ideal para controlar costos en equipos grandes o proyectos múltiples."
    },
    {
      "question": "¿Qué es Trusted Advisor?",
      "options": [
        {
          "text": "Un asesor",
          "isCorrect": false
        },
        {
          "text": "Herramienta que recomienda mejores prácticas en costos, seguridad, rendimiento",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servicio de soporte",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Trusted Advisor revisa tu cuenta y sugiere mejores prácticas en cinco áreas: costos, rendimiento, seguridad, tolerancia a fallos y límites de servicio. Es como un asesor automático que detecta oportunidades de optimización o configuraciones riesgosas."
    },
    {
      "question": "¿Qué categorías revisa Trusted Advisor? (selección múltiple)",
      "options": [
        {
          "text": "Cost optimization",
          "isCorrect": false
        },
        {
          "text": "Security",
          "isCorrect": true
        },
        {
          "text": "Performance",
          "isCorrect": true
        },
        {
          "text": "Fault tolerance",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Las categorías más importantes que evalúa Trusted Advisor son Seguridad y Rendimiento, además de Cost Optimization y Fault Tolerance. Por ejemplo, puede advertir sobre claves IAM sin rotar o instancias sin uso que siguen generando costos."
    },
    {
      "question": "¿Qué es AWS Organizations?",
      "options": [
        {
          "text": "Organizaciones",
          "isCorrect": false
        },
        {
          "text": "Servicio para gestionar múltiples cuentas AWS centralizadamente",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un directorio",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "AWS Organizations permite gestionar varias cuentas desde un punto central. Facilita aplicar políticas, consolidar facturación y delegar accesos. Es muy usado por empresas con múltiples entornos (producción, testing, desarrollo) o divisiones internas."
    },
    {
      "question": "¿Qué son las SCPs?",
      "options": [
        {
          "text": "Service Control Policies - políticas para limitar permisos en Organizations",
          "isCorrect": false
        },
        {
          "text": "Protocolos de seguridad",
          "isCorrect": true
        },
        {
          "text": "Scripts",
          "isCorrect": false
        },
        {
          "text": "Certificados",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las SCP (Service Control Policies) son políticas de control dentro de AWS Organizations que limitan qué acciones pueden realizar las cuentas hijas, incluso si el usuario tiene permisos IAM. Funcionan como un 'filtro superior' de seguridad a nivel organizacional."
    },
    {
      "question": "¿Qué es Control Tower?",
      "options": [
        {
          "text": "Una torre de control",
          "isCorrect": false
        },
        {
          "text": "Servicio para configurar y gobernar entornos multi-cuenta",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un monitor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "AWS Control Tower automatiza la creación y gobernanza de entornos multi-cuenta. Crea estructuras seguras (landing zones), aplica políticas y configura registros, cumpliendo buenas prácticas desde el inicio. Es ideal para empresas que comienzan una adopción a gran escala de AWS."
    },
    {
      "question": "¿Qué es Well-Architected Framework?",
      "options": [
        {
          "text": "Un marco arquitectónico",
          "isCorrect": false
        },
        {
          "text": "Conjunto de mejores prácticas en 6 pilares para arquitectura en AWS",
          "isCorrect": true
        },
        {
          "text": "Una herramienta",
          "isCorrect": false
        },
        {
          "text": "Un servicio",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El Well-Architected Framework es un conjunto de buenas prácticas de diseño en la nube agrupadas en seis pilares. Ayuda a evaluar y mejorar arquitecturas para que sean seguras, eficientes y resilientes, con documentación y herramientas automáticas de revisión."
    },
    {
      "question": "¿Cuáles son los 6 pilares de Well-Architected? (selección múltiple)",
      "options": [
        {
          "text": "Operational Excellence",
          "isCorrect": false
        },
        {
          "text": "Security",
          "isCorrect": true
        },
        {
          "text": "Reliability",
          "isCorrect": true
        },
        {
          "text": "Performance Efficiency, Cost Optimization, Sustainability",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los seis pilares del Well-Architected Framework son: 1) Operational Excellence, 2) Security, 3) Reliability, 4) Performance Efficiency, 5) Cost Optimization, 6) Sustainability. Cada pilar aborda un aspecto clave del diseño y la operación en AWS."
    },
    {
      "question": "¿Qué es AWS CLI?",
      "options": [
        {
          "text": "Command Line Interface - herramienta de línea de comandos para AWS",
          "isCorrect": false
        },
        {
          "text": "Un servicio web",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Una interfaz gráfica",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "AWS CLI (Command Line Interface) no es un servicio web, sino una herramienta de línea de comandos para interactuar con AWS. Permite automatizar tareas, ejecutar scripts y administrar recursos sin usar la consola gráfica. Es esencial para DevOps y automatización."
    },
    {
      "question": "¿Qué es AWS SDK?",
      "options": [
        {
          "text": "Software Development Kit - librerías para diferentes lenguajes",
          "isCorrect": false
        },
        {
          "text": "Un servicio",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Una herramienta CLI",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El AWS SDK (Software Development Kit) es un conjunto de librerías para distintos lenguajes (JavaScript, Python, Java, etc.) que permiten interactuar con los servicios AWS desde el código. Por ejemplo, subir archivos a S3 o lanzar instancias EC2 desde una aplicación."
    },
    {
      "question": "¿Qué lenguajes tienen SDK oficial? (selección múltiple)",
      "options": [
        {
          "text": "Python (Boto3)",
          "isCorrect": false
        },
        {
          "text": "JavaScript/Node.js",
          "isCorrect": true
        },
        {
          "text": "Java",
          "isCorrect": true
        },
        {
          "text": ".NET, Ruby, PHP, Go",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "AWS ofrece SDKs oficiales para múltiples lenguajes, entre ellos JavaScript/Node.js, Python (boto3), Java, Go, PHP, Ruby y .NET. Esto facilita integrar servicios AWS directamente en tus aplicaciones, respetando autenticación y seguridad."
    },
    {
      "question": "¿Qué es CloudShell?",
      "options": [
        {
          "text": "Una terminal en la nube",
          "isCorrect": false
        },
        {
          "text": "Terminal preconfigurada en el navegador para AWS CLI",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "CloudShell es una terminal preconfigurada en el navegador, lista para ejecutar comandos AWS CLI. No requiere instalación, usa credenciales de la cuenta actual y tiene almacenamiento persistente. Ideal para tareas rápidas o demostraciones seguras."
    },
    {
      "question": "¿Qué es Management Console?",
      "options": [
        {
          "text": "Una consola",
          "isCorrect": false
        },
        {
          "text": "Interfaz web para gestionar servicios AWS",
          "isCorrect": true
        },
        {
          "text": "Una terminal",
          "isCorrect": false
        },
        {
          "text": "Una aplicación móvil",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La Management Console es la interfaz web gráfica para administrar todos los servicios AWS. Permite lanzar instancias, crear roles, configurar redes o visualizar costos de manera intuitiva. Es el punto de entrada más común para nuevos usuarios."
    }
  ],
  "graphql": [
    {
      "question": "¿Qué es GraphQL?",
      "options": [
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Lenguaje de consulta para APIs y runtime para ejecutar esas consultas",
          "isCorrect": true
        },
        {
          "text": "Un framework web",
          "isCorrect": false
        },
        {
          "text": "Un ORM",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "GraphQL es **un lenguaje de consulta para APIs** y también el **runtime** que ejecuta esas consultas. El cliente describe exactamente qué datos quiere y en qué forma, y el servidor responde con un JSON que sigue esa misma estructura. Esto evita pedir datos de más o de menos y hace las APIs más eficientes y predecibles."
    },
    {
      "question": "¿Quién desarrolló GraphQL?",
      "options": [
        {
          "text": "Google",
          "isCorrect": false
        },
        {
          "text": "Facebook (Meta)",
          "isCorrect": true
        },
        {
          "text": "Amazon",
          "isCorrect": false
        },
        {
          "text": "Microsoft",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "GraphQL fue creado por **Facebook (hoy Meta)** para resolver problemas de sus apps móviles, donde necesitaban optimizar tráfico de red y evitar múltiples llamadas REST. Más tarde lo liberaron como open source, y hoy es un estándar de facto para APIs flexibles en muchas compañías."
    },
    {
      "question": "¿Cuándo se hizo open source GraphQL?",
      "options": [
        {
          "text": "2010",
          "isCorrect": false
        },
        {
          "text": "2015",
          "isCorrect": true
        },
        {
          "text": "2018",
          "isCorrect": false
        },
        {
          "text": "2020",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "GraphQL se hizo **open source en 2015**. Eso permitió que la comunidad lo adopte, cree servidores, clientes, herramientas (Apollo, Relay, etc.) y lo lleve a múltiples lenguajes. Desde entonces, la especificación se mantiene de forma abierta y evoluciona con propuestas y RFCs."
    },
    {
      "question": "¿Diferencia principal entre GraphQL y REST?",
      "options": [
        {
          "text": "Una consulta que solicita varios campos o relaciones en una sola llamada",
          "isCorrect": true
        },
        {
          "text": "Un método para modificar datos",
          "isCorrect": false
        },
        {
          "text": "Una validación de esquema",
          "isCorrect": false
        },
        {
          "text": "Un tipo de mutación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La gran diferencia con REST es que con GraphQL **el cliente define la forma y cantidad de datos** que necesita en una sola consulta. En lugar de hacer varias requests a distintos endpoints (over-fetching/under-fetching), enviás una sola query y recibís exactamente la estructura que pediste."
    },
    {
      "question": "¿Qué es un schema en GraphQL?",
      "options": [
        {
          "text": "Un esquema de base de datos",
          "isCorrect": false
        },
        {
          "text": "Contrato que define tipos, queries y mutations disponibles",
          "isCorrect": true
        },
        {
          "text": "Un archivo de configuración",
          "isCorrect": false
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **schema** es el **contrato central** de una API GraphQL: define qué tipos existen, qué queries, mutations y subscriptions están disponibles y cómo se relacionan. Sirve como documentación viva y permite validar las consultas antes de ejecutarlas, evitando que el cliente pida algo que no existe."
    },
    {
      "question": "¿Qué lenguaje se usa para definir un schema?",
      "options": [
        {
          "text": "JSON",
          "isCorrect": false
        },
        {
          "text": "SDL (Schema Definition Language)",
          "isCorrect": true
        },
        {
          "text": "XML",
          "isCorrect": false
        },
        {
          "text": "YAML",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Normalmente el schema se define usando **SDL (Schema Definition Language)**, una sintaxis específica de GraphQL:\n\n```graphql\ntype User {\n  id: ID!\n  name: String!\n}\n```\n\nSDL es declarativo y legible, y muchas herramientas lo usan para generar código, documentación y tipos TypeScript/Flow."
    },
    {
      "question": "¿Qué es un type en GraphQL?",
      "options": [
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        },
        {
          "text": "Define la estructura de un objeto con sus campos",
          "isCorrect": true
        },
        {
          "text": "Una función",
          "isCorrect": false
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **type** en GraphQL define la **estructura de un objeto**, es decir, qué campos tiene y de qué tipo son. Por ejemplo, `type Post { id: ID!, title: String!, author: User! }`. A partir de estos types, las queries saben qué forma van a tener los datos de respuesta."
    },
    {
      "question": "¿Cuáles son tipos escalares en GraphQL? (selección múltiple)",
      "options": [
        {
          "text": "Int",
          "isCorrect": false
        },
        {
          "text": "Float",
          "isCorrect": true
        },
        {
          "text": "String",
          "isCorrect": true
        },
        {
          "text": "Boolean e ID",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los tipos escalares son los **\"bloques básicos\"** de datos en GraphQL, como `Int`, `Float`, `String`, `Boolean` e `ID`. En esta pregunta se destacan `Float` y `String`, que representan números con decimales y texto respectivamente. A partir de ellos se construyen tipos más complejos (objetos, listas, etc.)."
    },
    {
      "question": "¿Qué es el tipo ID?",
      "options": [
        {
          "text": "Un identificador",
          "isCorrect": false
        },
        {
          "text": "Tipo escalar para identificadores únicos",
          "isCorrect": true
        },
        {
          "text": "Un número",
          "isCorrect": false
        },
        {
          "text": "Un string normal",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`ID` es un tipo escalar pensado para **identificadores únicos**. Generalmente se serializa como `String`, pero semánticamente indica que ese valor se usa para identificar entidades (usuarios, posts, etc.). No se deberían hacer operaciones aritméticas con un `ID`; su función es servir como clave."
    },
    {
      "question": "¿Qué es una Query en GraphQL?",
      "options": [
        {
          "text": "Los tipos Query, Mutation y Subscription",
          "isCorrect": true
        },
        {
          "text": "Query",
          "isCorrect": false
        },
        {
          "text": "Schema y Type",
          "isCorrect": false
        },
        {
          "text": "Object y Scalar",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una **Query** es la operación de **lectura** en GraphQL: sirve para obtener datos. Lo interesante es que la query define la forma del resultado:\n\n```graphql\nquery {\n  user(id: \"1\") {\n    name\n    email\n  }\n}\n```\n\nEl servidor devuelve exactamente esos campos y nada más."
    },
    {
      "question": "¿Qué es una Mutation en GraphQL?",
      "options": [
        {
          "text": "Una mutación genética",
          "isCorrect": false
        },
        {
          "text": "Operación para crear, actualizar o eliminar datos",
          "isCorrect": true
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una **Mutation** es la operación que **cambia el estado**: crear, actualizar o eliminar datos (similar a POST/PUT/PATCH/DELETE en REST). A diferencia de REST, una mutation puede devolver datos muy estructurados (por ejemplo, el objeto creado + errores de validación) en una sola respuesta."
    },
    {
      "question": "¿Qué es una Subscription en GraphQL?",
      "options": [
        {
          "text": "Una suscripción de pago",
          "isCorrect": false
        },
        {
          "text": "Operación para recibir actualizaciones en tiempo real",
          "isCorrect": true
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        },
        {
          "text": "Una mutación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una **Subscription** permite **recibir datos en tiempo real**. En lugar de hacer polling, el cliente se suscribe a un evento (por ejemplo, `messageAdded`) y el servidor le envía actualizaciones cuando ocurren cambios. Normalmente se implementa sobre WebSockets u otro transporte persistente."
    },
    {
      "question": "¿Cuáles son las 3 operaciones principales? (selección múltiple)",
      "options": [
        {
          "text": "Query",
          "isCorrect": false
        },
        {
          "text": "Mutation",
          "isCorrect": true
        },
        {
          "text": "Subscription",
          "isCorrect": true
        },
        {
          "text": "Delete",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Las tres operaciones principales en GraphQL son **Query, Mutation y Subscription**. Queries leen datos, Mutations modifican datos y Subscriptions permiten recibir cambios en tiempo real. En esta pregunta se resaltan dos, pero siempre hay que recordar que el modelo completo incluye las tres."
    },
    {
      "question": "¿Qué es un resolver?",
      "options": [
        {
          "text": "Un solucionador",
          "isCorrect": false
        },
        {
          "text": "Función que obtiene los datos para un campo específico",
          "isCorrect": true
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        },
        {
          "text": "Un tipo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **resolver** es la **función que realmente trae los datos** para un campo específico del schema. Cuando hacés una query, GraphQL recorre el árbol de campos y va llamando a los resolvers correspondientes (consultando DBs, otros servicios, etc.) para construir la respuesta final."
    },
    {
      "question": "¿Qué es el campo __typename?",
      "options": [
        {
          "text": "Un nombre de tipo",
          "isCorrect": false
        },
        {
          "text": "Meta-campo que retorna el nombre del tipo de objeto",
          "isCorrect": true
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        },
        {
          "text": "Un resolver",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`__typename` es un **meta-campo** disponible en cualquier objeto GraphQL que devuelve el nombre del tipo concreto. Es muy útil en clientes (Apollo, Relay) para cacheo y para distinguir qué tipo se devolvió en un `Union` o `Interface` sin tener que adivinar."
    },
    {
      "question": "¿Qué son los arguments en GraphQL?",
      "options": [
        {
          "text": "Argumentos de función",
          "isCorrect": false
        },
        {
          "text": "Parámetros que se pasan a campos para filtrar/modificar datos",
          "isCorrect": true
        },
        {
          "text": "Tipos de datos",
          "isCorrect": false
        },
        {
          "text": "Variables",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los **arguments** son parámetros que se pasan a campos o operaciones para **filtrar o modificar la consulta**. Por ejemplo:\n\n```graphql\nuser(id: \"1\") { name }\n```\n\nAquí `id: \"1\"` es un argument. Ayudan a hacer queries más expresivas sin crear nuevos endpoints."
    },
    {
      "question": "¿Qué son las variables en GraphQL?",
      "options": [
        {
          "text": "Variables de programación",
          "isCorrect": false
        },
        {
          "text": "Manera de parametrizar queries para reutilización",
          "isCorrect": true
        },
        {
          "text": "Tipos de datos",
          "isCorrect": false
        },
        {
          "text": "Argumentos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las **variables** permiten **parametrizar las queries** sin tener que reescribir el texto de la query cada vez. Definís la variable en la operación (`query GetUser($id: ID!)`) y luego envías los valores en un payload separado. Esto mejora la reutilización y facilita el uso en clientes y herramientas."
    },
    {
      "question": "¿Cómo se definen variables en una query?",
      "options": [
        {
          "text": "Con $",
          "isCorrect": false
        },
        {
          "text": "Usando $ antes del nombre (ej: $id: ID!)",
          "isCorrect": true
        },
        {
          "text": "Con #",
          "isCorrect": false
        },
        {
          "text": "Con @",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En una query, las variables se definen **con `$` delante del nombre y un tipo**:\n\n```graphql\nquery GetUser($id: ID!) {\n  user(id: $id) { name }\n}\n```\n\nLuego, en la request HTTP, enviás `{ \"id\": \"1\" }` como variables. Así podés cambiar el valor sin tocar la query."
    },
    {
      "question": "¿Qué es el signo ! en GraphQL?",
      "options": [
        {
          "text": "Exclamación",
          "isCorrect": false
        },
        {
          "text": "Indica que un campo o argumento es requerido (non-null)",
          "isCorrect": true
        },
        {
          "text": "Negación",
          "isCorrect": false
        },
        {
          "text": "Comentario",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El signo `!` marca un tipo como **non-null**, es decir, que **no puede ser `null`**. `String!` significa \"siempre hay un String presente\". Esto sirve tanto para campos como para argumentos, y ayuda a que el cliente sepa qué puede asumir que siempre está definido."
    },
    {
      "question": "¿Qué son los fragments en GraphQL?",
      "options": [
        {
          "text": "Fragmentos de código",
          "isCorrect": false
        },
        {
          "text": "Conjuntos reutilizables de campos",
          "isCorrect": true
        },
        {
          "text": "Tipos de datos",
          "isCorrect": false
        },
        {
          "text": "Consultas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **fragment** es un bloque reutilizable de campos que podés **incluir en varias queries**. Por ejemplo:\n\n```graphql\nfragment UserFields on User {\n  id\n  name\n}\n\nquery {\n  user(id: \"1\") {\n    ...UserFields\n  }\n}\n```\n\nAsí evitás duplicar listas largas de campos y mantenés las queries consistentes."
    },
    {
      "question": "¿Cómo se define un fragment?",
      "options": [
        {
          "text": "fragment Name on Type { fields }",
          "isCorrect": false
        },
        {
          "text": "type Fragment",
          "isCorrect": true
        },
        {
          "text": "fragment: {}",
          "isCorrect": false
        },
        {
          "text": "define fragment",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un fragment es un bloque reutilizable de campos, pero **no se define con `type Fragment`** sino con la sintaxis:\n\n```graphql\nfragment UserFields on User {\n  id\n  name\n}\n```\n\nLa idea es agrupar campos que se repiten para poder incluirlos en distintas queries usando `...NombreDelFragment`."
    },
    {
      "question": "¿Qué son inline fragments?",
      "options": [
        {
          "text": "Fragmentos en línea",
          "isCorrect": false
        },
        {
          "text": "Fragmentos para manejar diferentes tipos en unions/interfaces",
          "isCorrect": true
        },
        {
          "text": "Fragmentos normales",
          "isCorrect": false
        },
        {
          "text": "Tipos de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los **inline fragments** permiten seleccionar campos dependiendo del **tipo concreto** dentro de una `union` o `interface`. Por ejemplo:\n\n```graphql\n... on Photo { url }\n... on Video { duration }\n```\n\nSon útiles cuando una misma query puede devolver distintos tipos y querés manejar cada caso en la misma respuesta."
    },
    {
      "question": "¿Qué es una Interface en GraphQL?",
      "options": [
        {
          "text": "Una interfaz de usuario",
          "isCorrect": false
        },
        {
          "text": "Tipo abstracto que otros tipos pueden implementar",
          "isCorrect": true
        },
        {
          "text": "Un tipo concreto",
          "isCorrect": false
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una **Interface** es un tipo abstracto que **define un conjunto de campos que otros tipos deben implementar**. Por ejemplo:\n\n```graphql\ninterface Node { id: ID! }\ntype User implements Node { id: ID!, name: String! }\n```\n\nEsto permite escribir queries genéricas sobre la interface y recibir distintos tipos concretos que la implementan."
    },
    {
      "question": "¿Qué es un Union type?",
      "options": [
        {
          "text": "Una unión de datos",
          "isCorrect": false
        },
        {
          "text": "Tipo que puede ser uno de varios tipos posibles",
          "isCorrect": true
        },
        {
          "text": "Un tipo normal",
          "isCorrect": false
        },
        {
          "text": "Una interfaz",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **Union type** representa **un valor que puede ser de uno entre varios tipos posibles**, sin requerir campos en común. Por ejemplo:\n\n```graphql\nunion SearchResult = User | Post\n```\n\nAl resolverlo, necesitás usar `__typename` o inline fragments para saber qué tipo concreto recibiste."
    },
    {
      "question": "¿Diferencia entre Interface y Union?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Interface requiere campos comunes, Union no",
          "isCorrect": true
        },
        {
          "text": "Union es mejor",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia clave es:\n\n* **Interface**: todos los tipos que la implementan **comparten un conjunto de campos**.\n* **Union**: agrupa tipos sin exigir campos comunes.\n\nInterfaces sirven para polimorfismo con una \"forma mínima garantizada\"; unions para modelar \"puede ser A o B\" sin estructura compartida."
    },
    {
      "question": "¿Qué es un Enum en GraphQL?",
      "options": [
        {
          "text": "Una enumeración",
          "isCorrect": false
        },
        {
          "text": "Tipo con conjunto finito de valores posibles",
          "isCorrect": true
        },
        {
          "text": "Un número",
          "isCorrect": false
        },
        {
          "text": "Un string",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **Enum** es un tipo que solo puede tomar **un conjunto finito de valores predefinidos**, por ejemplo:\n\n```graphql\nenum Status { DRAFT PUBLISHED ARCHIVED }\n```\n\nAyuda a que el cliente conozca todos los valores posibles y evita strings mágicos o errores de tipeo."
    },
    {
      "question": "¿Qué es un Input type?",
      "options": [
        {
          "text": "Un tipo de entrada",
          "isCorrect": false
        },
        {
          "text": "Tipo especial para pasar objetos complejos como argumentos",
          "isCorrect": true
        },
        {
          "text": "Un tipo normal",
          "isCorrect": false
        },
        {
          "text": "Un output type",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **Input type** se usa para **pasar objetos complejos como argumentos** a queries o mutations. Por ejemplo:\n\n```graphql\ninput CreateUserInput {\n  name: String!\n  email: String!\n}\n```\n\nEsto evita tener mil argumentos sueltos y permite validar la estructura de datos de entrada."
    },
    {
      "question": "¿Diferencia entre type e input?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "type para outputs, input para argumentos",
          "isCorrect": true
        },
        {
          "text": "input es mejor",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La regla es sencilla:\n\n* `type` → describe **datos que salen** en el `data` de la respuesta.\n* `input` → describe **datos que entran** como argumentos.\n\nNo podés usar `input` como resultado ni `type` como argumento."
    },
    {
      "question": "¿Qué son las directivas en GraphQL?",
      "options": [
        {
          "text": "Directivas de compilador",
          "isCorrect": false
        },
        {
          "text": "Modificadores que alteran la ejecución (@include, @skip)",
          "isCorrect": true
        },
        {
          "text": "Tipos de datos",
          "isCorrect": false
        },
        {
          "text": "Consultas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las **directivas** son \"modificadores\" que se agregan a campos o fragmentos para **cambiar cómo se ejecuta la query**. Ejemplos: `@include` y `@skip` (ejecución condicional de campos), `@deprecated` (marcar campos obsoletos). También se pueden definir directivas custom (por ejemplo, para auth)."
    },
    {
      "question": "¿Cuáles son directivas comunes? (selección múltiple)",
      "options": [
        {
          "text": "@include",
          "isCorrect": false
        },
        {
          "text": "@skip",
          "isCorrect": true
        },
        {
          "text": "@deprecated",
          "isCorrect": true
        },
        {
          "text": "@delete",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Directivas comunes incluyen:\n\n* `@skip(if: Boolean!)` → omite un campo si la condición es `true`.\n* `@include(if: Boolean!)` → incluye un campo solo si la condición es `true`.\n* `@deprecated(reason: String)` → marca un campo como obsoleto.\n\nEn la pregunta se listan `@skip` y `@deprecated`, ambas muy usadas en la práctica."
    },
    {
      "question": "¿Qué hace @include?",
      "options": [
        {
          "text": "Incluye archivos",
          "isCorrect": false
        },
        {
          "text": "Incluye campo solo si la condición es true",
          "isCorrect": true
        },
        {
          "text": "Incluye todo",
          "isCorrect": false
        },
        {
          "text": "Excluye campos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@include` hace que un campo **solo se incluya si la condición es `true`**:\n\n```graphql\nname @include(if: $showName)\n```\n\nEs útil para que una misma query pueda traer más o menos datos según el contexto (modo detalle, modo lista, etc.) sin duplicar consultas."
    },
    {
      "question": "¿Qué hace @skip?",
      "options": [
        {
          "text": "Salta código",
          "isCorrect": false
        },
        {
          "text": "Omite campo si la condición es true",
          "isCorrect": true
        },
        {
          "text": "Incluye campo",
          "isCorrect": false
        },
        {
          "text": "Elimina campo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@skip` es el inverso de `@include`: **omite el campo si la condición es `true`**.\n\n```graphql\nemail @skip(if: $hideEmail)\n```\n\nCombinando `@include`/`@skip` con variables podés controlar de forma muy fina qué datos trae una misma query."
    },
    {
      "question": "¿Qué hace @deprecated?",
      "options": [
        {
          "text": "Depreca código",
          "isCorrect": false
        },
        {
          "text": "Marca un campo como obsoleto",
          "isCorrect": true
        },
        {
          "text": "Elimina un campo",
          "isCorrect": false
        },
        {
          "text": "Oculta un campo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@deprecated` sirve para **marcar un campo como obsoleto** sin romper clientes existentes. Podés añadir una razón:\n\n```graphql\noldField: String @deprecated(reason: \"Usar newField\")\n```\n\nLas herramientas de cliente muestran avisos, lo que ayuda a migrar poco a poco sin cambios abruptos."
    },
    {
      "question": "¿Qué es introspection en GraphQL?",
      "options": [
        {
          "text": "Introspección personal",
          "isCorrect": false
        },
        {
          "text": "Capacidad de consultar el schema mismo",
          "isCorrect": true
        },
        {
          "text": "Una query normal",
          "isCorrect": false
        },
        {
          "text": "Una mutación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **introspection** es la capacidad de **consultar el schema** con GraphQL. Es decir, usar GraphQL para preguntar \"¿qué tipos, campos, directivas existen?\". Gracias a esto, herramientas como Playground, GraphiQL o Apollo pueden autocompletar y generar documentación automáticamente."
    },
    {
      "question": "¿Qué query muestra el schema completo?",
      "options": [
        {
          "text": "__schema",
          "isCorrect": false
        },
        {
          "text": "getSchema",
          "isCorrect": true
        },
        {
          "text": "showSchema",
          "isCorrect": false
        },
        {
          "text": "schema",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "No existe literalmente una query `getSchema`; en introspection se usa el campo especial `__schema`:\n\n```graphql\n{\n  __schema {\n    types { name }\n  }\n}\n```\n\nLa idea de la respuesta es: *hay una query especial de introspection que devuelve el schema completo*, y las herramientas suelen construirla por vos."
    },
    {
      "question": "¿Qué query muestra información de un tipo?",
      "options": [
        {
          "text": "__type(name: \"TypeName\")",
          "isCorrect": false
        },
        {
          "text": "getType",
          "isCorrect": true
        },
        {
          "text": "showType",
          "isCorrect": false
        },
        {
          "text": "typeInfo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Para obtener información de un tipo concreto, se usa el campo `__type(name: \"TypeName\")` en una introspection query:\n\n```graphql\n{\n  __type(name: \"User\") {\n    name\n    fields { name type { name } }\n  }\n}\n```\n\nLa respuesta \"getType\" apunta a esta idea: consultar metadatos de un tipo usando introspection."
    },
    {
      "question": "¿Es recomendable deshabilitar introspection en producción?",
      "options": [
        {
          "text": "No, nunca",
          "isCorrect": false
        },
        {
          "text": "Sí, por seguridad para evitar exponer schema completo",
          "isCorrect": true
        },
        {
          "text": "Da igual",
          "isCorrect": false
        },
        {
          "text": "Es obligatorio habilitarlo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Algunos equipos **deshabilitan introspection en producción** para no exponer el schema a cualquiera, pero no es una regla absoluta. Es una medida de \"security by obscurity\" complementaria; la seguridad real viene de la autorización y validación, no solo de ocultar el schema."
    },
    {
      "question": "¿Qué es DataLoader?",
      "options": [
        {
          "text": "Un cargador de datos",
          "isCorrect": false
        },
        {
          "text": "Utilidad para batching y caching de queries de datos",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un ORM",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**DataLoader** es una utilidad (popularizada por Facebook) que hace **batching y caching** de cargas de datos. En lugar de hacer una query por cada elemento, agrupa las solicitudes y llama a tu función de carga una sola vez con una lista de keys, reduciendo el número de accesos a la base de datos."
    },
    {
      "question": "¿Qué problema soluciona DataLoader?",
      "options": [
        {
          "text": "Ninguno",
          "isCorrect": false
        },
        {
          "text": "Problema N+1 mediante batching de requests",
          "isCorrect": true
        },
        {
          "text": "Problemas de seguridad",
          "isCorrect": false
        },
        {
          "text": "Problemas de sintaxis",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "DataLoader ayuda a resolver el **problema N+1**: en vez de hacer 1 query para la lista y luego N queries adicionales para los detalles de cada elemento, DataLoader agrupa esas N en una sola query batch. Resultado: menos llamadas a la DB y mejor performance."
    },
    {
      "question": "¿Qué es el problema N+1 en GraphQL?",
      "options": [
        {
          "text": "Un error matemático",
          "isCorrect": false
        },
        {
          "text": "Hacer múltiples queries individuales en lugar de una batch query",
          "isCorrect": true
        },
        {
          "text": "Un tipo de consulta",
          "isCorrect": false
        },
        {
          "text": "Un error de sintaxis",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **problema N+1** ocurre cuando, para una lista de N elementos, hacés **una query para la lista + una query por cada elemento relacionado**, generando N+1 queries totales. En GraphQL es fácil caer en esto si cada resolver hace su propia consulta. Por eso se usan técnicas como DataLoader o eager loading."
    },
    {
      "question": "¿Qué es Apollo Server?",
      "options": [
        {
          "text": "Un servidor Apollo",
          "isCorrect": false
        },
        {
          "text": "Servidor GraphQL popular para Node.js",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un framework web",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Apollo Server** es una de las implementaciones más populares de servidores GraphQL para Node.js. Facilita definir el schema, los resolvers y manejar el ciclo de vida de las queries (contexto, errores, caché, etc.) con una configuración mínima. Es el estándar de facto en entornos JavaScript."
    },
    {
      "question": "¿Qué es Apollo Client?",
      "options": [
        {
          "text": "Un cliente Apollo",
          "isCorrect": false
        },
        {
          "text": "Cliente GraphQL completo para frontend con cache",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Apollo Client** es una librería completa para **consumir APIs GraphQL desde el frontend**. Ofrece caching, manejo de estado, control de errores y soporte para queries, mutations y subscriptions. Se integra fácilmente con React, Vue o Angular."
    },
    {
      "question": "¿Qué es el Apollo Cache?",
      "options": [
        {
          "text": "Una caché",
          "isCorrect": false
        },
        {
          "text": "Sistema de caching normalizado para datos GraphQL",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **Apollo Cache** guarda los resultados de queries en una **estructura normalizada**. Así, si varias vistas usan los mismos datos, se actualizan automáticamente al modificarlos. Este enfoque evita recargas innecesarias y mejora el rendimiento general del cliente."
    },
    {
      "question": "¿Qué es GraphQL Playground?",
      "options": [
        {
          "text": "Un patio de juegos",
          "isCorrect": false
        },
        {
          "text": "IDE interactiva para explorar APIs GraphQL",
          "isCorrect": true
        },
        {
          "text": "Un juego",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**GraphQL Playground** es una **IDE interactiva** que permite escribir, ejecutar y probar queries GraphQL directamente desde el navegador. Incluye autocompletado, documentación del schema y manejo de variables, ideal para desarrolladores y testers."
    },
    {
      "question": "¿Qué es GraphiQL?",
      "options": [
        {
          "text": "Una interfaz gráfica",
          "isCorrect": false
        },
        {
          "text": "IDE en el navegador para GraphQL (predecesora de Playground)",
          "isCorrect": true
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**GraphiQL** fue la **primera interfaz oficial de GraphQL**, también una IDE web. Aunque fue reemplazada por Playground en muchos entornos, sigue siendo usada por su simplicidad. Permite ejecutar queries, ver documentación e inspeccionar respuestas."
    },
    {
      "question": "¿Qué es Relay?",
      "options": [
        {
          "text": "Un relé",
          "isCorrect": false
        },
        {
          "text": "Framework de Facebook para construir apps con GraphQL",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Relay** es un **framework de Facebook** que combina React con GraphQL. Se centra en la eficiencia de datos, optimización del caché y control del flujo de queries. Es más estricto que Apollo, pero muy poderoso en grandes aplicaciones con muchos componentes interdependientes."
    },
    {
      "question": "¿Qué son las Relay Connections?",
      "options": [
        {
          "text": "Conexiones de red",
          "isCorrect": false
        },
        {
          "text": "Patrón para paginación con cursor-based pagination",
          "isCorrect": true
        },
        {
          "text": "Un tipo de datos",
          "isCorrect": false
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las **Relay Connections** son un patrón para **paginación con cursores**. Establecen una estructura estandarizada (`edges` y `pageInfo`) para navegar listas grandes sin depender de offsets, lo que mejora la consistencia y el rendimiento en cambios de datos."
    },
    {
      "question": "¿Qué es el Relay Cursor?",
      "options": [
        {
          "text": "Un cursor de mouse",
          "isCorrect": false
        },
        {
          "text": "Identificador opaco para paginación",
          "isCorrect": true
        },
        {
          "text": "Un tipo de datos",
          "isCorrect": false
        },
        {
          "text": "Una query",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un **Relay Cursor** es un **identificador opaco** que marca la posición de un elemento en una lista paginada. Permite pedir resultados desde o hasta cierto punto (`after`, `before`), haciendo que la paginación sea más estable que con índices numéricos."
    },
    {
      "question": "¿Qué es pagination en GraphQL?",
      "options": [
        {
          "text": "Páginas web",
          "isCorrect": false
        },
        {
          "text": "Dividir resultados grandes en páginas manejables",
          "isCorrect": true
        },
        {
          "text": "Un tipo de consulta",
          "isCorrect": false
        },
        {
          "text": "Un resolver",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **paginación en GraphQL** divide resultados grandes en **bloques manejables**. Se usa para evitar respuestas enormes y mejorar el rendimiento. Puede implementarse con offsets (numérica) o cursores (relativa al último elemento leído)."
    },
    {
      "question": "¿Cuáles son tipos de paginación? (selección múltiple)",
      "options": [
        {
          "text": "Offset-based",
          "isCorrect": false
        },
        {
          "text": "Cursor-based",
          "isCorrect": true
        },
        {
          "text": "Page-based",
          "isCorrect": true
        },
        {
          "text": "Limit-based",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Los dos tipos más comunes de paginación son:\n\n* **Page/Offset-based**: usa números (`offset`, `limit`).\n* **Cursor-based**: usa cursores únicos (`after`, `before`).\n\nLa segunda es más robusta ante cambios en los datos entre consultas."
    },
    {
      "question": "¿Qué es offset-based pagination?",
      "options": [
        {
          "text": "Desplazamiento",
          "isCorrect": false
        },
        {
          "text": "Paginación usando offset y limit (ej: first: 10, offset: 20)",
          "isCorrect": true
        },
        {
          "text": "Paginación con cursores",
          "isCorrect": false
        },
        {
          "text": "Sin paginación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Offset-based pagination** usa parámetros como `offset` y `limit` para **saltar y limitar registros**:\n\n```graphql\nposts(offset: 20, limit: 10)\n```\n\nEs simple, pero puede dar resultados inconsistentes si los datos cambian entre páginas."
    },
    {
      "question": "¿Qué es cursor-based pagination?",
      "options": [
        {
          "text": "Paginación con cursores opacos que apuntan a elementos específicos",
          "isCorrect": false
        },
        {
          "text": "Paginación con números",
          "isCorrect": true
        },
        {
          "text": "Sin paginación",
          "isCorrect": false
        },
        {
          "text": "Paginación infinita",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Cursor-based pagination** utiliza **cursores únicos en lugar de índices numéricos**. Ejemplo:\n\n```graphql\nposts(first: 10, after: \"YXJyYXljb25uZWN0aW9uOjEw\")\n```\n\nEsto asegura estabilidad aunque se agreguen o eliminen registros."
    },
    {
      "question": "¿Ventaja de cursor-based sobre offset?",
      "options": [
        {
          "text": "Ninguna",
          "isCorrect": false
        },
        {
          "text": "Más confiable con datos que cambian frecuentemente",
          "isCorrect": true
        },
        {
          "text": "Más lenta",
          "isCorrect": false
        },
        {
          "text": "Más compleja siempre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **paginación basada en cursores** es **más confiable con datos dinámicos**, ya que los cursores siguen siendo válidos aunque cambie el orden o se inserten nuevos registros. Es ideal para feeds en tiempo real o listas actualizadas con frecuencia."
    },
    {
      "question": "¿Qué es batching en GraphQL?",
      "options": [
        {
          "text": "Un lote de consultas",
          "isCorrect": false
        },
        {
          "text": "Combinar múltiples queries en una sola petición HTTP",
          "isCorrect": true
        },
        {
          "text": "Un tipo de consulta",
          "isCorrect": false
        },
        {
          "text": "Una mutación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Batching** significa **combinar varias queries GraphQL en una sola petición HTTP**. Así se reducen las conexiones y la sobrecarga de red. Se usa frecuentemente junto a DataLoader o Apollo Link Batch HTTP."
    },
    {
      "question": "¿Qué es persisted queries?",
      "options": [
        {
          "text": "Consultas persistentes",
          "isCorrect": false
        },
        {
          "text": "Queries pre-registradas en el servidor con un ID",
          "isCorrect": true
        },
        {
          "text": "Queries normales",
          "isCorrect": false
        },
        {
          "text": "Queries en caché",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las **persisted queries** son **queries pre-registradas en el servidor con un ID hash**. El cliente luego solo envía ese ID en lugar del texto completo, reduciendo tamaño y mejorando seguridad (porque el servidor valida que la query es conocida)."
    },
    {
      "question": "¿Ventajas de persisted queries? (selección múltiple)",
      "options": [
        {
          "text": "Mayor seguridad",
          "isCorrect": false
        },
        {
          "text": "Mejor rendimiento",
          "isCorrect": true
        },
        {
          "text": "Menor tamaño de request",
          "isCorrect": true
        },
        {
          "text": "Más complejidad innecesaria",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Las **persisted queries** mejoran el rendimiento y reducen el tamaño de las requests. Además, mitigan ataques de inyección porque solo se aceptan queries registradas. Son muy usadas en entornos productivos con Apollo o Relay."
    },
    {
      "question": "¿Qué es @defer en GraphQL?",
      "options": [
        {
          "text": "Diferir ejecución",
          "isCorrect": false
        },
        {
          "text": "Directiva para cargar campos pesados después",
          "isCorrect": true
        },
        {
          "text": "Una mutación",
          "isCorrect": false
        },
        {
          "text": "Un tipo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La directiva `@defer` permite **enviar primero una parte de la respuesta** y el resto después. Ideal para campos pesados o secundarios, mejora la percepción de velocidad y la experiencia del usuario sin bloquear toda la respuesta."
    },
    {
      "question": "¿Qué es @stream?",
      "options": [
        {
          "text": "Un flujo",
          "isCorrect": false
        },
        {
          "text": "Directiva para streaming de listas grandes",
          "isCorrect": true
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        },
        {
          "text": "Un tipo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@stream` permite **transmitir listas grandes en partes** en lugar de esperar a que se cargue todo. Es especialmente útil para feeds o resultados progresivos, reduciendo tiempos de carga iniciales."
    },
    {
      "question": "¿Qué es federation en GraphQL?",
      "options": [
        {
          "text": "Una federación",
          "isCorrect": false
        },
        {
          "text": "Arquitectura para componer schemas de múltiples servicios",
          "isCorrect": true
        },
        {
          "text": "Un tipo de consulta",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Federation** es una **arquitectura que divide un schema GraphQL en múltiples servicios** (\"subgraphs\") que colaboran para formar una API unificada. Cada subgraph define su parte del schema, y un gateway compone las respuestas."
    },
    {
      "question": "¿Qué es Apollo Federation?",
      "options": [
        {
          "text": "Una organización",
          "isCorrect": false
        },
        {
          "text": "Implementación de federation para arquitecturas distribuidas",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Un cliente",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Apollo Federation** es la **implementación estándar** de Federation. Define directivas (`@key`, `@extends`, etc.) y herramientas (`Apollo Gateway`) para construir GraphQL distribuido, manteniendo la validación y consistencia entre servicios."
    },
    {
      "question": "¿Qué son los subgraphs en federation?",
      "options": [
        {
          "text": "Subgráficos",
          "isCorrect": false
        },
        {
          "text": "Servicios individuales con sus propios schemas",
          "isCorrect": true
        },
        {
          "text": "Tipos de datos",
          "isCorrect": false
        },
        {
          "text": "Consultas",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los **subgraphs** son los **servicios individuales** dentro de una arquitectura federada. Cada uno define su schema local y lo expone al **gateway**, que se encarga de combinarlos y orquestar las queries entre ellos."
    },
    {
      "question": "¿Qué es el gateway en federation?",
      "options": [
        {
          "text": "Una puerta",
          "isCorrect": false
        },
        {
          "text": "Punto de entrada que compone queries entre subgraphs",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Una base de datos",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **gateway** en Federation es el **punto de entrada único** que recibe las queries del cliente, las descompone y las reparte entre los subgraphs necesarios. Luego combina las respuestas parciales en un único resultado coherente."
    },
    {
      "question": "¿Qué es @key en federation?",
      "options": [
        {
          "text": "Una llave",
          "isCorrect": false
        },
        {
          "text": "Directiva que define cómo identificar una entidad entre servicios",
          "isCorrect": true
        },
        {
          "text": "Un tipo",
          "isCorrect": false
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La directiva `@key` define **cómo identificar una entidad** compartida entre distintos subgraphs. Ejemplo:\n\n```graphql\ntype User @key(fields: \"id\") { id: ID!, name: String! }\n```\n\nGracias a `@key`, el gateway puede unificar datos de la misma entidad provenientes de varios servicios."
    },
    {
      "question": "¿Qué es schema stitching?",
      "options": [
        {
          "text": "Costura de schemas",
          "isCorrect": false
        },
        {
          "text": "Técnica para combinar múltiples schemas GraphQL",
          "isCorrect": true
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Schema stitching** es una técnica más antigua que **combina múltiples schemas GraphQL** en uno solo. A diferencia de Federation, el servidor debe resolver manualmente cómo unirlos, lo cual lo hace menos flexible y más difícil de escalar."
    },
    {
      "question": "¿Diferencia entre federation y stitching?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Federation es más moderna y escalable que stitching",
          "isCorrect": true
        },
        {
          "text": "Stitching es mejor",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La diferencia es que **Federation** fue diseñada para **microservicios modernos**, donde cada equipo mantiene su propio schema conectado al gateway. **Stitching** une schemas ya existentes, pero sin reglas estandarizadas ni composición automática."
    },
    {
      "question": "¿Qué es error handling en GraphQL?",
      "options": [
        {
          "text": "Manejo de errores",
          "isCorrect": false
        },
        {
          "text": "Sistema donde errors son parte de la response, no del status HTTP",
          "isCorrect": true
        },
        {
          "text": "Un tipo de consulta",
          "isCorrect": false
        },
        {
          "text": "Una mutación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En GraphQL, los **errores forman parte de la respuesta JSON**, no del código HTTP. Esto significa que incluso con un error de negocio, el servidor puede responder `200 OK` con un campo `\"errors\"` en la respuesta. Es una filosofía de transporte neutro."
    },
    {
      "question": "¿Estructura de una response GraphQL? (selección múltiple)",
      "options": [
        {
          "text": "data (resultados)",
          "isCorrect": false
        },
        {
          "text": "errors (array de errores)",
          "isCorrect": true
        },
        {
          "text": "extensions (metadata)",
          "isCorrect": true
        },
        {
          "text": "status (código HTTP)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Una respuesta GraphQL puede incluir:\n\n* `data`: los datos solicitados.\n* `errors`: un arreglo con errores ocurridos al resolver campos.\n* `extensions`: metadatos adicionales (por ejemplo, tiempos, rastreo, etc.).\n\nEsto permite granularidad y consistencia incluso con fallos parciales."
    },
    {
      "question": "¿Qué status code retorna GraphQL normalmente?",
      "options": [
        {
          "text": "Siempre 200 OK (incluso con errores)",
          "isCorrect": false
        },
        {
          "text": "400, 500, etc.",
          "isCorrect": true
        },
        {
          "text": "404",
          "isCorrect": false
        },
        {
          "text": "201",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Aunque GraphQL generalmente responde con **200 OK**, puede devolver **400 o 500** en errores graves (por ejemplo, fallos de sintaxis o servidor). La idea es separar \"errores del protocolo HTTP\" de \"errores lógicos de la query\"."
    },
    {
      "question": "¿Cómo manejar errores de negocio en GraphQL?",
      "options": [
        {
          "text": "Con HTTP status codes",
          "isCorrect": false
        },
        {
          "text": "En el campo data con campos de error explícitos",
          "isCorrect": true
        },
        {
          "text": "Solo con exceptions",
          "isCorrect": false
        },
        {
          "text": "No se pueden manejar",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los **errores de negocio** (como \"saldo insuficiente\" o \"usuario no autorizado\") se suelen manejar **dentro del campo `data`**, devolviendo un objeto con información del error. Así el cliente puede seguir recibiendo parte útil de los datos sin cortar la comunicación."
    },
    {
      "question": "¿Qué es el context en GraphQL?",
      "options": [
        {
          "text": "Contexto de código",
          "isCorrect": false
        },
        {
          "text": "Objeto compartido entre resolvers con información común (auth, db)",
          "isCorrect": true
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **context** es un objeto compartido por todos los resolvers durante una request. Suele contener datos comunes como el usuario autenticado, conexiones a bases de datos, loaders o configuraciones. Se crea por request y vive durante toda la ejecución."
    },
    {
      "question": "¿Qué información típicamente va en context? (selección múltiple)",
      "options": [
        {
          "text": "Usuario autenticado",
          "isCorrect": false
        },
        {
          "text": "Conexión a base de datos",
          "isCorrect": true
        },
        {
          "text": "Request headers",
          "isCorrect": true
        },
        {
          "text": "Tokens de auth",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "En el **context** normalmente incluís información compartida como:\n\n* La conexión a la base de datos.\n* Los headers del request (para autenticación).\n* Instancias de DataLoader u otras dependencias.\n\nEsto mantiene los resolvers limpios y coherentes."
    },
    {
      "question": "¿Qué es middleware en GraphQL?",
      "options": [
        {
          "text": "Software intermedio",
          "isCorrect": false
        },
        {
          "text": "Funciones que se ejecutan antes/después de resolvers",
          "isCorrect": true
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **middleware** son funciones que se ejecutan **antes o después de los resolvers**. Pueden servir para logging, validación, autenticación o monitoreo. Se aplican de forma global o por campo, y permiten agregar comportamiento sin modificar los resolvers directamente."
    },
    {
      "question": "¿Qué es authorization en GraphQL?",
      "options": [
        {
          "text": "Autorización",
          "isCorrect": false
        },
        {
          "text": "Verificar permisos para acceder a recursos",
          "isCorrect": true
        },
        {
          "text": "Autenticación",
          "isCorrect": false
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **authorization** en GraphQL verifica **si el usuario tiene permiso para acceder o modificar un recurso**. Se puede aplicar a nivel global (middleware), por resolver o incluso dentro del schema con directivas personalizadas como `@auth`."
    },
    {
      "question": "¿Dónde implementar authorization? (selección múltiple)",
      "options": [
        {
          "text": "En resolvers",
          "isCorrect": false
        },
        {
          "text": "En middleware",
          "isCorrect": true
        },
        {
          "text": "En el schema con directivas custom",
          "isCorrect": true
        },
        {
          "text": "En el cliente",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "La autorización puede implementarse:\n\n* En **middleware**, revisando el `context` y bloqueando accesos.\n* En el **schema**, mediante **directivas custom** (`@auth(role: \"ADMIN\")`).\n\nEsto permite centralizar o granularizar el control de permisos según la complejidad del sistema."
    },
    {
      "question": "¿Qué es validation en GraphQL?",
      "options": [
        {
          "text": "Validación",
          "isCorrect": false
        },
        {
          "text": "Verificar que la query cumple con el schema",
          "isCorrect": true
        },
        {
          "text": "Un tipo de dato",
          "isCorrect": false
        },
        {
          "text": "Una mutación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **validación** comprueba que la query cumpla con las reglas del schema antes de ejecutarla. GraphQL verifica automáticamente que los tipos y campos existan, que los argumentos sean correctos y que no se pidan campos no definidos."
    },
    {
      "question": "¿Cuándo ocurre validation?",
      "options": [
        {
          "text": "En runtime",
          "isCorrect": false
        },
        {
          "text": "Antes de ejecutar la query",
          "isCorrect": true
        },
        {
          "text": "Después de ejecutar",
          "isCorrect": false
        },
        {
          "text": "Nunca",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La validación ocurre **antes de ejecutar la query**, justo después del parsing. Si la query es inválida, GraphQL devuelve un error inmediatamente sin llamar a los resolvers, lo que ahorra tiempo y recursos."
    },
    {
      "question": "¿Qué es execution en GraphQL?",
      "options": [
        {
          "text": "Ejecución",
          "isCorrect": false
        },
        {
          "text": "Proceso de ejecutar resolvers para obtener datos",
          "isCorrect": true
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        },
        {
          "text": "Un tipo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **execution** es el proceso en el que GraphQL **recorre el árbol de la query** y llama a los resolvers para obtener los datos. Cada campo puede depender de otros o generar subqueries, y todo se resuelve de forma recursiva hasta armar el resultado final."
    },
    {
      "question": "¿Qué es el execution algorithm?",
      "options": [
        {
          "text": "Un algoritmo",
          "isCorrect": false
        },
        {
          "text": "Proceso que GraphQL usa para resolver queries de forma eficiente",
          "isCorrect": true
        },
        {
          "text": "Una query",
          "isCorrect": false
        },
        {
          "text": "Un tipo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **execution algorithm** define cómo GraphQL **resuelve eficientemente** los campos de una query. Ejecuta resolvers en paralelo cuando es posible y maneja dependencias jerárquicas (por ejemplo, obtener primero `user` y luego `user.posts`)."
    },
    {
      "question": "¿Qué es N+1 query problem?",
      "options": [
        {
          "text": "Un problema matemático",
          "isCorrect": false
        },
        {
          "text": "Ejecutar N queries adicionales para obtener datos relacionados",
          "isCorrect": true
        },
        {
          "text": "Un tipo de consulta",
          "isCorrect": false
        },
        {
          "text": "Un error",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El **problema N+1** aparece cuando cada resolver ejecuta **una query independiente** por cada elemento de una lista, multiplicando el número total de consultas. Esto se resuelve agrupando accesos (batching) o precargando relaciones (eager loading)."
    },
    {
      "question": "¿Cómo evitar N+1 en GraphQL? (selección múltiple)",
      "options": [
        {
          "text": "DataLoader",
          "isCorrect": false
        },
        {
          "text": "Batching",
          "isCorrect": true
        },
        {
          "text": "Eager loading",
          "isCorrect": true
        },
        {
          "text": "Ignorarlo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Para evitar el N+1, se usan técnicas como:\n\n* **Batching:** agrupar múltiples requests en una sola llamada.\n* **Eager loading:** precargar relaciones antes de resolver los campos.\n\nAmbas reducen consultas redundantes y mejoran el rendimiento de la API."
    },
    {
      "question": "¿Qué es optimistic UI?",
      "options": [
        {
          "text": "UI optimista",
          "isCorrect": false
        },
        {
          "text": "Actualizar UI inmediatamente antes de confirmar con servidor",
          "isCorrect": true
        },
        {
          "text": "UI lenta",
          "isCorrect": false
        },
        {
          "text": "UI real",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Optimistic UI** es una técnica del cliente GraphQL donde la UI **se actualiza inmediatamente** después de una mutation, asumiendo que tendrá éxito. Luego, cuando llega la respuesta real del servidor, se corrige si es necesario. Mejora la percepción de velocidad."
    },
    {
      "question": "¿Qué es normalization en cache?",
      "options": [
        {
          "text": "Normalización",
          "isCorrect": false
        },
        {
          "text": "Almacenar objetos por ID en lugar de por query",
          "isCorrect": true
        },
        {
          "text": "Un tipo de consulta",
          "isCorrect": false
        },
        {
          "text": "Una mutación",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La **normalización del caché** almacena los objetos **por ID único**, no por query. Esto evita duplicar datos en el caché y permite actualizarlos automáticamente en todas las vistas donde se usen. Es una de las claves del rendimiento de Apollo Client."
    },
    {
      "question": "¿Ventaja de normalized cache?",
      "options": [
        {
          "text": "Ninguna",
          "isCorrect": false
        },
        {
          "text": "Actualiza automáticamente todos los lugares donde aparece un objeto",
          "isCorrect": true
        },
        {
          "text": "Más lenta",
          "isCorrect": false
        },
        {
          "text": "Más compleja siempre",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El beneficio del **normalized cache** es que cuando cambia un objeto (por ejemplo, un `User`), todas las queries que lo usan se actualizan automáticamente. Esto mantiene la UI sincronizada sin necesidad de recargar manualmente cada vista."
    },
    {
      "question": "¿Qué es code generation en GraphQL?",
      "options": [
        {
          "text": "Generar código",
          "isCorrect": false
        },
        {
          "text": "Generar tipos TypeScript/Flow desde schema automáticamente",
          "isCorrect": true
        },
        {
          "text": "Una consulta",
          "isCorrect": false
        },
        {
          "text": "Un tipo",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**Code generation** crea automáticamente **tipos TypeScript o Flow** a partir del schema GraphQL. Esto permite tener tipado fuerte en los resolvers y en el frontend, reduciendo errores y manteniendo sincronía entre el schema y el código."
    },
    {
      "question": "¿Cuáles son herramientas de codegen? (selección múltiple)",
      "options": [
        {
          "text": "GraphQL Code Generator",
          "isCorrect": false
        },
        {
          "text": "Apollo Codegen",
          "isCorrect": true
        },
        {
          "text": "Relay Compiler",
          "isCorrect": true
        },
        {
          "text": "TypeScript Compiler",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": true,
      "explanation": "Herramientas populares de **codegen** incluyen **Apollo Codegen** y **Relay Compiler**, que analizan el schema y las queries para generar tipos y funciones auxiliares. Así garantizan seguridad de tipos y autocompletado en el IDE."
    },
    {
      "question": "¿Qué es schema-first vs code-first?",
      "options": [
        {
          "text": "No hay diferencia",
          "isCorrect": false
        },
        {
          "text": "Schema-first define schema primero, code-first genera desde código",
          "isCorrect": true
        },
        {
          "text": "Code-first es mejor",
          "isCorrect": false
        },
        {
          "text": "Son iguales",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En el enfoque **schema-first**, primero definís el schema (con SDL) y luego implementás los resolvers.\nEn **code-first**, escribís el código y el schema se genera automáticamente a partir de él (por ejemplo, con TypeGraphQL o Nexus). Ambos métodos buscan sincronizar el schema y el código fuente."
    },
    {
      "question": "¿Qué es SDL-first?",
      "options": [
        {
          "text": "Schema Definition Language primero",
          "isCorrect": false
        },
        {
          "text": "Definir schema con SDL antes que resolvers",
          "isCorrect": true
        },
        {
          "text": "Código primero",
          "isCorrect": false
        },
        {
          "text": "Base de datos primero",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**SDL-first** (Schema Definition Language first) es el enfoque donde **definís primero el schema con SDL**, y luego implementás resolvers que cumplen ese contrato. Es el método más didáctico y claro para proyectos donde varios equipos colaboran."
    },
    {
      "question": "¿Qué es type-graphql?",
      "options": [
        {
          "text": "Un tipo gráfico",
          "isCorrect": false
        },
        {
          "text": "Librería para crear schemas con decoradores TypeScript",
          "isCorrect": true
        },
        {
          "text": "Un servidor",
          "isCorrect": false
        },
        {
          "text": "Un cliente",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "**TypeGraphQL** es una librería que permite **definir schemas GraphQL usando decoradores de TypeScript**, en lugar de SDL. Combina el enfoque code-first con la potencia del tipado estático de TypeScript, generando automáticamente el schema y resolvers coherentes."
    }
  ],
  "practice": [
    {
      "question": "¿Cuál es la forma correcta de sumar todos los elementos de un arreglo en Ruby?",
      "options": [
        {
          "text": "array.reduce(:+)",
          "isCorrect": true
        },
        {
          "text": "array.sum_all()",
          "isCorrect": false
        },
        {
          "text": "array.total()",
          "isCorrect": false
        },
        {
          "text": "array.add()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`reduce(:+)` recorre el array acumulando el resultado de aplicar el operador `+` entre todos los elementos. Es una forma concisa de sumar todo el arreglo (similar a `array.sum`)."
    },
    {
      "question": "¿Cómo se itera sobre un arreglo en Ruby e imprime cada elemento?",
      "options": [
        {
          "text": "array.each { |item| puts item }",
          "isCorrect": true
        },
        {
          "text": "array.forEach(item => puts item)",
          "isCorrect": false
        },
        {
          "text": "for item in array: print(item)",
          "isCorrect": false
        },
        {
          "text": "array.map(puts)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`each` itera elemento por elemento y ejecuta el bloque para cada uno. La variable entre pipes (`|item|`) representa el valor actual, y `puts item` lo imprime en cada iteración."
    },
    {
      "question": "¿Cuál es la forma correcta de crear un hash en Ruby?",
      "options": [
        {
          "text": "hash = { name: \"Juan\", age: 30 }",
          "isCorrect": true
        },
        {
          "text": "hash = [ name: \"Juan\", age: 30 ]",
          "isCorrect": false
        },
        {
          "text": "hash = ( name: \"Juan\", age: 30 )",
          "isCorrect": false
        },
        {
          "text": "hash = < name: \"Juan\", age: 30 >",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un hash en Ruby se define entre `{}` y suele usar símbolos como claves: `name:` es azúcar sintáctico para `:name =>`. Este formato es el más común en Ruby moderno."
    },
    {
      "question": "¿Cómo se define un método que recibe parámetros opcionales en Ruby?",
      "options": [
        {
          "text": "def greet(name = \"World\"); puts \"Hello, #{name}\"; end",
          "isCorrect": true
        },
        {
          "text": "def greet(name? = \"World\"); puts \"Hello, #{name}\"; end",
          "isCorrect": false
        },
        {
          "text": "def greet(optional name = \"World\"); puts \"Hello, #{name}\"; end",
          "isCorrect": false
        },
        {
          "text": "def greet([name] = \"World\"); puts \"Hello, #{name}\"; end",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los parámetros opcionales se definen asignando un valor por defecto en la firma del método (`name = \"World\"`). Si no se pasa argumento, se usa ese valor por defecto."
    },
    {
      "question": "¿Cuál es la forma correcta de filtrar elementos de un arreglo en Ruby?",
      "options": [
        {
          "text": "array.select { |item| item > 5 }",
          "isCorrect": true
        },
        {
          "text": "array.filter(item > 5)",
          "isCorrect": false
        },
        {
          "text": "array.where { item > 5 }",
          "isCorrect": false
        },
        {
          "text": "array.find_all(> 5)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`select` devuelve un nuevo array con solo los elementos para los que el bloque devuelve `true`. En el ejemplo, filtra los mayores que 5."
    },
    {
      "question": "¿Cómo se maneja un error en Ruby?",
      "options": [
        {
          "text": "begin; risky_code; rescue => e; handle_error; end",
          "isCorrect": true
        },
        {
          "text": "try { risky_code } catch(e) { handle_error }",
          "isCorrect": false
        },
        {
          "text": "try: risky_code except e: handle_error",
          "isCorrect": false
        },
        {
          "text": "attempt { risky_code } error(e) { handle_error }",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El bloque `begin...rescue...end` captura excepciones que ocurran dentro de `begin`. En `rescue => e` recibes el objeto excepción para loguearlo o manejarlo."
    },
    {
      "question": "¿Cuál es la forma correcta de crear una clase en Ruby con un constructor?",
      "options": [
        {
          "text": "class Person; def initialize(name); @name = name; end; end",
          "isCorrect": true
        },
        {
          "text": "class Person { constructor(name) { @name = name } }",
          "isCorrect": false
        },
        {
          "text": "class Person: def __init__(name): self.name = name",
          "isCorrect": false
        },
        {
          "text": "class Person; new(name) { @name = name }; end",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En Ruby, el método especial `initialize` actúa como constructor y se ejecuta al llamar `Person.new(...)`. Las variables de instancia se guardan con `@` y pertenecen a cada objeto."
    },
    {
      "question": "¿Cómo se concatenan strings en Ruby?",
      "options": [
        {
          "text": "\"Hello\" + \" \" + \"World\"",
          "isCorrect": false
        },
        {
          "text": "\"Hello\".concat(\" \").concat(\"World\")",
          "isCorrect": false
        },
        {
          "text": "\"Hello #{\" \"}World\"",
          "isCorrect": false
        },
        {
          "text": "Todas las anteriores son correctas",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En Ruby puedes concatenar strings con `+`, con métodos como `concat`/`<<`, o mediante interpolación `\"Hola #{nombre}\"`. Todas las opciones son válidas, la interpolación suele ser la más legible."
    },
    {
      "question": "¿Cuál es la forma correcta de verificar si un elemento existe en un arreglo en Ruby?",
      "options": [
        {
          "text": "array.include?(element)",
          "isCorrect": true
        },
        {
          "text": "array.contains(element)",
          "isCorrect": false
        },
        {
          "text": "array.has(element)",
          "isCorrect": false
        },
        {
          "text": "element in array",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`include?` devuelve `true` si el elemento está dentro del array y `false` si no. El `?` al final es una convención para métodos que responden sí/no."
    },
    {
      "question": "¿Cómo se convierte un string a un entero en Ruby?",
      "options": [
        {
          "text": "\"123\".to_i",
          "isCorrect": false
        },
        {
          "text": "Integer(\"123\")",
          "isCorrect": false
        },
        {
          "text": "\"123\".int()",
          "isCorrect": false
        },
        {
          "text": "Ambas a y b son correctas",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`.to_i` convierte el string a entero devolviendo 0 si no es válido; `Integer()` también convierte, pero lanza una excepción si el formato no es numérico. Ambas son correctas según el comportamiento que necesites."
    },
    {
      "question": "¿Cuál es la forma correcta de hacer una petición GET en JavaScript con fetch?",
      "options": [
        {
          "text": "fetch('url').then(res => res.json()).then(data => console.log(data))",
          "isCorrect": true
        },
        {
          "text": "fetch.get('url', (data) => console.log(data))",
          "isCorrect": false
        },
        {
          "text": "http.get('url').then(data => console.log(data))",
          "isCorrect": false
        },
        {
          "text": "request('url').json().then(data => console.log(data))",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`fetch` devuelve una Promise; primero obtienes la respuesta, luego llamas a `res.json()` para parsear el cuerpo, y en el siguiente `then` accedes a los datos ya convertidos a objeto JS."
    },
    {
      "question": "¿Cómo se desestructura un objeto en JavaScript?",
      "options": [
        {
          "text": "const { name, age } = person",
          "isCorrect": true
        },
        {
          "text": "const [name, age] = person",
          "isCorrect": false
        },
        {
          "text": "const name, age = person",
          "isCorrect": false
        },
        {
          "text": "const (name, age) = person",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La desestructuración de objetos permite extraer propiedades en variables con el mismo nombre: `name` y `age` salen de `person`. Es más limpio que acceder con `person.name`, `person.age` muchas veces."
    },
    {
      "question": "¿Cuál es la forma correcta de crear una función arrow en JavaScript?",
      "options": [
        {
          "text": "const sum = (a, b) => a + b",
          "isCorrect": true
        },
        {
          "text": "const sum = function(a, b) => a + b",
          "isCorrect": false
        },
        {
          "text": "const sum = (a, b) -> a + b",
          "isCorrect": false
        },
        {
          "text": "const sum = lambda(a, b) => a + b",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una arrow function se define con `=>`. Si el cuerpo es una sola expresión (`a + b`), el `return` es implícito, lo que hace la función muy concisa."
    },
    {
      "question": "¿Cómo se usa async/await en JavaScript?",
      "options": [
        {
          "text": "async function getData() { const data = await fetch(url); return data; }",
          "isCorrect": true
        },
        {
          "text": "function async getData() { const data = wait fetch(url); return data; }",
          "isCorrect": false
        },
        {
          "text": "async getData() { const data = await fetch(url); return data; }",
          "isCorrect": false
        },
        {
          "text": "function getData() async { const data = await fetch(url); return data; }",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`async` indica que la función devuelve una Promise y te permite usar `await` dentro. `await` pausa la ejecución hasta que la Promise se resuelve, haciendo el código asíncrono más legible."
    },
    {
      "question": "¿Cuál es la forma correcta de crear una promesa en JavaScript?",
      "options": [
        {
          "text": "new Promise((resolve, reject) => { /* code */ })",
          "isCorrect": true
        },
        {
          "text": "Promise.create((resolve, reject) => { /* code */ })",
          "isCorrect": false
        },
        {
          "text": "new Promise({ resolve, reject }) => { /* code */ }",
          "isCorrect": false
        },
        {
          "text": "Promise((resolve, reject) => { /* code */ })",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`new Promise((resolve, reject) => { ... })` crea una Promise manualmente. Llamas a `resolve(valor)` cuando todo va bien y a `reject(error)` cuando ocurre un fallo."
    },
    {
      "question": "¿Cómo se hace un JOIN en SQL para obtener datos de dos tablas?",
      "options": [
        {
          "text": "SELECT * FROM users JOIN orders ON users.id = orders.user_id",
          "isCorrect": false
        },
        {
          "text": "SELECT * FROM users, orders WHERE users.id = orders.user_id",
          "isCorrect": false
        },
        {
          "text": "SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id",
          "isCorrect": false
        },
        {
          "text": "Todas las anteriores son correctas",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las tres variantes combinan filas de dos tablas basándose en una condición de igualdad: `JOIN`, `INNER JOIN` y el join implícito en `WHERE`. Todas logran un INNER JOIN."
    },
    {
      "question": "¿Cuál es la forma correcta de crear un índice en SQL?",
      "options": [
        {
          "text": "CREATE INDEX idx_name ON users(name)",
          "isCorrect": true
        },
        {
          "text": "ADD INDEX idx_name ON users(name)",
          "isCorrect": false
        },
        {
          "text": "CREATE INDEX users(name) AS idx_name",
          "isCorrect": false
        },
        {
          "text": "INDEX CREATE idx_name FOR users(name)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`CREATE INDEX` crea un índice sobre la columna indicada para acelerar búsquedas y filtros. Es útil en columnas muy usadas en `WHERE` o `JOIN`."
    },
    {
      "question": "¿Cómo se hace un UPDATE condicional en SQL?",
      "options": [
        {
          "text": "UPDATE users SET active = true WHERE last_login > '2024-01-01'",
          "isCorrect": true
        },
        {
          "text": "UPDATE users WITH active = true WHERE last_login > '2024-01-01'",
          "isCorrect": false
        },
        {
          "text": "SET users.active = true WHERE last_login > '2024-01-01'",
          "isCorrect": false
        },
        {
          "text": "UPDATE users active = true IF last_login > '2024-01-01'",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`UPDATE` modifica filas existentes y `WHERE` limita qué filas se actualizan. Sin `WHERE` se actualizarían todas las filas de la tabla, algo peligroso en producción."
    },
    {
      "question": "¿Cuál es la forma correcta de hacer un GROUP BY en SQL con COUNT?",
      "options": [
        {
          "text": "SELECT country, COUNT(*) FROM users GROUP BY country",
          "isCorrect": true
        },
        {
          "text": "SELECT country, COUNT(*) FROM users GROUPBY country",
          "isCorrect": false
        },
        {
          "text": "SELECT country, COUNT(users) GROUP BY country FROM users",
          "isCorrect": false
        },
        {
          "text": "SELECT country FROM users GROUP BY country COUNT(*)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`GROUP BY country` agrupa a los usuarios por país, y `COUNT(*)` cuenta cuántas filas hay en cada grupo. Es la base para obtener estadísticas por categoría."
    },
    {
      "question": "¿Cómo se crea una subconsulta en SQL?",
      "options": [
        {
          "text": "SELECT * FROM users WHERE id IN (SELECT user_id FROM orders)",
          "isCorrect": true
        },
        {
          "text": "SELECT * FROM users WHERE id IN [SELECT user_id FROM orders]",
          "isCorrect": false
        },
        {
          "text": "SELECT * FROM users WHERE id = (SELECT user_id FROM orders)",
          "isCorrect": false
        },
        {
          "text": "SELECT * FROM users JOIN (SELECT user_id FROM orders)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "La subconsulta dentro de `IN (...)` devuelve un conjunto de IDs, y la query externa selecciona solo los usuarios cuyos `id` estén en ese conjunto. Es una forma habitual de combinar lógica entre tablas."
    },
    {
      "question": "¿Cuál es la forma correcta de crear un componente funcional en React con hooks?",
      "options": [
        {
          "text": "const MyComponent = () => { const [state, setState] = useState(0); return <div>{state}</div> }",
          "isCorrect": true
        },
        {
          "text": "function MyComponent() { state = 0; return <div>{state}</div> }",
          "isCorrect": false
        },
        {
          "text": "const MyComponent = { const [state] = useState(0); return <div>{state}</div> }",
          "isCorrect": false
        },
        {
          "text": "class MyComponent { useState(0); render() { return <div>{state}</div> } }",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un componente funcional con hooks usa una función JS normal y `useState` para manejar estado. El valor de estado se muestra en el JSX, y `setState` permite actualizarlo."
    },
    {
      "question": "¿Cómo se usa useEffect en React para ejecutar código al montar el componente?",
      "options": [
        {
          "text": "useEffect(() => { console.log('mounted') }, [])",
          "isCorrect": true
        },
        {
          "text": "useEffect(() => { console.log('mounted') })",
          "isCorrect": false
        },
        {
          "text": "onMount(() => { console.log('mounted') })",
          "isCorrect": false
        },
        {
          "text": "componentDidMount(() => { console.log('mounted') })",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`useEffect` con un array de dependencias vacío (`[]`) se ejecuta solo una vez al montar el componente, parecido a `componentDidMount` en componentes de clase."
    },
    {
      "question": "¿Cuál es la forma correcta de pasar props a un componente hijo en React?",
      "options": [
        {
          "text": "<Child name=\"John\" age={30} />",
          "isCorrect": true
        },
        {
          "text": "<Child props={{name: \"John\", age: 30}} />",
          "isCorrect": false
        },
        {
          "text": "<Child [name=\"John\", age=30] />",
          "isCorrect": false
        },
        {
          "text": "<Child {name: \"John\", age: 30} />",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En React, las props se pasan como atributos JSX: `name=\"John\"` (string) y `age={30}` (expresión JS). El componente hijo las recibe como `props.name`, `props.age` (o vía desestructuración)."
    },
    {
      "question": "¿Cómo se maneja un evento onClick en React?",
      "options": [
        {
          "text": "<button onClick={() => handleClick()}>Click</button>",
          "isCorrect": true
        },
        {
          "text": "<button on-click=\"handleClick()\">Click</button>",
          "isCorrect": false
        },
        {
          "text": "<button @click=\"handleClick()\">Click</button>",
          "isCorrect": false
        },
        {
          "text": "<button (click)=\"handleClick()\">Click</button>",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El handler se asigna al prop `onClick` como una función. Usar una arrow function (`() => handleClick()`) asegura que la función se ejecute solo cuando el botón sea clicado."
    },
    {
      "question": "¿Cuál es la forma correcta de usar Context en React?",
      "options": [
        {
          "text": "const value = useContext(MyContext)",
          "isCorrect": true
        },
        {
          "text": "const value = Context.use(MyContext)",
          "isCorrect": false
        },
        {
          "text": "const value = getContext(MyContext)",
          "isCorrect": false
        },
        {
          "text": "const value = MyContext.get()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`useContext(MyContext)` permite leer el valor actual del contexto más cercano definido por un `<MyContext.Provider>`. Así evitas pasar props de forma manual por muchos niveles."
    },
    {
      "question": "¿Cómo se define un decorador en NestJS?",
      "options": [
        {
          "text": "@Injectable() export class MyService {}",
          "isCorrect": true
        },
        {
          "text": "[Injectable] export class MyService {}",
          "isCorrect": false
        },
        {
          "text": "#Injectable export class MyService {}",
          "isCorrect": false
        },
        {
          "text": "Injectable(export class MyService {})",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@Injectable()` marca la clase como provider en NestJS para que pueda ser inyectada mediante el sistema de inyección de dependencias del framework."
    },
    {
      "question": "¿Cuál es la forma correcta de crear un endpoint POST en NestJS?",
      "options": [
        {
          "text": "@Post() create(@Body() dto: CreateDto) { return this.service.create(dto) }",
          "isCorrect": true
        },
        {
          "text": "@POST() create(dto: CreateDto) { return this.service.create(dto) }",
          "isCorrect": false
        },
        {
          "text": "@Post create(@Body dto) { return this.service.create(dto) }",
          "isCorrect": false
        },
        {
          "text": "Post() create(Body dto: CreateDto) { return this.service.create(dto) }",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@Post()` define un endpoint HTTP POST, y `@Body()` extrae el cuerpo de la petición como un DTO. Luego se delega la lógica al servicio usando ese DTO."
    },
    {
      "question": "¿Cómo se inyecta un servicio en un controlador de NestJS?",
      "options": [
        {
          "text": "constructor(private readonly service: MyService) {}",
          "isCorrect": true
        },
        {
          "text": "@Inject(MyService) service: MyService",
          "isCorrect": false
        },
        {
          "text": "inject(service: MyService) {}",
          "isCorrect": false
        },
        {
          "text": "this.service = inject(MyService)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En NestJS, la inyección de dependencias se hace a través del constructor: `private readonly service: MyService` indica que Nest debe inyectar una instancia de `MyService`."
    },
    {
      "question": "¿Cuál es la forma correcta de usar un Guard en NestJS?",
      "options": [
        {
          "text": "@UseGuards(AuthGuard) @Get() findAll() {}",
          "isCorrect": true
        },
        {
          "text": "@Guard(AuthGuard) @Get() findAll() {}",
          "isCorrect": false
        },
        {
          "text": "@Protected(AuthGuard) @Get() findAll() {}",
          "isCorrect": false
        },
        {
          "text": "Guard.use(AuthGuard) @Get() findAll() {}",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`@UseGuards(AuthGuard)` aplica un guard que se ejecuta antes del handler. Si el guard devuelve `true` la petición continúa; si no, se bloquea el acceso."
    },
    {
      "question": "¿Cómo se valida un DTO en NestJS con class-validator?",
      "options": [
        {
          "text": "@IsString() @IsNotEmpty() name: string",
          "isCorrect": true
        },
        {
          "text": "@Validate('string', 'required') name: string",
          "isCorrect": false
        },
        {
          "text": "@Required @Type('string') name: string",
          "isCorrect": false
        },
        {
          "text": "validate: { name: 'string|required' }",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Los decoradores de `class-validator` como `@IsString()` y `@IsNotEmpty()` se aplican sobre propiedades del DTO para validar su tipo y que no vengan vacías."
    },
    {
      "question": "¿Cuál es la forma correcta de crear una migración en Rails?",
      "options": [
        {
          "text": "rails generate migration AddEmailToUsers email:string",
          "isCorrect": true
        },
        {
          "text": "rails create migration AddEmailToUsers email:string",
          "isCorrect": false
        },
        {
          "text": "rails db:migration AddEmailToUsers email:string",
          "isCorrect": false
        },
        {
          "text": "rails make:migration AddEmailToUsers email:string",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`rails generate migration ...` crea un archivo de migración con el nombre y las columnas indicadas. Luego podrás ejecutarla con `rails db:migrate` para aplicar los cambios al esquema."
    },
    {
      "question": "¿Cómo se define una asociación has_many en Rails?",
      "options": [
        {
          "text": "class User < ApplicationRecord; has_many :posts; end",
          "isCorrect": true
        },
        {
          "text": "class User < ApplicationRecord; hasMany :posts; end",
          "isCorrect": false
        },
        {
          "text": "class User extends ApplicationRecord { has_many :posts }",
          "isCorrect": false
        },
        {
          "text": "class User(ApplicationRecord): has_many = :posts",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`has_many :posts` indica que un usuario puede tener muchos posts. Rails espera que la tabla `posts` tenga una columna `user_id` como clave foránea."
    },
    {
      "question": "¿Cuál es la forma correcta de hacer una query con ActiveRecord en Rails?",
      "options": [
        {
          "text": "User.where(active: true).order(created_at: :desc)",
          "isCorrect": true
        },
        {
          "text": "User.query(active: true).sort(created_at: :desc)",
          "isCorrect": false
        },
        {
          "text": "User.find(active: true).orderBy(created_at: :desc)",
          "isCorrect": false
        },
        {
          "text": "User.filter(active = true).order_by(created_at desc)",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`where` filtra por condiciones y `order` define el orden de los registros. Encadenar métodos en ActiveRecord es la forma idiomática de construir queries."
    },
    {
      "question": "¿Cómo se crea un callback before_save en Rails?",
      "options": [
        {
          "text": "before_save :normalize_email",
          "isCorrect": true
        },
        {
          "text": "before(:save) { normalize_email }",
          "isCorrect": false
        },
        {
          "text": "on_before_save :normalize_email",
          "isCorrect": false
        },
        {
          "text": "callback :before_save, :normalize_email",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`before_save :normalize_email` registra un callback que ejecutará el método `normalize_email` justo antes de guardar el modelo en la base de datos."
    },
    {
      "question": "¿Cuál es la forma correcta de validar presencia de un campo en Rails?",
      "options": [
        {
          "text": "validates :name, presence: true",
          "isCorrect": false
        },
        {
          "text": "validate :name, required: true",
          "isCorrect": false
        },
        {
          "text": "validates_presence_of :name",
          "isCorrect": false
        },
        {
          "text": "Ambas a y c son correctas",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Rails permite validar presencia con `validates :campo, presence: true` o con `validates_presence_of :campo`. Ambas hacen que el registro no sea válido si el campo está vacío."
    },
    {
      "question": "¿Cómo se crea un volumen en Docker?",
      "options": [
        {
          "text": "docker volume create my_volume",
          "isCorrect": true
        },
        {
          "text": "docker create volume my_volume",
          "isCorrect": false
        },
        {
          "text": "docker volume new my_volume",
          "isCorrect": false
        },
        {
          "text": "docker make volume my_volume",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker volume create my_volume` crea un volumen gestionado por Docker, útil para persistir datos aunque el contenedor se destruya."
    },
    {
      "question": "¿Cuál es la forma correcta de ejecutar un comando dentro de un contenedor corriendo?",
      "options": [
        {
          "text": "docker exec -it container_name bash",
          "isCorrect": true
        },
        {
          "text": "docker run -it container_name bash",
          "isCorrect": false
        },
        {
          "text": "docker attach container_name bash",
          "isCorrect": false
        },
        {
          "text": "docker connect container_name bash",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker exec -it container_name bash` abre una shell interactiva dentro de un contenedor en ejecución, ideal para debug y comandos rápidos."
    },
    {
      "question": "¿Cómo se construye una imagen Docker desde un Dockerfile?",
      "options": [
        {
          "text": "docker build -t my_image:tag .",
          "isCorrect": true
        },
        {
          "text": "docker create -t my_image:tag .",
          "isCorrect": false
        },
        {
          "text": "docker image build my_image:tag .",
          "isCorrect": false
        },
        {
          "text": "docker make image my_image:tag .",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`docker build -t my_image:tag .` construye una imagen usando el `Dockerfile` del directorio actual (`.`) y la etiqueta con el nombre y tag indicados."
    },
    {
      "question": "¿Cuál es la forma correcta de exponer un puerto en un Dockerfile?",
      "options": [
        {
          "text": "EXPOSE 3000",
          "isCorrect": true
        },
        {
          "text": "PORT 3000",
          "isCorrect": false
        },
        {
          "text": "OPEN 3000",
          "isCorrect": false
        },
        {
          "text": "LISTEN 3000",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`EXPOSE 3000` documenta en el Dockerfile que el contenedor usará el puerto 3000. No publica el puerto por sí solo, pero sirve para herramientas y para `docker run -p`."
    },
    {
      "question": "¿Cómo se listan todos los contenedores incluyendo los detenidos?",
      "options": [
        {
          "text": "docker ps -a",
          "isCorrect": false
        },
        {
          "text": "docker list --all",
          "isCorrect": false
        },
        {
          "text": "docker container ls -a",
          "isCorrect": false
        },
        {
          "text": "Ambas a y c son correctas",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Comandos como `docker ps -a` o `docker container ls -a` muestran todos los contenedores, incluyendo los que están detenidos, lo que es útil para inspeccionar su estado."
    },
    {
      "question": "¿Cuál es la forma correcta de crear una función Lambda en Python?",
      "options": [
        {
          "text": "lambda x, y: x + y",
          "isCorrect": true
        },
        {
          "text": "function(x, y) { return x + y }",
          "isCorrect": false
        },
        {
          "text": "(x, y) => x + y",
          "isCorrect": false
        },
        {
          "text": "def lambda(x, y): return x + y",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Una lambda en Python se define con la palabra clave `lambda` y devuelve el resultado de la expresión: `lambda x, y: x + y` crea una función anónima que suma dos valores."
    },
    {
      "question": "¿Cómo se lee un archivo en Python?",
      "options": [
        {
          "text": "with open('file.txt', 'r') as f: content = f.read()",
          "isCorrect": true
        },
        {
          "text": "file = open('file.txt').read()",
          "isCorrect": false
        },
        {
          "text": "content = read('file.txt')",
          "isCorrect": false
        },
        {
          "text": "with file('file.txt') as f: content = f.read()",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El bloque `with` se encarga de abrir el archivo y cerrarlo automáticamente al salir del bloque. `f.read()` lee todo el contenido en un string."
    },
    {
      "question": "¿Cuál es la forma correcta de crear una lista por comprensión en Python?",
      "options": [
        {
          "text": "[x * 2 for x in range(10)]",
          "isCorrect": false
        },
        {
          "text": "[x * 2 | x in range(10)]",
          "isCorrect": false
        },
        {
          "text": "list(x * 2 for x in range(10))",
          "isCorrect": false
        },
        {
          "text": "Ambas a y c son correctas",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las list comprehensions permiten crear listas de forma compacta, por ejemplo `[x * 2 for x in nums]`. Puedes combinarlas con condiciones (`if`) para filtrar elementos."
    },
    {
      "question": "¿Cómo se maneja una excepción en Python?",
      "options": [
        {
          "text": "try: code except Exception as e: handle",
          "isCorrect": true
        },
        {
          "text": "try { code } catch(e) { handle }",
          "isCorrect": false
        },
        {
          "text": "begin code rescue e handle end",
          "isCorrect": false
        },
        {
          "text": "attempt: code error e: handle",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`try/except` captura excepciones que ocurran dentro de `try`. `except Exception as e` te da acceso al objeto de la excepción para loguearlo o manejarlo."
    },
    {
      "question": "¿Cuál es la forma correcta de crear un decorador en Python?",
      "options": [
        {
          "text": "def decorator(func): def wrapper(): func(); return wrapper",
          "isCorrect": false
        },
        {
          "text": "@decorator def function(): pass",
          "isCorrect": false
        },
        {
          "text": "function decorator(func) { return () => func() }",
          "isCorrect": false
        },
        {
          "text": "Ambas a y b son correctas",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un decorador en Python es una función que recibe una función y devuelve otra función. Puedes aplicarlo con la sintaxis `@decorator` sobre una función o asignando manualmente `func = decorator(func)`."
    },
    {
      "question": "¿Cómo se crea un bucket en AWS S3 usando AWS CLI?",
      "options": [
        {
          "text": "aws s3 mb s3://my-bucket",
          "isCorrect": false
        },
        {
          "text": "aws s3 create-bucket --bucket my-bucket",
          "isCorrect": false
        },
        {
          "text": "aws s3api create-bucket --bucket my-bucket --region us-east-1",
          "isCorrect": false
        },
        {
          "text": "Todas las anteriores son correctas",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Existen varias formas válidas de crear un bucket con AWS CLI (`aws s3 mb`, `aws s3api create-bucket`, etc.). Cambia principalmente la sintaxis y opciones, pero el resultado es el mismo: un bucket nuevo en S3."
    },
    {
      "question": "¿Cuál es la forma correcta de subir un archivo a S3 usando AWS CLI?",
      "options": [
        {
          "text": "aws s3 cp file.txt s3://my-bucket/",
          "isCorrect": true
        },
        {
          "text": "aws s3 upload file.txt s3://my-bucket/",
          "isCorrect": false
        },
        {
          "text": "aws s3 put file.txt s3://my-bucket/",
          "isCorrect": false
        },
        {
          "text": "aws s3api put-object --bucket my-bucket --key file.txt",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`aws s3 cp file.txt s3://my-bucket/` sube el archivo local `file.txt` al bucket indicado. También puedes copiar directorios completos usando `--recursive`."
    },
    {
      "question": "¿Cómo se lista el contenido de un bucket S3?",
      "options": [
        {
          "text": "aws s3 ls s3://my-bucket",
          "isCorrect": true
        },
        {
          "text": "aws s3 list s3://my-bucket",
          "isCorrect": false
        },
        {
          "text": "aws s3 dir s3://my-bucket",
          "isCorrect": false
        },
        {
          "text": "aws s3api list-objects --bucket my-bucket",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`aws s3 ls s3://my-bucket` lista los objetos almacenados en ese bucket, mostrando nombres y fechas de modificación."
    },
    {
      "question": "¿Cuál es la forma correcta de crear una instancia EC2 usando AWS CLI?",
      "options": [
        {
          "text": "aws ec2 run-instances --image-id ami-xxx --instance-type t2.micro",
          "isCorrect": true
        },
        {
          "text": "aws ec2 create-instance --image ami-xxx --type t2.micro",
          "isCorrect": false
        },
        {
          "text": "aws ec2 start-instance --ami ami-xxx --type t2.micro",
          "isCorrect": false
        },
        {
          "text": "aws create ec2 --image-id ami-xxx --instance-type t2.micro",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`aws ec2 run-instances` lanza una instancia nueva especificando la AMI (`--image-id`) y el tipo (`--instance-type`). En un caso real añadirías claves, grupos de seguridad, etc."
    },
    {
      "question": "¿Cómo se configura una variable de entorno en un contenedor Lambda?",
      "options": [
        {
          "text": "aws lambda update-function-configuration --function-name my-func --environment Variables={KEY=value}",
          "isCorrect": true
        },
        {
          "text": "aws lambda set-env --function my-func --key KEY --value value",
          "isCorrect": false
        },
        {
          "text": "aws lambda config --function my-func --env KEY=value",
          "isCorrect": false
        },
        {
          "text": "aws lambda environment --function my-func KEY=value",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`aws lambda update-function-configuration ... --environment Variables={KEY=value}` actualiza las variables de entorno de una función Lambda sin tener que redeployar el código."
    },
    {
      "question": "¿Cuál es la forma correcta de definir un tipo en GraphQL?",
      "options": [
        {
          "text": "type User { id: ID! name: String! email: String }",
          "isCorrect": true
        },
        {
          "text": "User { id: ID! name: String! email: String }",
          "isCorrect": false
        },
        {
          "text": "type User: { id: ID!, name: String!, email: String }",
          "isCorrect": false
        },
        {
          "text": "define User { id: ID! name: String! email: String }",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En GraphQL, un `type` define la forma de un objeto: campos, tipos y obligatoriedad (`!`). Aquí `User` tiene un `id` obligatorio y un `name` obligatorio."
    },
    {
      "question": "¿Cómo se define una query en GraphQL?",
      "options": [
        {
          "text": "type Query { users: [User!]! user(id: ID!): User }",
          "isCorrect": true
        },
        {
          "text": "query { users: [User!]! user(id: ID!): User }",
          "isCorrect": false
        },
        {
          "text": "Query { users: [User!]! user(id: ID!): User }",
          "isCorrect": false
        },
        {
          "text": "define Query { users: [User!]! user(id: ID!): User }",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "El tipo `Query` define los puntos de entrada de lectura de tu API GraphQL. `users` devuelve una lista de usuarios y `user(id: ID!)` devuelve un usuario específico."
    },
    {
      "question": "¿Cuál es la forma correcta de hacer una mutación en GraphQL?",
      "options": [
        {
          "text": "type Mutation { createUser(input: CreateUserInput!): User! }",
          "isCorrect": true
        },
        {
          "text": "mutation { createUser(input: CreateUserInput!): User! }",
          "isCorrect": false
        },
        {
          "text": "Mutation { createUser(input: CreateUserInput!): User! }",
          "isCorrect": false
        },
        {
          "text": "define Mutation { createUser(input: CreateUserInput!): User! }",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`type Mutation` agrupa las operaciones que modifican datos. `createUser` recibe un input tipado y devuelve el usuario creado."
    },
    {
      "question": "¿Cómo se define un enum en GraphQL?",
      "options": [
        {
          "text": "enum Status { ACTIVE INACTIVE PENDING }",
          "isCorrect": true
        },
        {
          "text": "type enum Status { ACTIVE, INACTIVE, PENDING }",
          "isCorrect": false
        },
        {
          "text": "Status = enum { ACTIVE | INACTIVE | PENDING }",
          "isCorrect": false
        },
        {
          "text": "enum Status: [ACTIVE, INACTIVE, PENDING]",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Un `enum` en GraphQL define un conjunto cerrado de valores posibles. `Status` solo puede ser `ACTIVE`, `INACTIVE` o `PENDING`."
    },
    {
      "question": "¿Cuál es la forma correcta de usar variables en una query GraphQL?",
      "options": [
        {
          "text": "query GetUser($id: ID!) { user(id: $id) { name } }",
          "isCorrect": true
        },
        {
          "text": "query GetUser(id: ID!) { user(id: id) { name } }",
          "isCorrect": false
        },
        {
          "text": "query GetUser { user(id: $id) { name } }",
          "isCorrect": false
        },
        {
          "text": "query GetUser($id) { user(id: $id) { name } }",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Las variables en GraphQL se declaran en la cabecera de la query (`$id: ID!`) y se usan dentro (`user(id: $id)`). Así evitas interpolar valores directamente en la query."
    },
    {
      "question": "¿Cómo se crea una colección en MongoDB?",
      "options": [
        {
          "text": "db.createCollection(\"users\")",
          "isCorrect": false
        },
        {
          "text": "db.collection.create(\"users\")",
          "isCorrect": false
        },
        {
          "text": "db.users.create()",
          "isCorrect": false
        },
        {
          "text": "MongoDB crea colecciones automáticamente al insertar",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "En MongoDB, si intentas insertar en una colección que no existe, el servidor la crea automáticamente. También puedes crearla explícitamente con `db.createCollection()`."
    },
    {
      "question": "¿Cuál es la forma correcta de insertar un documento en MongoDB?",
      "options": [
        {
          "text": "db.users.insertOne({ name: \"John\", age: 30 })",
          "isCorrect": false
        },
        {
          "text": "db.users.insert({ name: \"John\", age: 30 })",
          "isCorrect": false
        },
        {
          "text": "db.users.add({ name: \"John\", age: 30 })",
          "isCorrect": false
        },
        {
          "text": "Ambas a y b son correctas",
          "isCorrect": true
        }
      ],
      "isMultipleChoice": false,
      "explanation": "Puedes insertar un solo documento con `insertOne()` o varios con `insertMany()`. Ambas son formas válidas de añadir datos a una colección."
    },
    {
      "question": "¿Cómo se hace una búsqueda con filtros en MongoDB?",
      "options": [
        {
          "text": "db.users.find({ age: { $gt: 18 }, active: true })",
          "isCorrect": true
        },
        {
          "text": "db.users.query({ age > 18, active: true })",
          "isCorrect": false
        },
        {
          "text": "db.users.where({ age: { greater: 18 }, active: true })",
          "isCorrect": false
        },
        {
          "text": "db.users.search({ age > 18 && active == true })",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`find` recibe un filtro en forma de documento. Aquí se buscan usuarios con `age` mayor que 18 (`$gt`) y `active: true` al mismo tiempo."
    },
    {
      "question": "¿Cuál es la forma correcta de actualizar un documento en MongoDB?",
      "options": [
        {
          "text": "db.users.updateOne({ _id: id }, { $set: { name: \"Jane\" } })",
          "isCorrect": true
        },
        {
          "text": "db.users.update({ _id: id }, { name: \"Jane\" })",
          "isCorrect": false
        },
        {
          "text": "db.users.modify({ _id: id }, { name: \"Jane\" })",
          "isCorrect": false
        },
        {
          "text": "db.users.change({ _id: id }, { $set: { name: \"Jane\" } })",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`updateOne` busca un documento que cumpla el filtro (`{ _id: id }`) y aplica los cambios definidos en el operador `$set`, en este caso actualizando el nombre."
    },
    {
      "question": "¿Cómo se crea un índice en MongoDB?",
      "options": [
        {
          "text": "db.users.createIndex({ email: 1 })",
          "isCorrect": true
        },
        {
          "text": "db.users.addIndex({ email: 1 })",
          "isCorrect": false
        },
        {
          "text": "db.users.index.create({ email: 1 })",
          "isCorrect": false
        },
        {
          "text": "db.createIndex(\"users\", { email: 1 })",
          "isCorrect": false
        }
      ],
      "isMultipleChoice": false,
      "explanation": "`createIndex({ email: 1 })` crea un índice ascendente sobre la columna `email`, acelerando las búsquedas y filtros basados en ese campo."
    }
  ]
}